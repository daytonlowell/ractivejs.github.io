{
    "docs": [
        {
            "location": "/", 
            "text": "Ractive.js\n\n    \nweb apps made simple\n\n  \n\n\n\n\n\n\n  \nscript src=\"\nhttps://cdn.jsdelivr.net/npm/ractive\n\"\n/script\n\n  \n(All revisions here)\n\n\n\n\n\n\n  \n\n    \n\n      \n\n        \nLive, reactive templating\n\n        \nRactive.js is a template-driven UI library that transforms your templates, styles and logic into blueprints for highly interactive apps.\n\n      \n\n    \n\n    \n\n      \n\n        \nPowerful and extensible\n\n        \nComponents, Two-way binding, scoped CSS, SVG support, animations and much more provided out-of-the-box. And you can easily extend functionality even further with the use of plugins.\n\n      \n\n    \n\n    \n\n      \n\n        \nOptimised for your sanity\n\n        \nRactive.js works for you, not the other way around. You do not need to learn new terminologies, concepts, and methodologies. And it plays well with libraries you already know and like to use.\n\n      \n\n    \n\n  \n\n\n\n\n\n\n  \n\n  \n\n  \n\n  \n\n  \n\n  \n\n  \n\n  \n\n\n\n\n\n\n  \n\n    \n\n      \n\n        \nAbout Ractive.js\n\n        \nRactive was originally created at The Guardian \ntheguardian.com\n to produce news applications. A typical news app is heavily interactive, combines HTML and SVG, and is developed under extreme deadline pressure. It has to work reliably across browsers, and perform well even on mobile devices.\n\n        \nUnlike other frameworks, \nRactive works for you\n, not the other way around. It doesn't have an opinion about the other tools you want to use with it. It also adapts to the approach you want to take. You're not locked-in to a framework-specific way of thinking. Should you hate one of your tools for some reason, you can easily swap it out for another and move on with life.\n\n        \nThis project is the brainchild of an Englishman and has contributors from all over the world. There is an eclectic mix of primarily the Queen's English, a fair amount of 'Murican English, and a bit of others here and there. Things like \"adaptor\", \"behaviour\", and \"dependant\" may have more than one spelling but we try to stick to the Queen's English to the extent that we are able.\n\n        \nFun fact: The name is a reference to Neal Stephenson's \nThe Diamond Age: Or, A Young Lady's Illustrated Primer\n \u2013 a book about (among other things) the future of storytelling.\n\n      \n\n    \n\n    \n\n      \n\n        \nDownloads\n\n\n# jsDelivr\nhttps://cdn.jsdelivr.net/npm/ractive\n\n# CDNjs\nhttps://cdnjs.com/libraries/ractive\n\n# unpkg\nhttps://unpkg.com/ractive\n\n# npm\nnpm install --save-dev ractive\n\n# Bower\nbower install --save ractive", 
            "title": "Home"
        }, 
        {
            "location": "/tutorials/hello-world/", 
            "text": "Hello, world!\n\n\nWelcome to the Ractive.js tutorials. This is a set of interactive tutorials which you can take at your own pace. Each tutorial consists of a number of steps \u2013 first up is step 1 of the 'Hello world!' tutorial.\n\n\nAt any time you can start or reset a step by clicking its Start button.\n\n\nStep 1\n\n\n\n    \nStart\n\n\n\n\nTry creating a new Ractive by executing the JavaScript in the script tab of the playground by hitting the \n button on the top right-hand corner of the playground.\n\n\n\n\nIn later steps, if you can't get it to work (or if you're just lazy!) you can click the Fix Code button, if there is one available, next to the Start button to insert working code as though you'd followed the instructions exactly.\n\n\nThroughout the tutorials, boxes like this will contain technical notes and asides, for the particularly nerdy or curious.\n\n\n\n\nStep 2\n\n\n\n    \nStart\n\n    \nFix Code\n\n\n\n\nThat's not very exciting. Let's make our template more templatey \u2013 replace the hard-coded text in the template with some variables:\n\n\np\n{{greeting}} {{name}}!\n/p\n\n\n\n\n\nThen, add some data to it, by adding a data initialisation option to our code on the script tab so that it looks like this:\n\n\nvar ractive = Ractive({\n  target: output,\n  template: template,\n  data: { greeting: 'Hello', name: 'world' }\n});\n\n\n\n\nExecute the code (with the \n button). It should look exactly as it did before.\n\n\nStep 3\n\n\n\n  \nStart\n\n\n\n\nHere's where Ractive differs from other templating libraries. Normally, if you wanted to change the data, you would have to re-render the entire view, which would have the effect of discarding the DOM nodes you'd already created. That's wasteful.\n\n\nInstead, we can manipulate views we've already created. Try running this code - click the \n button in the top-right corner:\n\n\n\n\n\nractive.set('greeting', 'Bonjour');\n\n\n\n\nAnd now this:\n\n\n\n\n\nractive.set('name', 'tout le monde');\n\n\n\n\nOoh la la! Even better, we could set both properties in one go. Let's do it in Mandarin this time:\n\n\n\n\n\nractive.set({\n  greeting: '\u4f60\u597d',\n  name: '\u4e16\u754c'\n});\n\n\n\n\nWhat's happening here is that the contents of the \np\n element are split into four text nodes \u2013 one for \n{{greeting}}\n, one for the comma and space characters, one for \n{{name}}\n, and one for the \n!\n. Ractive stores references to the nodes that correspond to the variables, and updates them when the data changes, leaving everything else untouched.\n\n\nSurgically updating text nodes is much faster than replacing elements, particularly when you only need to change part of your ractive.\n\n\n\n\nNote that due to the way the tutorials interact with the playground, the eval blocks above are actually running after the entire example is reloaded in the output pane. That's why running the last eval before running the next to last eval doesn't leave the Mandarin greeting intact. Under normal circumstances, the entire example wouldn't need to be re-run, which \nwould\n leave the Mandarin greeting intact.", 
            "title": "Hello, world!"
        }, 
        {
            "location": "/tutorials/hello-world/#hello-world", 
            "text": "Welcome to the Ractive.js tutorials. This is a set of interactive tutorials which you can take at your own pace. Each tutorial consists of a number of steps \u2013 first up is step 1 of the 'Hello world!' tutorial.  At any time you can start or reset a step by clicking its Start button.", 
            "title": "Hello, world!"
        }, 
        {
            "location": "/tutorials/hello-world/#step-1", 
            "text": "Start   Try creating a new Ractive by executing the JavaScript in the script tab of the playground by hitting the   button on the top right-hand corner of the playground.   In later steps, if you can't get it to work (or if you're just lazy!) you can click the Fix Code button, if there is one available, next to the Start button to insert working code as though you'd followed the instructions exactly.  Throughout the tutorials, boxes like this will contain technical notes and asides, for the particularly nerdy or curious.", 
            "title": "Step 1"
        }, 
        {
            "location": "/tutorials/hello-world/#step-2", 
            "text": "Start \n     Fix Code   That's not very exciting. Let's make our template more templatey \u2013 replace the hard-coded text in the template with some variables:  p {{greeting}} {{name}}! /p   Then, add some data to it, by adding a data initialisation option to our code on the script tab so that it looks like this:  var ractive = Ractive({\n  target: output,\n  template: template,\n  data: { greeting: 'Hello', name: 'world' }\n});  Execute the code (with the   button). It should look exactly as it did before.", 
            "title": "Step 2"
        }, 
        {
            "location": "/tutorials/hello-world/#step-3", 
            "text": "Start   Here's where Ractive differs from other templating libraries. Normally, if you wanted to change the data, you would have to re-render the entire view, which would have the effect of discarding the DOM nodes you'd already created. That's wasteful.  Instead, we can manipulate views we've already created. Try running this code - click the   button in the top-right corner:   ractive.set('greeting', 'Bonjour');  And now this:   ractive.set('name', 'tout le monde');  Ooh la la! Even better, we could set both properties in one go. Let's do it in Mandarin this time:   ractive.set({\n  greeting: '\u4f60\u597d',\n  name: '\u4e16\u754c'\n});  What's happening here is that the contents of the  p  element are split into four text nodes \u2013 one for  {{greeting}} , one for the comma and space characters, one for  {{name}} , and one for the  ! . Ractive stores references to the nodes that correspond to the variables, and updates them when the data changes, leaving everything else untouched.  Surgically updating text nodes is much faster than replacing elements, particularly when you only need to change part of your ractive.   Note that due to the way the tutorials interact with the playground, the eval blocks above are actually running after the entire example is reloaded in the output pane. That's why running the last eval before running the next to last eval doesn't leave the Mandarin greeting intact. Under normal circumstances, the entire example wouldn't need to be re-run, which  would  leave the Mandarin greeting intact.", 
            "title": "Step 3"
        }, 
        {
            "location": "/tutorials/nested-properties/", 
            "text": "Nested Properties\n\n\nRactive uses the mustache syntax, which supports nested properties \u2013 in JavaScript-land, that means properties that are objects with their own properties (which might be objects with their own properties...).\n\n\nStep 1\n\n\n\n  \nStart\n\n  \nFix Code\n\n\n\n\nLet's say we were building an app that displayed information about different countries. An object representing a country could look like this:\n\n\n{\n  name: 'The UK',\n  climate: { temperature: 'cold', rainfall: 'excessive' },\n  population: 63230000,\n  capital: { name: 'London', lat: 51.5171, lon: -0.1062 }\n}\n\n\n\n\nAdd that data to our JavaScript \u2013 there's a placeholder \ncountry\n property.\n\n\nWe can refer to these nested properties in our template using dot notation. So to refer to the country's name, we use \n{{country.name}}\n.\n\n\nGo ahead and replace the placeholders in the template with mustaches. Don't forget the \nhref\n on the 'see map' link. If you get stuck, click the \nFix Code\n button.\n\n\nExecute the code. You should see an accurate description of the UK.\n\n\n\n\n\n// Once we've rendered our view, we can change the country info\nractive.set( 'country', {\n  name: 'Australia',\n  climate: { temperature: 'hot', rainfall: 'limited' },\n  population: 22620600,\n  capital: { name: 'Canberra', lat: -35.2828, lon: 149.1314 }\n});\n\n\n\n\nStep 2\n\n\n\n    \nStart\n\n    \nFix Code\n\n\n\n\nThat's all well and good, but it's a little on the verbose side. You can imagine if we had lots more properties on the capital city object that we wanted to refer to \u2013 we don't want to keep writing \n{{country.capital.xyz}}\n if we don't have to.\n\n\nWe don't have to. Instead, we can use a \nwith section\n to provide \ncontext\n:\n\n\n{{#with country}}\n  \np\n{{name}} is a {{climate.temperature}} country\n  with {{climate.rainfall}} rainfall and a population\n  of {{population}}.\n/p\n\n{{/with}}\n\n\n\n\n\n\nStrictly speaking, you don't need the with - you can just use a # sign by itself:\n\n\n{{#country}}\n  \np\n{{name}} is a {{climate.temperature}} country\n  with {{climate.rainfall}} rainfall and a population\n  of {{population}}.\n/p\n\n{{/country}}\n\n\n\nIn this case, when Ractive looks up country, it will decide whether to render a with, if or each section based on its value. We'll learn about if and each shortly.\n\n\nGenerally, it's better to be explicit about which type of section you intend \u2013 other programmers (including future you) will be grateful.\n\n\n\n\nGo ahead and update the template, creating a section for the capital as well. (You can either create a \n{{#with country.capital}}\n section, or a  \n{{#with capital}}\n section inside the \n{{#with country}}\n section. Use whichever structure is easier in a given situation.)\n\n\n\n\nNotice that if you create a \n{{#with capital}}\n section, you could end up having two \n{{name}}\n variables \u2013 one for the country, one for the capital.\n\n\nWe say that the capital \n{{name}}\n reference has a two-level context stack \u2013 if the innermost context (\ncountry.capital\n) has a name property, \n{{name}}\n resolves to the \ncountry.capital.name\n keypath.\n\n\nIf not, Ractive moves \nup the context stack\n (in this case, to \ncountry\n, and then to the root \ndata\n object) until it \ndoes\n find a context with a \nname\n property. If no matching property is found, then the reference will resolve to the current context. Once a reference is resolved, its keypath is fixed.\n\n\nIf you ever need to \nforce\n a reference to resolve in the current context, rather than potentially somewhere up the context stack, you can simply prefix the reference with a \n.\n. \n.stats.area\n will \nalways\n resolve to \ncountry.capital.stats.area\n in \n{{#with country.capital}}{{.stats.area}}{{/with}}\n, even if there is not already a \nstats\n property on \ncountry.capital\n and there is one on \ncountry\n. If/when \ncountry.capital.stats\n is set, any references will be ready to update.\n\n\n\n\nIf you get stuck, hit the \nFix Code\n button.\n\n\nStep 3\n\n\n\n    \nStart\n\n\n\n\nLet's say we want to update a nested property. If we'd stored a reference to our model object, we could do it like this:\n\n\n\n\n\n// we didn't store a reference, so let's do it now\nvar country = ractive.get('country');\n\ncountry.climate.rainfall = 'very high';\nractive.update('country');\n\n\n\n\nRactive will recognise that only the rainfall property has changed, and leave everything else untouched.\n\n\nBut there's an easier way to do it:\n\n\n\n\n\nractive.set('country.climate.rainfall', 'too much');\n\n\n\n\nTry changing properties. (If you're not from the UK, suitable values for rainfall include 'near-constant', 'unnecessarily high', or 'an unholy amount of'.)", 
            "title": "Nested Properties"
        }, 
        {
            "location": "/tutorials/nested-properties/#nested-properties", 
            "text": "Ractive uses the mustache syntax, which supports nested properties \u2013 in JavaScript-land, that means properties that are objects with their own properties (which might be objects with their own properties...).", 
            "title": "Nested Properties"
        }, 
        {
            "location": "/tutorials/nested-properties/#step-1", 
            "text": "Start \n   Fix Code   Let's say we were building an app that displayed information about different countries. An object representing a country could look like this:  {\n  name: 'The UK',\n  climate: { temperature: 'cold', rainfall: 'excessive' },\n  population: 63230000,\n  capital: { name: 'London', lat: 51.5171, lon: -0.1062 }\n}  Add that data to our JavaScript \u2013 there's a placeholder  country  property.  We can refer to these nested properties in our template using dot notation. So to refer to the country's name, we use  {{country.name}} .  Go ahead and replace the placeholders in the template with mustaches. Don't forget the  href  on the 'see map' link. If you get stuck, click the  Fix Code  button.  Execute the code. You should see an accurate description of the UK.   // Once we've rendered our view, we can change the country info\nractive.set( 'country', {\n  name: 'Australia',\n  climate: { temperature: 'hot', rainfall: 'limited' },\n  population: 22620600,\n  capital: { name: 'Canberra', lat: -35.2828, lon: 149.1314 }\n});", 
            "title": "Step 1"
        }, 
        {
            "location": "/tutorials/nested-properties/#step-2", 
            "text": "Start \n     Fix Code   That's all well and good, but it's a little on the verbose side. You can imagine if we had lots more properties on the capital city object that we wanted to refer to \u2013 we don't want to keep writing  {{country.capital.xyz}}  if we don't have to.  We don't have to. Instead, we can use a  with section  to provide  context :  {{#with country}}\n   p {{name}} is a {{climate.temperature}} country\n  with {{climate.rainfall}} rainfall and a population\n  of {{population}}. /p \n{{/with}}   Strictly speaking, you don't need the with - you can just use a # sign by itself:  {{#country}}\n   p {{name}} is a {{climate.temperature}} country\n  with {{climate.rainfall}} rainfall and a population\n  of {{population}}. /p \n{{/country}}  In this case, when Ractive looks up country, it will decide whether to render a with, if or each section based on its value. We'll learn about if and each shortly.  Generally, it's better to be explicit about which type of section you intend \u2013 other programmers (including future you) will be grateful.   Go ahead and update the template, creating a section for the capital as well. (You can either create a  {{#with country.capital}}  section, or a   {{#with capital}}  section inside the  {{#with country}}  section. Use whichever structure is easier in a given situation.)   Notice that if you create a  {{#with capital}}  section, you could end up having two  {{name}}  variables \u2013 one for the country, one for the capital.  We say that the capital  {{name}}  reference has a two-level context stack \u2013 if the innermost context ( country.capital ) has a name property,  {{name}}  resolves to the  country.capital.name  keypath.  If not, Ractive moves  up the context stack  (in this case, to  country , and then to the root  data  object) until it  does  find a context with a  name  property. If no matching property is found, then the reference will resolve to the current context. Once a reference is resolved, its keypath is fixed.  If you ever need to  force  a reference to resolve in the current context, rather than potentially somewhere up the context stack, you can simply prefix the reference with a  . .  .stats.area  will  always  resolve to  country.capital.stats.area  in  {{#with country.capital}}{{.stats.area}}{{/with}} , even if there is not already a  stats  property on  country.capital  and there is one on  country . If/when  country.capital.stats  is set, any references will be ready to update.   If you get stuck, hit the  Fix Code  button.", 
            "title": "Step 2"
        }, 
        {
            "location": "/tutorials/nested-properties/#step-3", 
            "text": "Start   Let's say we want to update a nested property. If we'd stored a reference to our model object, we could do it like this:   // we didn't store a reference, so let's do it now\nvar country = ractive.get('country');\n\ncountry.climate.rainfall = 'very high';\nractive.update('country');  Ractive will recognise that only the rainfall property has changed, and leave everything else untouched.  But there's an easier way to do it:   ractive.set('country.climate.rainfall', 'too much');  Try changing properties. (If you're not from the UK, suitable values for rainfall include 'near-constant', 'unnecessarily high', or 'an unholy amount of'.)", 
            "title": "Step 3"
        }, 
        {
            "location": "/tutorials/expressions/", 
            "text": "Expressions\n\n\nOne problem with the last example \u2013 the population number. Printing out a number like 63230000 just looks a bit daft.\n\n\nStep 1\n\n\n\n  \nStart\n\n  \nFix Code\n\n\n\n\nWe could replace the number with a string, like '63.2 million'. But numbers are generally a hell of a lot easier to work with.\n\n\nInstead, we can use an \nexpression\n. Expressions look just like regular mustaches:\n\n\n{{ format(population) }}\n\n\n\n\nAdd a \nformat\n property alongside the country data (it may seem weird adding a function as 'data', but it will make sense in due course!):\n\n\nfunction ( num ) {\n  if ( num \n 1000000000 ) return ( num / 1000000000 ).toFixed( 1 ) + ' billion';\n  if ( num \n 1000000 ) return ( num / 1000000 ).toFixed( 1 ) + ' million';\n  if ( num \n 1000 ) return ( Math.floor( num / 1000 ) ) + ',' + ( num % 1000 );\n  return num;\n}\n\n\n\n\nExecute the code. Doesn't that look better? Try changing the values.\n\n\n\n\n\nractive.set({\n  country: 'China',\n  population: 1351000000\n});\n\n\n\n\n\n\nNote that expressions are not part of the mustache syntax \u2013 they are specific to Ractive.js.\n\n\n\n\nStep 2\n\n\n\n  \nStart\n\n  \nFix Code\n\n\n\n\nYou can also use mathematical expressions. Let's rummage around in the bag of contrived examples and see what comes out... yep... this one will do... it's a shopping basket.\n\n\nWe have an \nitem\n property, a \nprice\n, and a \nquantity\n. Add an expression where the total should go:\n\n\ntd\n{{ price * quantity }}\n/td\n\n\n\n\n\nExecute the code. The total should appear. Now we just need to add a currency formatter \u2013 here's one for the UK (if you're not from here, write one for your own currency for extra credit):\n\n\nfunction ( num ) {\n  if ( num \n 1 ) return ( 100 * num ) + 'p';\n  return '\u00a3' + num.toFixed( 2 );\n}\n\n\n\n\nAdd that, and use in the template it for both the price and the total. Try changing the price and the quantity.\n\n\n\n\n\nractive.set({\n  item: 'banana',\n  price: 0.19,\n  quantity: 7\n});\n\n\n\n\n\n\nYou might reasonably ask how this works. What happens is this: when the template is parsed, any \nreferences\n inside expressions (such as \nprice\n, \nquantity\n or \nformat\n in the example above) are identified. At render time, the expression binds to those references and creates a function to calculate the result. (Whenever possible, Ractive.js will re-use functions \u2013 for example \n{{a+b}}\n and \n{{c+d}}\n would share the same function.)\n\n\nWhen the value of one or more of those references change, the expression is re-evaluated. If the result changes, the DOM is updated.\n\n\n\n\nStep 3\n\n\n\n  \nStart\n\n  \nFix Code\n\n\n\n\nIn this next contrived example, we're going to make a colour mixer.\n\n\nFirst, we want to show how much we're using of each colour. We'll use \ndiv\n elements with a percentage width corresponding to the amount. All the colour values are between 0 and 1, so we need to multiply by 100:\n\n\ndiv style='background-color: red;\n     width: {{red*100}}%;'\n/div\n\n\n\n\n\nUpdate the first three \ndiv\n elements in the template accordingly.\n\n\n\n\nPro-tip: in the playground editors, hold the \nCmd\n key (or \nCtrl\n if you're not on a Mac) and click in each of the places where you need to type 100. Multiple cursors FTW!\n\n\n\n\nTo show the result, we can use an \nrgb(r,g,b)\n CSS colour value. But instead of percentages, these need to be between 0 and 255:\n\n\ndiv style='background-color:\n  rgb({{red   * 255}},\n      {{green * 255}},\n      {{blue  * 255}})'\n\n\n/div\n\n\n\n\n\nUpdate the template and execute the code. Did it work?\n\n\nNo, it didn't. That's because CSS insists that you use integers \u2013 no decimals allowed. So let's use \nMath.round\n to turn the numbers into integers:\n\n\ndiv style='background-color:\n  rgb({{Math.round(red   * 255)}},\n      {{Math.round(green * 255)}},\n      {{Math.round(blue  * 255)}})'\n\n\n/div\n\n\n\n\n\nExecute the code. Ta-da! Try changing the colours.\n\n\n\n\n\nractive.set( 'red', 1 );\n// PSST! Want a sneak preview of something neat?\n// Try using ractive.animate() instead of ractive.set().\n// You can drop it in after the line 9 in the Script content.\n\n\n\n\n\n\nThe \nMath\n object is one of several built-in JavaScript objects you have direct access to within expressions, alongside \nDate\n, \nencodeURI\n, \nparseInt\n, \nJSON\n and various others. Consult the documentation for a full list. You can also access other globals using the \n@global\n special reference, where the \nJSON\n object would be accessible as \n@global.JSON\n.\n\n\nExpressions can be as simple or as complex as you like, as long as they only refer to properties of their view model (i.e. the properties on the data object), don't include assignment operators (including \n+=\n, \n-=\n, \n++\n and  \n--\n), \nnew\n, \ndelete\n or \nvoid\n, and don't use function literals.", 
            "title": "Expressions"
        }, 
        {
            "location": "/tutorials/expressions/#expressions", 
            "text": "One problem with the last example \u2013 the population number. Printing out a number like 63230000 just looks a bit daft.", 
            "title": "Expressions"
        }, 
        {
            "location": "/tutorials/expressions/#step-1", 
            "text": "Start \n   Fix Code   We could replace the number with a string, like '63.2 million'. But numbers are generally a hell of a lot easier to work with.  Instead, we can use an  expression . Expressions look just like regular mustaches:  {{ format(population) }}  Add a  format  property alongside the country data (it may seem weird adding a function as 'data', but it will make sense in due course!):  function ( num ) {\n  if ( num   1000000000 ) return ( num / 1000000000 ).toFixed( 1 ) + ' billion';\n  if ( num   1000000 ) return ( num / 1000000 ).toFixed( 1 ) + ' million';\n  if ( num   1000 ) return ( Math.floor( num / 1000 ) ) + ',' + ( num % 1000 );\n  return num;\n}  Execute the code. Doesn't that look better? Try changing the values.   ractive.set({\n  country: 'China',\n  population: 1351000000\n});   Note that expressions are not part of the mustache syntax \u2013 they are specific to Ractive.js.", 
            "title": "Step 1"
        }, 
        {
            "location": "/tutorials/expressions/#step-2", 
            "text": "Start \n   Fix Code   You can also use mathematical expressions. Let's rummage around in the bag of contrived examples and see what comes out... yep... this one will do... it's a shopping basket.  We have an  item  property, a  price , and a  quantity . Add an expression where the total should go:  td {{ price * quantity }} /td   Execute the code. The total should appear. Now we just need to add a currency formatter \u2013 here's one for the UK (if you're not from here, write one for your own currency for extra credit):  function ( num ) {\n  if ( num   1 ) return ( 100 * num ) + 'p';\n  return '\u00a3' + num.toFixed( 2 );\n}  Add that, and use in the template it for both the price and the total. Try changing the price and the quantity.   ractive.set({\n  item: 'banana',\n  price: 0.19,\n  quantity: 7\n});   You might reasonably ask how this works. What happens is this: when the template is parsed, any  references  inside expressions (such as  price ,  quantity  or  format  in the example above) are identified. At render time, the expression binds to those references and creates a function to calculate the result. (Whenever possible, Ractive.js will re-use functions \u2013 for example  {{a+b}}  and  {{c+d}}  would share the same function.)  When the value of one or more of those references change, the expression is re-evaluated. If the result changes, the DOM is updated.", 
            "title": "Step 2"
        }, 
        {
            "location": "/tutorials/expressions/#step-3", 
            "text": "Start \n   Fix Code   In this next contrived example, we're going to make a colour mixer.  First, we want to show how much we're using of each colour. We'll use  div  elements with a percentage width corresponding to the amount. All the colour values are between 0 and 1, so we need to multiply by 100:  div style='background-color: red;\n     width: {{red*100}}%;' /div   Update the first three  div  elements in the template accordingly.   Pro-tip: in the playground editors, hold the  Cmd  key (or  Ctrl  if you're not on a Mac) and click in each of the places where you need to type 100. Multiple cursors FTW!   To show the result, we can use an  rgb(r,g,b)  CSS colour value. But instead of percentages, these need to be between 0 and 255:  div style='background-color:\n  rgb({{red   * 255}},\n      {{green * 255}},\n      {{blue  * 255}})'  /div   Update the template and execute the code. Did it work?  No, it didn't. That's because CSS insists that you use integers \u2013 no decimals allowed. So let's use  Math.round  to turn the numbers into integers:  div style='background-color:\n  rgb({{Math.round(red   * 255)}},\n      {{Math.round(green * 255)}},\n      {{Math.round(blue  * 255)}})'  /div   Execute the code. Ta-da! Try changing the colours.   ractive.set( 'red', 1 );\n// PSST! Want a sneak preview of something neat?\n// Try using ractive.animate() instead of ractive.set().\n// You can drop it in after the line 9 in the Script content.   The  Math  object is one of several built-in JavaScript objects you have direct access to within expressions, alongside  Date ,  encodeURI ,  parseInt ,  JSON  and various others. Consult the documentation for a full list. You can also access other globals using the  @global  special reference, where the  JSON  object would be accessible as  @global.JSON .  Expressions can be as simple or as complex as you like, as long as they only refer to properties of their view model (i.e. the properties on the data object), don't include assignment operators (including  += ,  -= ,  ++  and   -- ),  new ,  delete  or  void , and don't use function literals.", 
            "title": "Step 3"
        }, 
        {
            "location": "/tutorials/events/", 
            "text": "Events\n\n\nDOM events are central to anything interactive on the web. You've probably written \nelement.addEventListener('click', handler)\n or \n$('#button').on('click', handler)\n, or similar code, a thousand times.\n\n\nStep 1\n\n\n\n  \nStart\n\n  \nFix Code\n\n\n\n\nWith Ractive.js, events are declarative instead, and you declare an event handler like this:\n\n\nbutton on-click=\n@global.alert( 'Activating!' )\nActivate!\n/button\n\n\n\n\n\n\n\n\"But wait!\", you say. \"That looks like some sort of global inline event listener horribleness!\". It's not though, I promise. Instead, the \non-\n directive will bind a shared callback directly to the element using \naddEventListener\n when it is rendered. When the shared callback is triggered, it will evaluate the expression (or list of expressions) that was passed to the event directive. If you inspect the button element in your browser's Dev Tools, you'll notice that there is no \non-click\n attribute. That's because directives don't render directly to the DOM, but instead control behavior related to rendering like attaching event listeners.\n\n\n\n\nThis is generally more convenient - you don't need to pepper the DOM with id and class attributes just you've got a hook to identify elements with. It also takes the guesswork out of when to attach and detach event listeners, since Ractive.js will automatically attach and detach handlers as elements are rendered and unrendered. Since the event directive actually accepts a list of expressions as its argument, so go ahead and log a console message after the alert is acknowledged:\n\n\nbutton on-click=\n@global.alert( 'Activating!' ), console.log( 'alert was acknowledged' )\nActivate!\n/button\n\n\n\n\n\n\n\nconsole\n is one of the globals that is exposed to Ractive.js templates, but if you want to get to \nalert\n, you have to go through the \n@global\n special reference.\n\n\nThe playground watches for console messages in the output pane and displays them on the \nConsole\n tab, so if you happen to be reading through this in a browser that doesn't have Dev Tools, you can still see most console messages.\n\n\n\n\nStep 2\n\n\n\n  \nStart\n\n  \nFix Code\n\n\n\n\nOkay, we can now annoy users and log debug info. What about something a bit more useful? Back into the bag of contrived examples, and out comes... a number incrementer!\n\n\n{{number}} \nbutton on-click=\n@this.add('number')\n+\n/button\n\n\n\n\n\n\n\n@this\n is a reference to the Ractive.js instance that is controlling the template, so you can call any methods on the Ractive.js API with the \n@this\n special reference. Since \n@this\n is a \nvery\n common reference, it also has an ever so slightly shorter shorthand \n@\n. \n@this.toggle('visible')\n and \n@.toggle('visible')\n are equivalent.\n\n\n\n\nGiven that there is a \nsubtract\n method in the Ractive.js API, can you add a decrement button to the example as well?\n\n\nStep 3\n\n\n\n  \nStart\n\n  \nFix Code\n\n\n\n\nTo further wangle our incrementer contrivance, suppose we devised a web version of the old traveling game wherein you collect all of the cows that you pass on your side of the car. So we'll need two objects, one for \nme\n and one for my \nsibling\n. Each person will have a property, \ncows\n, which is an integer representing accumulated bovine beasts.\n\n\n{\n  me: { cows: 0 },\n  sibling: { cows: 0 }\n}\n\n\n\n\nThe template for this game will include a \ntable\n containing counts for each person and buttons to increment each person's taurine total.\n\n\ntable\n\n  \ntr\n\n    \nth\nMe\n/th\nth\nSibling\n/th\n\n  \n/tr\n\n  \ntr\n\n    \ntd\n\n      {{#with me}}\n        {{.cows}}\n        \nbutton\n+\n/button\n\n      {{/with}}\n    \n/td\n\n    \ntd\n\n      {{#with sibling}}\n        {{.cows}}\n        \nbutton\n+\n/button\n\n      {{/with}}\n    \n/td\n\n  \n/tr\n\n\n/table\n\n\n\n\n\nThe event listeners \ncould\n use the full path to the appropriate \ncows\n property, which is not too large an imposition here, but with a deeper context, it would quickly become inconvenient. They could also do some keypath manipulation using the special reference \n@keypath\n, which resolves to the keypath to the current context at any point in the template. That's a bit painful in most contexts and impossible in others. To address this particular issue, Ractive.js provides a special \n@context\n reference that acts as an API adaptor that is rooted in the current context of the template. \n@context\n objects have most of the same API methods as a Ractive.js instance, but they can resolve relative keypaths. Add this event directive to each of the buttons to see it in action:\n\n\nbutton on-click=\n@context.add( '.cows' )\n+\n/button\n\n\n\n\n\nTo complete the rules of the game, when you pass a cemetery on your side of the car, you lose all of your cows. It's a weird game, I know, but I didn't make it up. What would be the easiest way to reset a person's cow count?\n\n\nStep 4\n\n\n\n  \nStart\n\n\n\n\nSuppose you need to track the mouse cursor as it moves across a \ndiv\n for... reasons. Perhaps you've landed the contract for the frontend of a missile targeting system. Ractive.js provides access to the DOM event object in event directive expressions as the special \n@event\n reference. Any properties and methods available on the event object passed to the \naddEventListener\n callback are available from the \n@event\n reference e.g. \n@event.clientX\n.\n\n\ndiv id=\ntracker\n on-mousemove=\n@.set({ x: @event.clientX, y: @event.clientY })\n on-click=\nconsole.log(`firing at (${@event.clientX}, ${@event.clientY})!`)\n\n  ({{x}}, {{y}})\n\n/div\n\n\n\n\n\nThe element on which the event directive is installed is also available within event directive expressions as the special \n@node\n reference. Like the \n@event\n reference, you can access any properties or methods of the DOM element or even pass it as an argument to another function using \n@node\n.\n\n\ninput value=\nexample\n on-focus=\n@node.select()\n /\n\n\n\n\n\n\n\nIf you need to cancel an event by calling \nstopPropagation\n, you can simply make \nfalse\n the last expression in your event directive expression list.\n\n\na href=\"/nope\" on-click=\"doSomething(), false\"\nThis will do something rather than /nope.\n/a\n\n\n\n\n\n\nStep 5\n\n\n\n  \nStart\n\n  \nFix Code\n\n\n\n\nRactive.js also provides its own instance-level event system, so that you can raise and respond to internal events in a more abstract way. You can name your events however you like, so you can convey more meaning about the intent of the action that triggered the event, such as \naddUser\n as opposed to \nclick\n.\n\n\nTo listen to an event, you attach an event listener to your Ractive.js instance with the \non\n method.\n\n\nractive.on( 'activate', function ( context ) {\n  // `this` is the ractive instance\n  // `context` is a context object\n  // any additional event arguments would follow `context`, if supplied\n  alert( 'Activating!' );\n});\n\n\n\n\nTo raise an event, you pass the event name and optional context and arguments to the \nfire\n method.\n\n\n// this will trigger the \nractive.fire( 'activate' );\n\n\n\n\nUpdate the template and JavaScript to fire and handle an instance event, then execute. Remember, you can access the current Ractive.js instance with the \n@this\n special reference or \n@\n shorthand.\n\n\n\n\nA Ractive.js instance doesn't need to be rendered to update data or fire and handle events.\n\n\n\n\nStep 6\n\n\n\n  \nStart\n\n  \nFix Code\n\n\n\n\nYou can subscribe to multiple instance events in one go:\n\n\nractive.on({\n  activate: function () {\n    alert( 'Activating!' );\n  },\n  deactivate: function () {\n    alert( 'Deactivating!' );\n  }\n});\n\n\n\n\nAdd a 'deactivate' button and wire it up.\n\n\nStep 7\n\n\n\n  \nStart\n\n\n\n\nConverting a DOM event into an instance event is a terribly convenient way to handle user actions in a meaningful way. The signature of the \nfire\n method is a little cumbersome to include all over your template, especially if you need to pass the \n@context\n and a few additional arguments. To address that, Ractive.js provides a convenient shorthand method for firing and instance event from an event directive. If there is only one expression in the event directive arguments, that expression returns an array, and that array has a string as the first member, the event directive will fire an internal event with the first array element as the name, the current \n@context\n as the context, and any remaining members of the array as event arguments. This is generally referred to as a \"proxy event\".\n\n\nbutton on-click=\n['activate', user]\nActivate!\n/button\n\n\n!-- which is a bit more convenient than --\n\n\nbutton on-click=\n@this.fire('activate', @context, user)\nActivate!\n/button\n\n\n\n\n\n\n\nDepending on your editor and personal tastes, it might be convenient to use an unquoted attribute for your proxied events: \nbutton on-click=['activate', user]\nActivate!\n/button\n. There is nothing special going on there - Ractive.js supports just about everything that HTML does, and HTML supports unquoted attributes e.g. \ninput value=green /\n.\n\n\n\n\nAs with regular event expressions, if a handler for a proxied event returns \nfalse\n, it will cancel the event.\n\n\nStep 8\n\n\n\n  \nStart\n\n  \nFix Code\n\n\n\n\nThere are a couple of ways to unsubscribe from events. If you've used jQuery, you'll be used to this syntax:\n\n\nractive.on( 'select', selectHandler );\n\n// later...\nractive.off( 'select', selectHandler );\n\n\n\n\nThat's fine, as long as you stored a reference to selectHandler (i.e. you didn't just use an anonymous function). If you didn't, you can also do this:\n\n\n// remove ALL 'select' handlers\nractive.off( 'select' );\n\n// remove all handlers of ANY type\nractive.off();\n\n\n\n\nAlternatively, you can do this:\n\n\nvar listener = ractive.on( 'select', selectHandler );\n\nvar otherListeners = ractive.on({\n  activate: function () { alert( 'Activating' ); },\n  deactivate: function () { alert( 'Deactivating!' ); }\n});\n\n// later...\nlistener.cancel();\notherListeners.cancel();\n\n\n\n\nTry adding a 'stop' button which removes the 'activate' and 'deactivate' handlers.\n\n\nYou can also temporarily disable an event handler or set of event handlers by calling \nsilence\n on the handle returned by \non\n. You can resume processing of the handler or handlers by calling the conveniently named \nresume\n method on the handle.\n\n\nvar listener = ractive.on({\n  'select', function () { alert( 'Selected!' ); },\n  'delete', function () { alert( 'Deleted!' ); }\n});\n\n// later...\nlistener.silence();\n\n// no alerts here\nractive.fire( 'select' );\nractive.fire( 'delete' );\n\n// later...\nlistener.resume();\n\n// alert here\nractive.fire( 'select' );\n\n\n\n\nTry adding a silence button that checks to see if the listener is silenced using the handle's \nisSilenced\n method, and silences or resumes it as appropriate.\n\n\n\n\nIf you remove your ractive from the DOM with \nractive.teardown()\n, any event handlers will be automatically cleaned up.\n\n\n\n\nStep 9\n\n\n\n  \nStart\n\n  \nFix Code\n\n\n\n\nIt's possible to define custom template events in Ractive.js. You use them just like normal events:\n\n\nbutton on-tap='activate'\nActivate!\n/button\n\n\n\n\n\nNote that we're using on-tap here instead of \non-click\n \u2013 \ntap\n is a custom event.\n\n\n\n\nCustom events are distributed as plugins, which can be downloaded from here to include in your project.\n\n\nYou can also create your own plugins \u2013 just follow the instructions on the docs.\n\n\n\n\nThe trouble with \nclick\n is that it's nonsense. If you put your mouse down on the 'activate' button, waggle it about, then lift your finger up after a few seconds, the browser will in most cases consider it a 'click'. I don't. Do you?\n\n\nFurthermore, if your interface needs to work on touch devices, using \nclick\n means a 300ms delay between the \ntouchstart\n-\ntouchend\n sequence event and the simulated \nmousedown\n-\nmouseup\n-\nclick\n sequence.\n\n\nThe tap event corrects for both of these anomalies. Try replacing the click proxies in the template.", 
            "title": "Events"
        }, 
        {
            "location": "/tutorials/events/#events", 
            "text": "DOM events are central to anything interactive on the web. You've probably written  element.addEventListener('click', handler)  or  $('#button').on('click', handler) , or similar code, a thousand times.", 
            "title": "Events"
        }, 
        {
            "location": "/tutorials/events/#step-1", 
            "text": "Start \n   Fix Code   With Ractive.js, events are declarative instead, and you declare an event handler like this:  button on-click= @global.alert( 'Activating!' ) Activate! /button    \"But wait!\", you say. \"That looks like some sort of global inline event listener horribleness!\". It's not though, I promise. Instead, the  on-  directive will bind a shared callback directly to the element using  addEventListener  when it is rendered. When the shared callback is triggered, it will evaluate the expression (or list of expressions) that was passed to the event directive. If you inspect the button element in your browser's Dev Tools, you'll notice that there is no  on-click  attribute. That's because directives don't render directly to the DOM, but instead control behavior related to rendering like attaching event listeners.   This is generally more convenient - you don't need to pepper the DOM with id and class attributes just you've got a hook to identify elements with. It also takes the guesswork out of when to attach and detach event listeners, since Ractive.js will automatically attach and detach handlers as elements are rendered and unrendered. Since the event directive actually accepts a list of expressions as its argument, so go ahead and log a console message after the alert is acknowledged:  button on-click= @global.alert( 'Activating!' ), console.log( 'alert was acknowledged' ) Activate! /button    console  is one of the globals that is exposed to Ractive.js templates, but if you want to get to  alert , you have to go through the  @global  special reference.  The playground watches for console messages in the output pane and displays them on the  Console  tab, so if you happen to be reading through this in a browser that doesn't have Dev Tools, you can still see most console messages.", 
            "title": "Step 1"
        }, 
        {
            "location": "/tutorials/events/#step-2", 
            "text": "Start \n   Fix Code   Okay, we can now annoy users and log debug info. What about something a bit more useful? Back into the bag of contrived examples, and out comes... a number incrementer!  {{number}}  button on-click= @this.add('number') + /button    @this  is a reference to the Ractive.js instance that is controlling the template, so you can call any methods on the Ractive.js API with the  @this  special reference. Since  @this  is a  very  common reference, it also has an ever so slightly shorter shorthand  @ .  @this.toggle('visible')  and  @.toggle('visible')  are equivalent.   Given that there is a  subtract  method in the Ractive.js API, can you add a decrement button to the example as well?", 
            "title": "Step 2"
        }, 
        {
            "location": "/tutorials/events/#step-3", 
            "text": "Start \n   Fix Code   To further wangle our incrementer contrivance, suppose we devised a web version of the old traveling game wherein you collect all of the cows that you pass on your side of the car. So we'll need two objects, one for  me  and one for my  sibling . Each person will have a property,  cows , which is an integer representing accumulated bovine beasts.  {\n  me: { cows: 0 },\n  sibling: { cows: 0 }\n}  The template for this game will include a  table  containing counts for each person and buttons to increment each person's taurine total.  table \n   tr \n     th Me /th th Sibling /th \n   /tr \n   tr \n     td \n      {{#with me}}\n        {{.cows}}\n         button + /button \n      {{/with}}\n     /td \n     td \n      {{#with sibling}}\n        {{.cows}}\n         button + /button \n      {{/with}}\n     /td \n   /tr  /table   The event listeners  could  use the full path to the appropriate  cows  property, which is not too large an imposition here, but with a deeper context, it would quickly become inconvenient. They could also do some keypath manipulation using the special reference  @keypath , which resolves to the keypath to the current context at any point in the template. That's a bit painful in most contexts and impossible in others. To address this particular issue, Ractive.js provides a special  @context  reference that acts as an API adaptor that is rooted in the current context of the template.  @context  objects have most of the same API methods as a Ractive.js instance, but they can resolve relative keypaths. Add this event directive to each of the buttons to see it in action:  button on-click= @context.add( '.cows' ) + /button   To complete the rules of the game, when you pass a cemetery on your side of the car, you lose all of your cows. It's a weird game, I know, but I didn't make it up. What would be the easiest way to reset a person's cow count?", 
            "title": "Step 3"
        }, 
        {
            "location": "/tutorials/events/#step-4", 
            "text": "Start   Suppose you need to track the mouse cursor as it moves across a  div  for... reasons. Perhaps you've landed the contract for the frontend of a missile targeting system. Ractive.js provides access to the DOM event object in event directive expressions as the special  @event  reference. Any properties and methods available on the event object passed to the  addEventListener  callback are available from the  @event  reference e.g.  @event.clientX .  div id= tracker  on-mousemove= @.set({ x: @event.clientX, y: @event.clientY })  on-click= console.log(`firing at (${@event.clientX}, ${@event.clientY})!`) \n  ({{x}}, {{y}}) /div   The element on which the event directive is installed is also available within event directive expressions as the special  @node  reference. Like the  @event  reference, you can access any properties or methods of the DOM element or even pass it as an argument to another function using  @node .  input value= example  on-focus= @node.select()  /    If you need to cancel an event by calling  stopPropagation , you can simply make  false  the last expression in your event directive expression list.  a href=\"/nope\" on-click=\"doSomething(), false\" This will do something rather than /nope. /a", 
            "title": "Step 4"
        }, 
        {
            "location": "/tutorials/events/#step-5", 
            "text": "Start \n   Fix Code   Ractive.js also provides its own instance-level event system, so that you can raise and respond to internal events in a more abstract way. You can name your events however you like, so you can convey more meaning about the intent of the action that triggered the event, such as  addUser  as opposed to  click .  To listen to an event, you attach an event listener to your Ractive.js instance with the  on  method.  ractive.on( 'activate', function ( context ) {\n  // `this` is the ractive instance\n  // `context` is a context object\n  // any additional event arguments would follow `context`, if supplied\n  alert( 'Activating!' );\n});  To raise an event, you pass the event name and optional context and arguments to the  fire  method.  // this will trigger the \nractive.fire( 'activate' );  Update the template and JavaScript to fire and handle an instance event, then execute. Remember, you can access the current Ractive.js instance with the  @this  special reference or  @  shorthand.   A Ractive.js instance doesn't need to be rendered to update data or fire and handle events.", 
            "title": "Step 5"
        }, 
        {
            "location": "/tutorials/events/#step-6", 
            "text": "Start \n   Fix Code   You can subscribe to multiple instance events in one go:  ractive.on({\n  activate: function () {\n    alert( 'Activating!' );\n  },\n  deactivate: function () {\n    alert( 'Deactivating!' );\n  }\n});  Add a 'deactivate' button and wire it up.", 
            "title": "Step 6"
        }, 
        {
            "location": "/tutorials/events/#step-7", 
            "text": "Start   Converting a DOM event into an instance event is a terribly convenient way to handle user actions in a meaningful way. The signature of the  fire  method is a little cumbersome to include all over your template, especially if you need to pass the  @context  and a few additional arguments. To address that, Ractive.js provides a convenient shorthand method for firing and instance event from an event directive. If there is only one expression in the event directive arguments, that expression returns an array, and that array has a string as the first member, the event directive will fire an internal event with the first array element as the name, the current  @context  as the context, and any remaining members of the array as event arguments. This is generally referred to as a \"proxy event\".  button on-click= ['activate', user] Activate! /button  !-- which is a bit more convenient than --  button on-click= @this.fire('activate', @context, user) Activate! /button    Depending on your editor and personal tastes, it might be convenient to use an unquoted attribute for your proxied events:  button on-click=['activate', user] Activate! /button . There is nothing special going on there - Ractive.js supports just about everything that HTML does, and HTML supports unquoted attributes e.g.  input value=green / .   As with regular event expressions, if a handler for a proxied event returns  false , it will cancel the event.", 
            "title": "Step 7"
        }, 
        {
            "location": "/tutorials/events/#step-8", 
            "text": "Start \n   Fix Code   There are a couple of ways to unsubscribe from events. If you've used jQuery, you'll be used to this syntax:  ractive.on( 'select', selectHandler );\n\n// later...\nractive.off( 'select', selectHandler );  That's fine, as long as you stored a reference to selectHandler (i.e. you didn't just use an anonymous function). If you didn't, you can also do this:  // remove ALL 'select' handlers\nractive.off( 'select' );\n\n// remove all handlers of ANY type\nractive.off();  Alternatively, you can do this:  var listener = ractive.on( 'select', selectHandler );\n\nvar otherListeners = ractive.on({\n  activate: function () { alert( 'Activating' ); },\n  deactivate: function () { alert( 'Deactivating!' ); }\n});\n\n// later...\nlistener.cancel();\notherListeners.cancel();  Try adding a 'stop' button which removes the 'activate' and 'deactivate' handlers.  You can also temporarily disable an event handler or set of event handlers by calling  silence  on the handle returned by  on . You can resume processing of the handler or handlers by calling the conveniently named  resume  method on the handle.  var listener = ractive.on({\n  'select', function () { alert( 'Selected!' ); },\n  'delete', function () { alert( 'Deleted!' ); }\n});\n\n// later...\nlistener.silence();\n\n// no alerts here\nractive.fire( 'select' );\nractive.fire( 'delete' );\n\n// later...\nlistener.resume();\n\n// alert here\nractive.fire( 'select' );  Try adding a silence button that checks to see if the listener is silenced using the handle's  isSilenced  method, and silences or resumes it as appropriate.   If you remove your ractive from the DOM with  ractive.teardown() , any event handlers will be automatically cleaned up.", 
            "title": "Step 8"
        }, 
        {
            "location": "/tutorials/events/#step-9", 
            "text": "Start \n   Fix Code   It's possible to define custom template events in Ractive.js. You use them just like normal events:  button on-tap='activate' Activate! /button   Note that we're using on-tap here instead of  on-click  \u2013  tap  is a custom event.   Custom events are distributed as plugins, which can be downloaded from here to include in your project.  You can also create your own plugins \u2013 just follow the instructions on the docs.   The trouble with  click  is that it's nonsense. If you put your mouse down on the 'activate' button, waggle it about, then lift your finger up after a few seconds, the browser will in most cases consider it a 'click'. I don't. Do you?  Furthermore, if your interface needs to work on touch devices, using  click  means a 300ms delay between the  touchstart - touchend  sequence event and the simulated  mousedown - mouseup - click  sequence.  The tap event corrects for both of these anomalies. Try replacing the click proxies in the template.", 
            "title": "Step 9"
        }, 
        {
            "location": "/tutorials/conditional-sections/", 
            "text": "Conditional Sections\n\n\nOften, you want to show or hide part of your view depending on whether a particular condition is met. For example you might want to show a slightly different view to users depending on whether they're signed in or not.\n\n\nStep 1\n\n\n\n  \nStart\n\n  \nFix Code\n\n\n\n\nIn this example we've already set up a mock sign-in mechanism \u2013 click the 'sign in' button and enter your name in the prompt.\n\n\nAll we need to do is hide the 'please sign in' message when we're signed in, and the 'welcome back!' message when we're not.\n\n\nWrap the first block in an \n#if\n section that uses the \nsignedIn\n property:\n\n\n{{#if signedIn}}\n  \n!-- message for signed-in users --\n\n  \np\nWelcome back, {{username}}!\n/p\n\n{{/if}}\n\n\n\n\nNow do the same for the other block, except with the \nnotSignedIn\n property. Execute the code.\n\n\n\n\nThe plain mustache block \n{{#...}}\n is equivalent to \n{{#if ...}}{{#with ...}}\n. It is both conditional and contextual.\n\n\n\n\nStep 2\n\n\n\n  \nStart\n\n  \nFix Code\n\n\n\n\nHaving two properties (\nsignedIn\n and \nnotSignedIn\n) to represent one piece of data (whether or not the user is signed in) is the sort of thing that makes most programmers itch uncontrollably.\n\n\nWe have a couple of options. We could use an \n#unless\n section:\n\n\n{{#unless signedIn}}\n  \n!-- not-signed-in block --\n\n{{/unless}}\n\n\n\n\n\n\nThere's also a plain mustache for negated sections, \n{{^signedIn}}...{{/}}\n.\n\n\n\n\nAlternatively, we could use else:\n\n\n{{#if signedIn}}\n  \n!-- signed-in block --\n\n{{else}}\n  \n!-- not-signed-in block --\n\n{{/if}}\n\n\n\n\nUpdate the template. Then, remove the references to notSignedIn in the JavaScript. Then breathe a sigh of relief \u2013 doesn't that feel better?\n\n\n\n\nIf you have another branch in your conditional, you can include it with an \n{{elseif ...}}\n mustache. An \n{{#if}}\n section can include as many \nelseif\ns as you need, but it can only contain one \nelse\n.", 
            "title": "Conditional Sections"
        }, 
        {
            "location": "/tutorials/conditional-sections/#conditional-sections", 
            "text": "Often, you want to show or hide part of your view depending on whether a particular condition is met. For example you might want to show a slightly different view to users depending on whether they're signed in or not.", 
            "title": "Conditional Sections"
        }, 
        {
            "location": "/tutorials/conditional-sections/#step-1", 
            "text": "Start \n   Fix Code   In this example we've already set up a mock sign-in mechanism \u2013 click the 'sign in' button and enter your name in the prompt.  All we need to do is hide the 'please sign in' message when we're signed in, and the 'welcome back!' message when we're not.  Wrap the first block in an  #if  section that uses the  signedIn  property:  {{#if signedIn}}\n   !-- message for signed-in users -- \n   p Welcome back, {{username}}! /p \n{{/if}}  Now do the same for the other block, except with the  notSignedIn  property. Execute the code.   The plain mustache block  {{#...}}  is equivalent to  {{#if ...}}{{#with ...}} . It is both conditional and contextual.", 
            "title": "Step 1"
        }, 
        {
            "location": "/tutorials/conditional-sections/#step-2", 
            "text": "Start \n   Fix Code   Having two properties ( signedIn  and  notSignedIn ) to represent one piece of data (whether or not the user is signed in) is the sort of thing that makes most programmers itch uncontrollably.  We have a couple of options. We could use an  #unless  section:  {{#unless signedIn}}\n   !-- not-signed-in block -- \n{{/unless}}   There's also a plain mustache for negated sections,  {{^signedIn}}...{{/}} .   Alternatively, we could use else:  {{#if signedIn}}\n   !-- signed-in block -- \n{{else}}\n   !-- not-signed-in block -- \n{{/if}}  Update the template. Then, remove the references to notSignedIn in the JavaScript. Then breathe a sigh of relief \u2013 doesn't that feel better?   If you have another branch in your conditional, you can include it with an  {{elseif ...}}  mustache. An  {{#if}}  section can include as many  elseif s as you need, but it can only contain one  else .", 
            "title": "Step 2"
        }, 
        {
            "location": "/tutorials/iterative-sections/", 
            "text": "Iterative Sections\n\n\nLists of data, of some form or another, are often at the heart of webapps. In this tutorial we're going to build a sortable table of superheroes, using data taken from \nsuperherodb.com\n.\n\n\nStep 1\n\n\n\n  \nStart\n\n  \nFix Code\n\n\n\n\nWe've already got an array of objects representing four of the X-Men, over there on the right. We just need to update the template.\n\n\nBegin by wrapping the second \ntr\n in an \n#each\n section:\n\n\n{{#each superheroes}}\n  \ntr\n\n    \n!-- row content --\n\n  \n/tr\n\n{{/each}}\n\n\n\n\n\n\nAs with \n#with\n and \n#if\n sections, you could just do \n{{#superheroes}}...{{/superheroes}}\n and it would work the same way, as long as superheroes is an array.\n\n\n\n\nThen, insert mustaches representing each of the three properties in the table \u2013 \nname\n, \nrealname\n and \npower\n. For extra credit, wrap the name in a link pointing to the info URL.\n\n\nExecute the code.\n\n\n// You can use array notation to update the data:\nractive.set( 'superheroes[1].power', 'Martial arts' );\n\n// Or, you can use dot notation. Whichever you prefer:\nractive.set( 'superheroes.3.power', 'Enhanced senses' );\n\n\n\n\n\n\nWhat if there weren't any items in the array? Displaying a table with no rows has been recognized by the International Web Decorum Foundation as impolite, so Ractive.js will allow you to provide alternate content using an \n{{else}}\n section in the \n#each\n block, which will be rendered if the array is empty.\n\n\n{{#each superheroes}}\n  \ntr\n...\n/tr\n\n{{else}}\n  \ntr\ntd colspan=\"4\"\nOh no! There are no superheroes!\n/td\n/tr\n\n{{/each}}\n\n\n\nThis also works with plain mustache sections.\n\n\n\n\nStep 2\n\n\n\n  \nStart\n\n  \nFix Code\n\n\n\n\nOften when working with lists, we want to know the index of the list item we're currently rendering.\n\n\nMustache doesn't have a good way of doing this, so Ractive.js introduces the \nindex reference\n:\n\n\n{{#each list: num}}\n  \n!-- inside here, {{num}} is the index --\n\n{{/each}}\n\n\n\n\n\n\nIf you don't want to name your index, you can also use the generic index special reference \n@index\n. \n@index\n will resolve to the index of the nearest iteration, so if you happen to have nested iterations, it will be the nearest parent iteration, not the root.\n\n\nIf your section happens to be iterating an object rather than an array, you can use the \n@key\n special reference to get the object key of the current iteration.\n\n\n\n\nBy declaring \nnum\n to be an index reference, we can use it the same way we'd use any other variable. Let's add a number column to our table \u2013 first add the column to the header row:\n\n\ntr\n\n  \nth\n#\n/th\n\n  \nth\nSuperhero name\n/th\n\n  \n!-- etc --\n\n\n/tr\n\n\n\n\n\nThen to the list row:\n\n\n{{#each superheroes: num}}\n  \ntr\n\n    \ntd\n{{num}}\n/td\n\n    \ntd\na href='{{info}}'\n{{name}}\n/a\n/td\n\n    \ntd\n{{realname}}\n/td\n\n    \ntd\n{{power}}\n/td\n\n  \n/tr\n\n{{/each}}\n\n\n\n\nExecute the code.\n\n\nNot bad, but it would look better if the numbers started at 1 rather than 0. Use an expression to increment each row number by 1.\n\n\nStep 3\n\n\n\n  \nStart\n\n\n\n\nLet's say you wanted to add an item to your list. You could use \nractive.set()\n the way you're used to, but you'd have to find the length of the existing array first:\n\n\nvar index = ractive.get( 'superheroes' ).length;\nractive.set( 'superheroes[' + index + ']', newSuperhero );\n\n\n\n\nThat's not ideal. We could use \nractive.update('superheroes')\n instead, which will make sure that the table is up to date:\n\n\nxmen[ xmen.length ] = newSuperhero;\nractive.update( 'superheroes' );\n\n\n\n\n\n\nIf you don't pass a keypath argument to \nractive.update()\n, Ractive.js will update everything that has changed since the last set or update.\n\n\n\n\nBut there's a more convenient way. Ractive.js provides mutator methods for arrays (push, pop, shift, unshift, splice, sort and reverse) that work with a keypath:\n\n\nractive.push( 'superheroes', newSuperhero );\n\n\n\n\nTry adding Storm to the list by pushing to the array in the Script pane:\n\n\nvar newSuperhero = {\n  name: 'Storm',\n  realname: 'Monroe, Ororo',\n  power: 'Controlling the weather',\n  info: 'http://www.superherodb.com/Storm/10-135/'\n};\n\n// add the code here...\n\n\n\n\nStep 4\n\n\n\n  \nStart\n\n  \nFix Code\n\n\n\n\nIt's time to make our table sortable. We've added a 'sortable' class to the three headers to indicate they can be clicked on.\n\n\nFirst, let's add an event listener to each column header, calling the instance \nsort\n method with the column header as an argument:\n\n\nth class='sortable' on-click='@.sort(\nname\n)'\nSuperhero name\n/th\n\n\nth class='sortable' on-click='@.sort(\nrealname\n)'\nReal name\n/th\n\n\nth class='sortable' on-click='@.sort(\npower\n)'\nSuperpower\n/th\n\n\n\n\n\nThat way, when the user clicks one of the column headers, the view will fire call the \nsort\n method.\n\n\nractive.sort = function ( column ) {\n  alert( 'Sorting by ' + column );\n});\n\n\n\n\n\n\nYou can add methods and properties directly to a Ractive.js instance by simply including them in the init options. Any keys that don't match know init options are added to the instance upon creation.\n\n\n\n\nExecute the code. When you click on the three sortable headers, the browser should alert the name of the column we're sorting by. Now we just need to add the sorting logic.\n\n\nStep 5\n\n\n\n  \nStart\n\n  \nFix Code\n\n\n\n\nSo we've wired up our event handler, and it's behaving as it should. The next step is to add some logic that actually sorts the table. For bonus points, we'll add a 'sorted' class to the header of the sorted column.\n\n\nThere's a nice easy way to ensure that the table remains sorted, even when we add more data: an expression. That's right, you can use expressions with sections.\n\n\nUpdate the template:\n\n\n{{#each sort( superheroes ) : num}}\n  \ntr\n\n   \n!-- row contents --\n\n  \n/tr\n\n{{/each}}\n\n\n\n\nNow we need to add the \nsort\n function. Here's one (if you're not sure why this works, \nhere's an MDN page\n that will help explain):\n\n\nfunction ( array ) {\n  // grab the current sort column\n  var column = this.get( 'sortColumn' ); \n\n  // clone the array so as not to modify the underlying data\n  var arr = array.slice();\n\n  return arr.sort( function ( a, b ) {\n    return a[ sortColumn ] \n b[ sortColumn ] ? -1 : 1;\n  });\n}\n\n\n\n\nWiring it up is easy:\n\n\nractive.sort = function ( column ) {\n  this.set( 'sortColumn', column );\n});\n\n\n\n\nTry executing this code and clicking different headers to sort the table. (You could specify an initial sort column by adding e.g. \nsortColumn: 'name'\n to \ndata\n.)\n\n\nThe last job is to add a sorted class to the header of the currently sorted column. There are several ways we could do this \u2013 you could use a bit of jQuery inside the sort proxy event handler, for example. But for this demonstration we'll put the logic in the template, using the conditional operator:\n\n\nth class='sortable' class-sorted=\nsortColumn === 'name'\n on-click='@.sort(\nname\n)'\n\n  Superhero name\n\n/th\n\n\n\n\n\n\n\nThe \nclass-\n directive is similar to the \nstyle-\n directive - it gives you direct control over the presence of a single class. The \nclass-\n directive exists in an expression context, so mustaches are not required. If the expression passed to the directive is truthy, Ractive.js will add the class to the element, and if it's false-y, it will remove it.\n\n\nYou could also add an additional expression within the existing \nclass\n attribute using a ternary e.g. \nclass=\"sortable {{ sortColumn === 'name' ? 'sorted' : '' }}\n.\n\n\n\n\nDo this for each of the headers, then execute the code. Congratulations! You've built a sortable table in just a few steps. Now comes the fun part \u2013 add Storm back to the table. The table will maintain its sort order.\n\n\nractive.push( 'superheroes', {\n  name: 'Storm',\n  realname: 'Monroe, Ororo',\n  power: 'Controlling the weather',\n  info: 'http://www.superherodb.com/Storm/10-135/'\n});", 
            "title": "Iterative Sections"
        }, 
        {
            "location": "/tutorials/iterative-sections/#iterative-sections", 
            "text": "Lists of data, of some form or another, are often at the heart of webapps. In this tutorial we're going to build a sortable table of superheroes, using data taken from  superherodb.com .", 
            "title": "Iterative Sections"
        }, 
        {
            "location": "/tutorials/iterative-sections/#step-1", 
            "text": "Start \n   Fix Code   We've already got an array of objects representing four of the X-Men, over there on the right. We just need to update the template.  Begin by wrapping the second  tr  in an  #each  section:  {{#each superheroes}}\n   tr \n     !-- row content -- \n   /tr \n{{/each}}   As with  #with  and  #if  sections, you could just do  {{#superheroes}}...{{/superheroes}}  and it would work the same way, as long as superheroes is an array.   Then, insert mustaches representing each of the three properties in the table \u2013  name ,  realname  and  power . For extra credit, wrap the name in a link pointing to the info URL.  Execute the code.  // You can use array notation to update the data:\nractive.set( 'superheroes[1].power', 'Martial arts' );\n\n// Or, you can use dot notation. Whichever you prefer:\nractive.set( 'superheroes.3.power', 'Enhanced senses' );   What if there weren't any items in the array? Displaying a table with no rows has been recognized by the International Web Decorum Foundation as impolite, so Ractive.js will allow you to provide alternate content using an  {{else}}  section in the  #each  block, which will be rendered if the array is empty.  {{#each superheroes}}\n   tr ... /tr \n{{else}}\n   tr td colspan=\"4\" Oh no! There are no superheroes! /td /tr \n{{/each}}  This also works with plain mustache sections.", 
            "title": "Step 1"
        }, 
        {
            "location": "/tutorials/iterative-sections/#step-2", 
            "text": "Start \n   Fix Code   Often when working with lists, we want to know the index of the list item we're currently rendering.  Mustache doesn't have a good way of doing this, so Ractive.js introduces the  index reference :  {{#each list: num}}\n   !-- inside here, {{num}} is the index -- \n{{/each}}   If you don't want to name your index, you can also use the generic index special reference  @index .  @index  will resolve to the index of the nearest iteration, so if you happen to have nested iterations, it will be the nearest parent iteration, not the root.  If your section happens to be iterating an object rather than an array, you can use the  @key  special reference to get the object key of the current iteration.   By declaring  num  to be an index reference, we can use it the same way we'd use any other variable. Let's add a number column to our table \u2013 first add the column to the header row:  tr \n   th # /th \n   th Superhero name /th \n   !-- etc --  /tr   Then to the list row:  {{#each superheroes: num}}\n   tr \n     td {{num}} /td \n     td a href='{{info}}' {{name}} /a /td \n     td {{realname}} /td \n     td {{power}} /td \n   /tr \n{{/each}}  Execute the code.  Not bad, but it would look better if the numbers started at 1 rather than 0. Use an expression to increment each row number by 1.", 
            "title": "Step 2"
        }, 
        {
            "location": "/tutorials/iterative-sections/#step-3", 
            "text": "Start   Let's say you wanted to add an item to your list. You could use  ractive.set()  the way you're used to, but you'd have to find the length of the existing array first:  var index = ractive.get( 'superheroes' ).length;\nractive.set( 'superheroes[' + index + ']', newSuperhero );  That's not ideal. We could use  ractive.update('superheroes')  instead, which will make sure that the table is up to date:  xmen[ xmen.length ] = newSuperhero;\nractive.update( 'superheroes' );   If you don't pass a keypath argument to  ractive.update() , Ractive.js will update everything that has changed since the last set or update.   But there's a more convenient way. Ractive.js provides mutator methods for arrays (push, pop, shift, unshift, splice, sort and reverse) that work with a keypath:  ractive.push( 'superheroes', newSuperhero );  Try adding Storm to the list by pushing to the array in the Script pane:  var newSuperhero = {\n  name: 'Storm',\n  realname: 'Monroe, Ororo',\n  power: 'Controlling the weather',\n  info: 'http://www.superherodb.com/Storm/10-135/'\n};\n\n// add the code here...", 
            "title": "Step 3"
        }, 
        {
            "location": "/tutorials/iterative-sections/#step-4", 
            "text": "Start \n   Fix Code   It's time to make our table sortable. We've added a 'sortable' class to the three headers to indicate they can be clicked on.  First, let's add an event listener to each column header, calling the instance  sort  method with the column header as an argument:  th class='sortable' on-click='@.sort( name )' Superhero name /th  th class='sortable' on-click='@.sort( realname )' Real name /th  th class='sortable' on-click='@.sort( power )' Superpower /th   That way, when the user clicks one of the column headers, the view will fire call the  sort  method.  ractive.sort = function ( column ) {\n  alert( 'Sorting by ' + column );\n});   You can add methods and properties directly to a Ractive.js instance by simply including them in the init options. Any keys that don't match know init options are added to the instance upon creation.   Execute the code. When you click on the three sortable headers, the browser should alert the name of the column we're sorting by. Now we just need to add the sorting logic.", 
            "title": "Step 4"
        }, 
        {
            "location": "/tutorials/iterative-sections/#step-5", 
            "text": "Start \n   Fix Code   So we've wired up our event handler, and it's behaving as it should. The next step is to add some logic that actually sorts the table. For bonus points, we'll add a 'sorted' class to the header of the sorted column.  There's a nice easy way to ensure that the table remains sorted, even when we add more data: an expression. That's right, you can use expressions with sections.  Update the template:  {{#each sort( superheroes ) : num}}\n   tr \n    !-- row contents -- \n   /tr \n{{/each}}  Now we need to add the  sort  function. Here's one (if you're not sure why this works,  here's an MDN page  that will help explain):  function ( array ) {\n  // grab the current sort column\n  var column = this.get( 'sortColumn' ); \n\n  // clone the array so as not to modify the underlying data\n  var arr = array.slice();\n\n  return arr.sort( function ( a, b ) {\n    return a[ sortColumn ]   b[ sortColumn ] ? -1 : 1;\n  });\n}  Wiring it up is easy:  ractive.sort = function ( column ) {\n  this.set( 'sortColumn', column );\n});  Try executing this code and clicking different headers to sort the table. (You could specify an initial sort column by adding e.g.  sortColumn: 'name'  to  data .)  The last job is to add a sorted class to the header of the currently sorted column. There are several ways we could do this \u2013 you could use a bit of jQuery inside the sort proxy event handler, for example. But for this demonstration we'll put the logic in the template, using the conditional operator:  th class='sortable' class-sorted= sortColumn === 'name'  on-click='@.sort( name )' \n  Superhero name /th    The  class-  directive is similar to the  style-  directive - it gives you direct control over the presence of a single class. The  class-  directive exists in an expression context, so mustaches are not required. If the expression passed to the directive is truthy, Ractive.js will add the class to the element, and if it's false-y, it will remove it.  You could also add an additional expression within the existing  class  attribute using a ternary e.g.  class=\"sortable {{ sortColumn === 'name' ? 'sorted' : '' }} .   Do this for each of the headers, then execute the code. Congratulations! You've built a sortable table in just a few steps. Now comes the fun part \u2013 add Storm back to the table. The table will maintain its sort order.  ractive.push( 'superheroes', {\n  name: 'Storm',\n  realname: 'Monroe, Ororo',\n  power: 'Controlling the weather',\n  info: 'http://www.superherodb.com/Storm/10-135/'\n});", 
            "title": "Step 5"
        }, 
        {
            "location": "/tutorials/two-way-binding/", 
            "text": "Two-way Binding\n\n\nHTML forms are a very important part of many web applications. Most data-binding in a template only goes in one direction - from the model to the view, but form elements provide a point at which the view could update the model. To that end, Ractive.js provides special bindings for form elements that go both ways - from the model to the view and from the view to the model - or two-way bindings.\n\n\nStep 1\n\n\n\n  \nStart\n\n  \nFix Code\n\n\n\n\nThe 'Hello, world!' of two-way data binding looks like this:\n\n\nlabel\n\n  Enter your name:\n  \ninput value='{{name}}'\n\n\n/label\n\n\n\np\nHello, {{name}}!\n/p\n\n\n\n\n\nUpdate the template and re-render it, then type your name in the box.\n\n\n\n\nInternally, we're binding to \ninput\n events (and \nkeyup\n for IE, since it doesn't fire \ninput\n correctly) alongside \nchange\n and \nblur\n events \u2013 this ensures instantaneous feedback for a slick experience.\n\n\nIf you'd rather the updates only happened on \nchange\n and \nblur\n, pass in \nlazy: true\n as an initialisation option.\n\n\nIf you'd rather disable two-way binding altogether, you can do so with \ntwoway: false\n.\n\n\nYou can also control two-way bindings and laziness on a per-element basis using the \ntwoway\n and \nlazy\n directives. The \nlazy\n directive may be boolean, or if you'd like to get updates without a blur, you can pass it a number of milliseconds to wait after the last \ninput\n event to trigger the update.\n\n\n\n\nThat's a cute demo, but it doesn't have much real world use. In all likelihood we want to do something with the data when it changes. For that, we use \nractive.observe()\n:\n\n\nractive.observe( 'name', function ( newValue, oldValue ) {\n  doSomethingWith( newValue );\n});\n\n\n\n\nStep 2\n\n\n\n  \nStart\n\n  \nFix Code\n\n\n\n\nYou can control whether checkboxes are checked or not like so:\n\n\nlabel\n\n  \ninput type='checkbox' checked='{{checked}}'\n\n  {{#if checked}}checked!{{else}}not checked{{/if}}\n\n/label\n\n\n\n\n\nUpdate the template and try toggling the checkbox.\n\n\nIf you have a group of radio buttons, whose values are mutually exclusive, you can do this:\n\n\nlabel\ninput type='radio' name='{{color}}' value='red' checked\n red\n/label\n\n\nlabel\ninput type='radio' name='{{color}}' value='green'\n green\n/label\n\n\nlabel\ninput type='radio' name='{{color}}' value='blue'\n blue\n/label\n\n\np\nThe selected colour is \nspan style='color: {{color}};'\n{{color}}\n/span\n.\n/p\n\n\n\n\n\nHere, because we've set the \nname\n attribute to \n{{color}}\n, the value of \ncolor\n is set to the \nvalue\n attribute of whichever radio button is currently checked. (If you need to read that sentence a couple of times, I don't blame you.) Notice that the value is initialised to \nred\n, because that option is initially checked.\n\n\nAdd \nname='{{color}}'\n to each of the options in the template and run the code.\n\n\n\n\nFront-end \u00fcber nerds will notice that this isn't how these attributes normally work. For example, a checkbox with checked='false' is the same as one with checked='true', because it's a boolean attribute which either exists on the element or doesn't \u2013 its value is completely irrelevant.\n\n\nFurthermore, once you've interacted with a checkbox, its checked attribute becomes irrelevant! You can only change the value programmatically by doing element.checked = true rather than  element.setAttribute( 'checked' ).\n\n\nCombine all that with cross-browser quirks (e.g. IE8 and below only fire  change events on blur), and we're in some seriously confusing territory.\n\n\nSo Ractive.js makes no apology for using checked='{{checked}}' to mean 'checked if checked is true, unchecked if it's false'. We're bringing sanity to the process of gathering user input.\n\n\n\n\nNeedless to say, you can continue to interact with the values programmatically:\n\n\nractive.set( 'checked', true );\nractive.set( 'color', 'green' );\n\n\n\n\nThis is as good a time as any to introduce the \nractive.toggle()\n method:\n\n\nractive.toggle( 'checked' );\n\n// Equivalent to:\n//   var checked = ractive.get( 'checked' );\n//   ractive.set( 'checked', !checked );\n\n\n\n\nStep 3\n\n\n\n  \nStart\n\n  \nFix Code\n\n\n\n\nAs well as \ninput\n elements (and \ntextarea\ns, which work similarly), two-way binding works with \nselect\n menus. Let's replace the radio group from the previous step with a \nselect\n:\n\n\nselect value='{{color}}'\n\n  \noption\nred\n/option\n\n  \noption\ngreen\n/option\n\n  \noption selected\nblue\n/option\n\n\n/select\n\n\n\n\n\n\n\nI apologise to my fellow Brits, and other English-speaking non-Americans, for the repeated use of color instead of colour. Occupational hazard.\n\n\n\n\nRe-render the ractive. Notice that once again, the data is initialised to the value of the selected \noption\n \u2013 in this case, blue. (You can explicity set a \nvalue\n attribute, but if you don't, the text content of the \noption\n is used instead.)\n\n\nThat's good, but we can go one better \u2013 rather than hard-coding our colours into the template, let's do it properly:\n\n\nselect value='{{color}}'\n\n  {{#each colors}}\n    \noption\n{{this}}\n/option\n\n  {{/each}}\n\n/select\n\n\n\n\n\n\n\nWe haven't seen \n{{this}}\n before \u2013 it simply means 'the current context'. Previously, whenever we've used lists, they've been lists of objects, so we've been able to use a property of the object (like \n{{name}}\n). Using this allows us to use lists of primitives (in this case, strings) instead.\n\n\nIf you prefer, you can use \n{{.}}\n instead of \n{{this}}\n.\n\n\nYou can also set up an alias to \nthis\n for a slightly more human friendly template in many circumstances. Within \n{{#each users as user}}...{{/each}}\n, \nuser\n will resolve to the current iteration. You can still use index names too e.g. \n{{#each users as user: i}}...{{/each}}\n.\n\n\n\n\nAnd add some data to our view:\n\n\nvar ractive = Ractive({\n  el: output,\n  template: template,\n  data: {\n    colors: [ 'red', 'green', 'blue' ],\n    color: 'green'\n  }\n});\n\n\n\n\n\n\nThe template no longer has an \noption\n with a \nselected\n attribute, so we need to specify an initial value of \ncolor\n.\nExecute this code. For extra credit, add more colours:\n\n\n\n\nractive.push( 'colors', 'purple' );\n\n\n\n\nStep 4\n\n\n\n  \nStart\n\n  \nFix Code\n\n\n\n\nIn some situations you need to make it possible to select several values simultaneously. HTML has us covered \u2013 we use the \nmultiple\n attribute with a \nselect\n.\n\n\nUnfortunately that's as helpful as it gets \u2013 \nselectElement.value\n returns the value of the \nmost recently selected\n option, which is just mad, frankly. In almost all cases, if you're using a select element with the \nmultiple\n attribute, what you really want is an array of the selected values. This is what Ractive.js provides.\n\n\nTry adding the \nmultiple\n attribute to the template:\n\n\nselect value='{{selectedColors}}' multiple\n\n\n\n\n\nExecute, then try making multiple selections. And, of course, it works the other way round:\n\n\n\n\n\nractive.set( 'selectedColors', [ 'green', 'purple' ]);", 
            "title": "Two-way Binding"
        }, 
        {
            "location": "/tutorials/two-way-binding/#two-way-binding", 
            "text": "HTML forms are a very important part of many web applications. Most data-binding in a template only goes in one direction - from the model to the view, but form elements provide a point at which the view could update the model. To that end, Ractive.js provides special bindings for form elements that go both ways - from the model to the view and from the view to the model - or two-way bindings.", 
            "title": "Two-way Binding"
        }, 
        {
            "location": "/tutorials/two-way-binding/#step-1", 
            "text": "Start \n   Fix Code   The 'Hello, world!' of two-way data binding looks like this:  label \n  Enter your name:\n   input value='{{name}}'  /label  p Hello, {{name}}! /p   Update the template and re-render it, then type your name in the box.   Internally, we're binding to  input  events (and  keyup  for IE, since it doesn't fire  input  correctly) alongside  change  and  blur  events \u2013 this ensures instantaneous feedback for a slick experience.  If you'd rather the updates only happened on  change  and  blur , pass in  lazy: true  as an initialisation option.  If you'd rather disable two-way binding altogether, you can do so with  twoway: false .  You can also control two-way bindings and laziness on a per-element basis using the  twoway  and  lazy  directives. The  lazy  directive may be boolean, or if you'd like to get updates without a blur, you can pass it a number of milliseconds to wait after the last  input  event to trigger the update.   That's a cute demo, but it doesn't have much real world use. In all likelihood we want to do something with the data when it changes. For that, we use  ractive.observe() :  ractive.observe( 'name', function ( newValue, oldValue ) {\n  doSomethingWith( newValue );\n});", 
            "title": "Step 1"
        }, 
        {
            "location": "/tutorials/two-way-binding/#step-2", 
            "text": "Start \n   Fix Code   You can control whether checkboxes are checked or not like so:  label \n   input type='checkbox' checked='{{checked}}' \n  {{#if checked}}checked!{{else}}not checked{{/if}} /label   Update the template and try toggling the checkbox.  If you have a group of radio buttons, whose values are mutually exclusive, you can do this:  label input type='radio' name='{{color}}' value='red' checked  red /label  label input type='radio' name='{{color}}' value='green'  green /label  label input type='radio' name='{{color}}' value='blue'  blue /label  p The selected colour is  span style='color: {{color}};' {{color}} /span . /p   Here, because we've set the  name  attribute to  {{color}} , the value of  color  is set to the  value  attribute of whichever radio button is currently checked. (If you need to read that sentence a couple of times, I don't blame you.) Notice that the value is initialised to  red , because that option is initially checked.  Add  name='{{color}}'  to each of the options in the template and run the code.   Front-end \u00fcber nerds will notice that this isn't how these attributes normally work. For example, a checkbox with checked='false' is the same as one with checked='true', because it's a boolean attribute which either exists on the element or doesn't \u2013 its value is completely irrelevant.  Furthermore, once you've interacted with a checkbox, its checked attribute becomes irrelevant! You can only change the value programmatically by doing element.checked = true rather than  element.setAttribute( 'checked' ).  Combine all that with cross-browser quirks (e.g. IE8 and below only fire  change events on blur), and we're in some seriously confusing territory.  So Ractive.js makes no apology for using checked='{{checked}}' to mean 'checked if checked is true, unchecked if it's false'. We're bringing sanity to the process of gathering user input.   Needless to say, you can continue to interact with the values programmatically:  ractive.set( 'checked', true );\nractive.set( 'color', 'green' );  This is as good a time as any to introduce the  ractive.toggle()  method:  ractive.toggle( 'checked' );\n\n// Equivalent to:\n//   var checked = ractive.get( 'checked' );\n//   ractive.set( 'checked', !checked );", 
            "title": "Step 2"
        }, 
        {
            "location": "/tutorials/two-way-binding/#step-3", 
            "text": "Start \n   Fix Code   As well as  input  elements (and  textarea s, which work similarly), two-way binding works with  select  menus. Let's replace the radio group from the previous step with a  select :  select value='{{color}}' \n   option red /option \n   option green /option \n   option selected blue /option  /select    I apologise to my fellow Brits, and other English-speaking non-Americans, for the repeated use of color instead of colour. Occupational hazard.   Re-render the ractive. Notice that once again, the data is initialised to the value of the selected  option  \u2013 in this case, blue. (You can explicity set a  value  attribute, but if you don't, the text content of the  option  is used instead.)  That's good, but we can go one better \u2013 rather than hard-coding our colours into the template, let's do it properly:  select value='{{color}}' \n  {{#each colors}}\n     option {{this}} /option \n  {{/each}} /select    We haven't seen  {{this}}  before \u2013 it simply means 'the current context'. Previously, whenever we've used lists, they've been lists of objects, so we've been able to use a property of the object (like  {{name}} ). Using this allows us to use lists of primitives (in this case, strings) instead.  If you prefer, you can use  {{.}}  instead of  {{this}} .  You can also set up an alias to  this  for a slightly more human friendly template in many circumstances. Within  {{#each users as user}}...{{/each}} ,  user  will resolve to the current iteration. You can still use index names too e.g.  {{#each users as user: i}}...{{/each}} .   And add some data to our view:  var ractive = Ractive({\n  el: output,\n  template: template,\n  data: {\n    colors: [ 'red', 'green', 'blue' ],\n    color: 'green'\n  }\n});   The template no longer has an  option  with a  selected  attribute, so we need to specify an initial value of  color .\nExecute this code. For extra credit, add more colours:   ractive.push( 'colors', 'purple' );", 
            "title": "Step 3"
        }, 
        {
            "location": "/tutorials/two-way-binding/#step-4", 
            "text": "Start \n   Fix Code   In some situations you need to make it possible to select several values simultaneously. HTML has us covered \u2013 we use the  multiple  attribute with a  select .  Unfortunately that's as helpful as it gets \u2013  selectElement.value  returns the value of the  most recently selected  option, which is just mad, frankly. In almost all cases, if you're using a select element with the  multiple  attribute, what you really want is an array of the selected values. This is what Ractive.js provides.  Try adding the  multiple  attribute to the template:  select value='{{selectedColors}}' multiple   Execute, then try making multiple selections. And, of course, it works the other way round:   ractive.set( 'selectedColors', [ 'green', 'purple' ]);", 
            "title": "Step 4"
        }, 
        {
            "location": "/tutorials/partials/", 
            "text": "Partials\n\n\nPartials are a good way to split complex templates up into several more manageable chunks. They also allow re-use of bits of template without having to repeat the template.\n\n\nStep 1\n\n\n\n  \nStart\n\n  \nFix Code\n\n\n\n\nTake this todo list, for example. It's not too bad, but the template would look neater if we could separate out the code for an individual item. Well, we can. Add this above the rest of the JavaScript:\n\n\nvar item = \nli class-done='.done'\n +\n           \n   \ninput type='checkbox' checked='{{.done}}'\n +\n           \n   \nspan class='description' on-click=\\\nedit\\\n +\n           \n   {{.description}}\n +\n           \n   {{#if .editing}}\n +\n           \n     \ninput class='edit'\n +\n           \n              value='{{.description}}'\n +\n           \n              on-blur='@context.toggle( \\\n.editing\\\n ), false'\n +\n           \n              on-keydown=\\\n@.enterExit( @event, @context )\\\n +\n           \n   {{/if}}\n +\n           \n   \n/span\n +\n           \n   \nbutton class='button' on-click='@context.splice( \\\n../\\\n, @index, 1 )'\n\u00d7\n/button\n +\n           \n \n/li\n;\n\n\n\n\nThen, in the main template we replace all that with a partial, which looks like a regular mustache but with a \n character:\n\n\nul class='todos'\n\n  {{#each items: i}}\n    {{\nitem}}\n  {{/each}}\n\n/ul\n\n\n\n\n\nFinally, we need to add the partial when we initialize out instance:\n\n\nvar ractive = Ractive({\n  target: '#target',\n  template: '#template',\n\n  partials: { item: item },\n  // etc...\n});\n\n\n\n\nExecute this code.\n\n\nStep 2\n\n\n\n  \nStart\n\n  \nFix Code\n\n\n\n\nFine, except that multiline string was fugly. It's good to know that you can pass partials in as strings, but unless you're loading those strings from a template file with AJAX, you'd probably prefer a neater way.\n\n\nThere are two. Firstly, you can add partials as \nscript\n tags on the page:\n\n\nscript id=\nitem\n type=\ntext/html\n\n  \nli class-done='.done'\n\n    \ninput type='checkbox' checked='{{.done}}'\n\n    \nspan class='description' on-click=\nedit\n\n      {{.description}}\n\n      {{#if .editing}}\n        \ninput class='edit'\n               value='{{.description}}'\n               on-blur='@context.toggle( \n.editing\n ), false'\n               on-keydown=\n@.enterExit( @event, @context )\n\n      {{/if}}\n    \n/span\n\n    \nbutton class='button' on-click='@context.splice( \n../\n, @index, 1 )'\n\u00d7\n/button\n\n  \n/li\n\n\n/script\n\n\n\n\n\n\n\nNote that the \nid\n attribute is the name of the partial, and that the \ntype\n attribute is \ntext/html\n (though it could be anything, as long as it's not \ntext/javascript\n). This is a convenient way to quickly test ideas out on a blank page (you can use these script tags as main templates as well as partials - just reference them as e.g. \n'#myTemplate'\n in your initialisation options).\n\n\n\n\nOr, you can use an \ninline partial\n. Inline partials are declared within your template, using the \n{{#partial myPartialName}}\n syntax:\n\n\n{{#partial item}}\n  \nli class-done='.done'\n\n    \ninput type='checkbox' checked='{{.done}}'\n\n    \nspan class='description' on-click=\nedit\n\n      {{.description}}\n\n      {{#if .editing}}\n        \ninput class='edit'\n               value='{{.description}}'\n               on-blur='@context.toggle( \n.editing\n ), false'\n               on-keydown=\n@.enterExit( @event, @context )\n\n      {{/if}}\n    \n/span\n\n    \nbutton class='button' on-click='@context.splice( \n../\n, @index, 1 )'\n\u00d7\n/button\n\n  \n/li\n\n{{/partial}}\n\n\n\n\nAdd the partial to the template, and remove it (and the \nvar item = ...\n bit) from the javascript code.\n\n\n\n\nIn addition to supporting partial strings, Ractive.js will accept a pre-parsed template in the \npartials\n map, or as the \ntemplate\n option, for that matter. Pre-parsed partials have the benefit of not requiring the parser at runtime, which means rendering can happen a bit faster - and you can ship a lighter-weight version of Ractive.js to the browser (see the runtime-only build).\n\n\n\n\nStep 3\n\n\n\n  \nStart\n\n  \nFix Code\n\n\n\n\nThat covers breaking templates into more manageable or logical chunks, so moving on to reuse, we'll grab our handy bag of contrivances and pull out... a formatted name. It's a bit simple, but it should suffice.\n\n\nSuppose we have a webapp that deals with people, businesses, and the yachts that they own. All three of those happen to have names that we'll say are broken down in slightly different ways. A yacht just has a name. A business has a name and a potential classifier, like LLC. A person has a given name, a family name, any number of middle names, and a potential suffix. A yacht is also owned by a business or a person, which, as we've established, both have names. (We're gonna go ahead and pretend that most yacht owners don't have a corporate entity to hold their yachts.)\n\n\nWhat we want to do is take our list of yachts with their various owners and display them in the table. Here's a partial that would work with each type of entity:\n\n\n{{#if .type === 'business'}}\n  {{.name}}{{.classifier ? `, ${.classifier}` : ''}}\n{{elseif .type === 'yacht'}}\n  {{name}}\n{{else}}\n  {{.familyName}}, {{.givenName}}{{.suffix ? ` ${.suffix}` : ''}}\n{{/if}}\n\n\n\n\nNow we want to use the partial for both the yacht and the owner, but the owner is a property of the yacht. We could use a \n#with\n block to set the context for the owner partial. It turns out that's a pretty common thing to need when working with complex apps with lots of partials, so Ractive.js has a sugared version of a partial that accepts a context after the partial name:\n\n\n{{\nname .owner}}\n\n\n\n\n\n\nThis is roughly equivalent to \n{{#with .owner}}{{\nname}}{{/with}}\n, but not quite exactly the same. For reasons that will become clear in the next step, the \n#with\n portion of the partial with context is wrapped around the template of the partial and not the partial mustache itself.\n\n\nIf no context is supplied to a partial, then it inherits its context from its parent.\n\n\nPartials may also set aliases instead of passing a context, which is convenient if there's more than one bit of data that needs to be uniform going into the partial. For instance \n{{\nuser .homePhone as phone, .workEmail as email}}\n lets the caller of the partial specify what \n{{phone}}\n and \n{{email}}\n should mean inside the partial. Again, this is the rough equivalent of the similar \n#with\n construct, \n{{#with .homePhone as phone, .workEmail as email}}{{\nuser}}{{/with}}\n.\n\n\n\n\nStep 4\n\n\n\n  \nStart\n\n  \nFix Code\n\n\n\n\nThat last contrivance was a bit stretched, so let's stretch it a bit further and see if it breaks. We want to future-proof our webapp in case some other type of entity should arise to be involved with our yachts. So we decide that we want to create a specific partial for each type of entity:\n\n\n{{#if .type === 'business'}}\n  {{\nbusiness-name}}\n{{elseif .type === 'yacht'}}\n  {{\nyacht-name}}\n{{else}}\n  {{\nperson-name}}\n{{/if}}\n\n\n\n\nPerhaps that's a bit better, but it's not very expandable \nor\n pretty. As it turns out, the name given to a partial mustache may also be an expression that evaluates to a string. So we can go ahead and replace our wrapper-partial with something simple:\n\n\n{{\n `${.type}-name`}}\n\n\n\n\n\n\nWhen the expression evaluates, it will return a string, which will then be used to look up the appropriate partial in the registry. Partials check for a matching name before evaluating as an expression, so if you an expression that could also be a valid partial name, the partial name will be picked rather that the result of evaluating the expression. For example with partials named \nuser\n and \nlarry\n and a property \nuser: 'larry'\n, \n{{\nuser}}\n will use the \nuser\n partial rather than the \nlarry\n partial.\n\n\n\n\nNow when it turns out that we need to also keep up with buildings, that for our purposes include a street address in their name, we can do so easily by adding a new partial named \nbuilding-name\n:\n\n\n{{.name}}, {{.address}}\n\n\n\n\nI think that contrivance has snapped, possibly in more than one place, but hopefully it was served its purpose.", 
            "title": "Partials"
        }, 
        {
            "location": "/tutorials/partials/#partials", 
            "text": "Partials are a good way to split complex templates up into several more manageable chunks. They also allow re-use of bits of template without having to repeat the template.", 
            "title": "Partials"
        }, 
        {
            "location": "/tutorials/partials/#step-1", 
            "text": "Start \n   Fix Code   Take this todo list, for example. It's not too bad, but the template would look neater if we could separate out the code for an individual item. Well, we can. Add this above the rest of the JavaScript:  var item =  li class-done='.done'  +\n                input type='checkbox' checked='{{.done}}'  +\n                span class='description' on-click=\\ edit\\  +\n               {{.description}}  +\n               {{#if .editing}}  +\n                  input class='edit'  +\n                          value='{{.description}}'  +\n                          on-blur='@context.toggle( \\ .editing\\  ), false'  +\n                          on-keydown=\\ @.enterExit( @event, @context )\\  +\n               {{/if}}  +\n                /span  +\n                button class='button' on-click='@context.splice( \\ ../\\ , @index, 1 )' \u00d7 /button  +\n              /li ;  Then, in the main template we replace all that with a partial, which looks like a regular mustache but with a   character:  ul class='todos' \n  {{#each items: i}}\n    {{ item}}\n  {{/each}} /ul   Finally, we need to add the partial when we initialize out instance:  var ractive = Ractive({\n  target: '#target',\n  template: '#template',\n\n  partials: { item: item },\n  // etc...\n});  Execute this code.", 
            "title": "Step 1"
        }, 
        {
            "location": "/tutorials/partials/#step-2", 
            "text": "Start \n   Fix Code   Fine, except that multiline string was fugly. It's good to know that you can pass partials in as strings, but unless you're loading those strings from a template file with AJAX, you'd probably prefer a neater way.  There are two. Firstly, you can add partials as  script  tags on the page:  script id= item  type= text/html \n   li class-done='.done' \n     input type='checkbox' checked='{{.done}}' \n     span class='description' on-click= edit \n      {{.description}}\n\n      {{#if .editing}}\n         input class='edit'\n               value='{{.description}}'\n               on-blur='@context.toggle(  .editing  ), false'\n               on-keydown= @.enterExit( @event, @context ) \n      {{/if}}\n     /span \n     button class='button' on-click='@context.splice(  ../ , @index, 1 )' \u00d7 /button \n   /li  /script    Note that the  id  attribute is the name of the partial, and that the  type  attribute is  text/html  (though it could be anything, as long as it's not  text/javascript ). This is a convenient way to quickly test ideas out on a blank page (you can use these script tags as main templates as well as partials - just reference them as e.g.  '#myTemplate'  in your initialisation options).   Or, you can use an  inline partial . Inline partials are declared within your template, using the  {{#partial myPartialName}}  syntax:  {{#partial item}}\n   li class-done='.done' \n     input type='checkbox' checked='{{.done}}' \n     span class='description' on-click= edit \n      {{.description}}\n\n      {{#if .editing}}\n         input class='edit'\n               value='{{.description}}'\n               on-blur='@context.toggle(  .editing  ), false'\n               on-keydown= @.enterExit( @event, @context ) \n      {{/if}}\n     /span \n     button class='button' on-click='@context.splice(  ../ , @index, 1 )' \u00d7 /button \n   /li \n{{/partial}}  Add the partial to the template, and remove it (and the  var item = ...  bit) from the javascript code.   In addition to supporting partial strings, Ractive.js will accept a pre-parsed template in the  partials  map, or as the  template  option, for that matter. Pre-parsed partials have the benefit of not requiring the parser at runtime, which means rendering can happen a bit faster - and you can ship a lighter-weight version of Ractive.js to the browser (see the runtime-only build).", 
            "title": "Step 2"
        }, 
        {
            "location": "/tutorials/partials/#step-3", 
            "text": "Start \n   Fix Code   That covers breaking templates into more manageable or logical chunks, so moving on to reuse, we'll grab our handy bag of contrivances and pull out... a formatted name. It's a bit simple, but it should suffice.  Suppose we have a webapp that deals with people, businesses, and the yachts that they own. All three of those happen to have names that we'll say are broken down in slightly different ways. A yacht just has a name. A business has a name and a potential classifier, like LLC. A person has a given name, a family name, any number of middle names, and a potential suffix. A yacht is also owned by a business or a person, which, as we've established, both have names. (We're gonna go ahead and pretend that most yacht owners don't have a corporate entity to hold their yachts.)  What we want to do is take our list of yachts with their various owners and display them in the table. Here's a partial that would work with each type of entity:  {{#if .type === 'business'}}\n  {{.name}}{{.classifier ? `, ${.classifier}` : ''}}\n{{elseif .type === 'yacht'}}\n  {{name}}\n{{else}}\n  {{.familyName}}, {{.givenName}}{{.suffix ? ` ${.suffix}` : ''}}\n{{/if}}  Now we want to use the partial for both the yacht and the owner, but the owner is a property of the yacht. We could use a  #with  block to set the context for the owner partial. It turns out that's a pretty common thing to need when working with complex apps with lots of partials, so Ractive.js has a sugared version of a partial that accepts a context after the partial name:  {{ name .owner}}   This is roughly equivalent to  {{#with .owner}}{{ name}}{{/with}} , but not quite exactly the same. For reasons that will become clear in the next step, the  #with  portion of the partial with context is wrapped around the template of the partial and not the partial mustache itself.  If no context is supplied to a partial, then it inherits its context from its parent.  Partials may also set aliases instead of passing a context, which is convenient if there's more than one bit of data that needs to be uniform going into the partial. For instance  {{ user .homePhone as phone, .workEmail as email}}  lets the caller of the partial specify what  {{phone}}  and  {{email}}  should mean inside the partial. Again, this is the rough equivalent of the similar  #with  construct,  {{#with .homePhone as phone, .workEmail as email}}{{ user}}{{/with}} .", 
            "title": "Step 3"
        }, 
        {
            "location": "/tutorials/partials/#step-4", 
            "text": "Start \n   Fix Code   That last contrivance was a bit stretched, so let's stretch it a bit further and see if it breaks. We want to future-proof our webapp in case some other type of entity should arise to be involved with our yachts. So we decide that we want to create a specific partial for each type of entity:  {{#if .type === 'business'}}\n  {{ business-name}}\n{{elseif .type === 'yacht'}}\n  {{ yacht-name}}\n{{else}}\n  {{ person-name}}\n{{/if}}  Perhaps that's a bit better, but it's not very expandable  or  pretty. As it turns out, the name given to a partial mustache may also be an expression that evaluates to a string. So we can go ahead and replace our wrapper-partial with something simple:  {{  `${.type}-name`}}   When the expression evaluates, it will return a string, which will then be used to look up the appropriate partial in the registry. Partials check for a matching name before evaluating as an expression, so if you an expression that could also be a valid partial name, the partial name will be picked rather that the result of evaluating the expression. For example with partials named  user  and  larry  and a property  user: 'larry' ,  {{ user}}  will use the  user  partial rather than the  larry  partial.   Now when it turns out that we need to also keep up with buildings, that for our purposes include a street address in their name, we can do so easily by adding a new partial named  building-name :  {{.name}}, {{.address}}  I think that contrivance has snapped, possibly in more than one place, but hopefully it was served its purpose.", 
            "title": "Step 4"
        }, 
        {
            "location": "/tutorials/triples-embedded-html/", 
            "text": "Triples (Embedded HTML)\n\n\nOrdinarily in a template, mustaches stand in for data, which is HTML escaped for sanitary purposes. But occasionally you need to insert chunks of HTML into your view \u2013 for that, we have the triple-stache: \n{{{content}}}\n.\n\n\nStep 1\n\n\n\n  \nStart\n\n\n\n\nTry running this code:\n\n\nractive.set( 'content', '\na href=\nhttp://bit.ly/QOyWC1\nimg src=\n/gifs/image.gif\n/\n/a\n' );\n\n\n\n\n\n\nThat was a short tutorial! When using triples, bear in mind that when their data changes, the nodes they represent must be removed from the DOM before being re-rendered and reinserted. For that reason, you shouldn't use triples where regular mustaches will do the same job \u2013 Ractive.js is able to operate more efficiently with mustaches.", 
            "title": "Triples (Embedded HTML)"
        }, 
        {
            "location": "/tutorials/triples-embedded-html/#triples-embedded-html", 
            "text": "Ordinarily in a template, mustaches stand in for data, which is HTML escaped for sanitary purposes. But occasionally you need to insert chunks of HTML into your view \u2013 for that, we have the triple-stache:  {{{content}}} .", 
            "title": "Triples (Embedded HTML)"
        }, 
        {
            "location": "/tutorials/triples-embedded-html/#step-1", 
            "text": "Start   Try running this code:  ractive.set( 'content', ' a href= http://bit.ly/QOyWC1 img src= /gifs/image.gif / /a ' );   That was a short tutorial! When using triples, bear in mind that when their data changes, the nodes they represent must be removed from the DOM before being re-rendered and reinserted. For that reason, you shouldn't use triples where regular mustaches will do the same job \u2013 Ractive.js is able to operate more efficiently with mustaches.", 
            "title": "Step 1"
        }, 
        {
            "location": "/tutorials/components/", 
            "text": "Components\n\n\nIf you've used Backbone Views in the past, you'll be familiar with the basic concept of \nextending\n the \nbase class\n to create a new \nsubclass\n with default data and additional methods.\n\n\nStep 1\n\n\n\n  \nStart\n\n  \nFix Code\n\n\n\n\nIn this tutorial we're first going to learn about Ractive.extend and use it to create an image slideshow, using gifs from \ndevopsreactions.tumblr.com\n.\n\n\nWe've got our basic template set up \u2013 we just need to make a few additions. First, we need to add a mustache for the image URL:\n\n\ndiv class='main-image'\n     style='background-image: url(\n{{image.src}}\n);'\n\n\n/div\n\n\n\n\n\nWe're using a CSS background rather than an \nimg\n element for this example, because you can use the \nbackground-size: contain\n CSS rule to ensure that the image is shown at maximum size without distorting the aspect ratio.\n\n\nThen, we need to add a mustache for the image caption:\n\n\ndiv class='caption'\n\n  \np\n{{image.caption}}\n/p\n\n\n/div\n\n\n\n\n\nFinally, let's add some event expressions that we can fill in later:\n\n\na class='prev' on-click='@.goto(current - 1)'\nspan\nlaquo;\n/span\n/a\n\n\n!-- ... --\n\n\na class='next' on-click='@.goto(current + 1)'\nspan\nraquo;\n/span\n/a\n\n\n\n\n\nExecute the JavaScript to redraw the view, with the placeholder data that's already there.\n\n\nStep 2\n\n\n\n  \nStart\n\n  \nFix Code\n\n\n\n\nTime to create our \nSlideshow\n class:\n\n\nvar Slideshow = Ractive.extend({\n  // this will be applied to all Slideshow instances\n  template: '#slideshow',\n\n  // method for changing the currently displayed image\n  goto: function ( imageNum ) {\n    // goto method goes here...\n  },\n\n  // default data\n  oninit: function () {\n    // return the default data for the component here\n  }\n});\n\n\n\n\nEach \nSlideshow\n instance will have a \ngoto\n method in addition to the normal \nRactive\n instance methods. We'll also provide default data for the component, notably to start with the \ncurrent\n index as \n0\n.\n\n\n\n\nWhen providing data for components, you should always use a data function that returns a data dictionary. If you return the same object from each invocation, then all of your component instances will share the same underlying data, but the properties won't necessarily be kept up-to-date across instances.\n\n\nComponent data and instance data is combined into the final instance's data dictionary starting with Ractive default data, moving through the component hierarchy, and ending with the data supplied to the instance constructor.\n\n\n\n\nLet's write our \ngoto\n method:\n\n\nfunction ( index ) {\n  var images = this.get( 'images' );\n\n  // handle wrap around\n  var num = ( index + images.length ) % images.length;\n\n  this.set( 'current', num );\n}\n\n\n\n\nLet's add some code to instantiate the slideshow with our gifs. There's a ready-made images variable you can use for this step:\n\n\nvar slideshow = Slideshow({\n  target: '#target',\n  data: { images: images }\n});\n\n\n\n\nGo ahead and execute the code \u2013 you should now have a working slideshow.\n\n\n\n\nNeedless to say, you could add as many bells and whistles as you wanted \u2013 fading or sliding transitions, image preloading, thumbnails, touchscreen gesture controls, and so on.\n\n\nYou could, of course, just use an existing image slideshow library. But then you would have to learn that library, and potentially submit to its design philosophy.\n\n\nRactive.js is all about flexibility. If you want to change the design or behaviour of a component (say, adding a class name to a particular element), the power to do so is in your hands \u2013 the template is easy to understand and tweak because it's basically just HTML, and the view logic is straightforward.\n\n\nIt's better to be able to build your own solution than to rely on developers maintaining high quality and up-to-date documentation.\n\n\n\n\nStep 3\n\n\n\n  \nStart\n\n  \nFix Code\n\n\n\n\nNow we have our lovely slideshow component, but suppose we want to use it in our Ractive.js app rather than mounting it directly on an element. It turns out that that is a pretty simple thing to accomplish. We can register our component with either globally or with our main Ractive.js instance, and anywhere that the template has a \nslideshow /\n element, Ractive.js will create an instance of \nSlideshow\n and mount it inline.\n\n\nRactive.components.slideshow = Slideshow;\n\n// or\nvar ractive = Ractive({\n    // ...\n\n  components: {\n    slideshow: Slideshow\n  },\n\n  // ...\n});\n\n\n\n\nNow in the template, we just reference the component as if it were a custom element:\n\n\ndiv style-height=\n40vh\n\n  \nslideshow /\n\n\n/div\n\n\n\n\n\nWe \nwere\n passing the list of pictures to the instance as it was being initialized, but since Ractive.js is now managing the instance, how do we get the list of pictures to the component instance? Well, we create a mapping from the data in the host instance to the \nimages\n keypath in the component by using an attribute:\n\n\ndiv style-height=\n40vh\n\n  \nslideshow images=\n{{devopsImages}}\n /\n\n\n/div\n\n\n\n\n\nUpdate the code with another images array and put two \nslideshow\n components in the main instance.\n\n\n\n\nMappings are automatically managed cross-instance \nlink\ns. A link is a bit like a filesystem symlink in that the data isn't copied anywhere - it just gets a new path that points to it. Changing the data in either place is effectively the same as changing it everywhere at once.\n\n\n\n\nStep 4\n\n\n\n  \nStart\n\n  \nFix Code\n\n\n\n\nWe have our image slideshow usable from any app now, but what if we wanted to make it slightly more customizable? Perhaps we could allow the user to have a bit more control over the template by, say, letting them include some sort of disclaimer on all of the slides. We could hard-code the disclaimer in a special version for each client, but that sounds like it would be awful to maintain.\n\n\nFortunately, Ractive.js allows you to use the content of a component tag to pass partials to the component instance. Any content not within a \n{{#patial}}\n tag is collected up and exposed to the component as a partial named \ncontent\n. Any \n{{#partial}}\ns are supplied to the component instance with the names they are given in the \n{{#partial}}\n tag. We'll use a disclaimer partial for our component:\n\n\nslideshow\n\n  {{#partial disclaimer}}\ndiv class=\ndisclaimer\nI don't know what we're disclaiming, but we're disclaiming it \na on-click=\n@.disclaim(), false\n href=\n#\nhere\n/a\n.\n/div\n{{/partial}}\n\n/slideshow\n\n\n\n\n\nWe can add a reference to the partial in the \nSlideshow\n component template:\n\n\n{{\ndisclaimer}}\n\n\n\n\n\n\nIt's not a bad idea to supply a default partial with the component, so that Ractive.js doesn't emit any warnings about missing partials. Any partials passed to the component will override any supplied to \nextend\n.\n\n\n\n\nNow what will happen when you click the \"here\" link? Partials exist completely in the context of the instance in which they are used, and there is no \ndisclaim\n method on the \nSlideshow\n component, so nothing will happen (except an error will be logged to the console). If you want a passed-in partial to render in the context from which it was passed, you can \n{{yield}}\n it.\n\n\n{{yield disclaimer}}\n\n\n\n\nAdd a \ndisclaim\n method to the main instance, update the \nSlideshow\n component, and run the code to see it all in action.\n\n\n\n\nSince \nyield\n puts the partial in the context of the caller, there's not much point in using it within an \n#each\n block because the array being iterated is unreachable from the \nyield\n. \nyield\ns can also supply aliases to data local to the component e.g. \n{{yield disclaimer with current as currentImage}}\n. \nyield\ning the \ncontent\n partial just requires dropping the name.\n\n\n\n\nStep 5\n\n\n\n  \nStart\n\n  \nFix Code\n\n\n\n\nNow suppose we wanted to do something to each of our component instances as they're created, like validate that they have certain parameters provided and issue a warning if they don't. Ractive.js components actually have a pretty complete set of lifecycle events that allow component authors to hook into just about every stage of a component's lifecycle - from \nconstruct\nion to \ndestruct\nion hitting \ninit\n, \nrender\n, \nunrender\n, \nteardown\n, \ncomplete\n (\nrender\n complete along with any transitions) and a few others in between. Each lifecycle event also happens to be an instance event.\n\n\nLets add our check to make sure the \nSlideshow\n component receives an \nimage\n parameter. There are a few ways to do this, including using \non\n and providing an \noninit\n function as an initialization parameter.\n\n\nvar ractive = Ractive({\n  // ...\n  on: {\n    init: function () {}\n  },\n  // ...\n});\n\n// or\n\nvar ractive = Ractive({\n  // ...\n  oninit: function () {},\n  // ...\n});\n\n// for other lifecycle events, you can attach after init\n\nractive.on( 'render', function () {} );\n\n\n\n\nAdd an \ninit\n event handler that checks to see if there are no images and issues a warning if there are none.\n\n\nStep 6\n\n\n\n  \nStart\n\n  \nFix Code\n\n\n\n\nWhen we started out with our slideshow, we were rendering it directly to a target element rather than as a component in another Ractive.js instance. It turns out that having self-contained components like that is a pretty convenient pattern for managing complexity in a larger app. All of the related functionality for a feature or group of features can be grouped into one Ractive.js extension known as a \nview\n. Each individual view can then be loaded and/or rendered independently.\n\n\nIn order to use views with a main instance controlling the overall app, you would have to have some sort of big \n#if\n/\nelse\n block with each view included as a branch. You could also resort to some sort of partial generation scheme. There's an easier way though.\n\n\nRactive.js will allow you to attach one independent instance to another using \nattachChild\n, optionally specifying a \ntarget\n. If you don't specify a target, then the child instance will not be rendered, but if you \ndo\n specify a target, then the instance will be rendered into the first available matching \nanchor\n. An anchor looks like a component or element, but its name always starts with a \n#\n. You may have as many anchors as you like, and they may each have the same or different names.\n\n\n#anchor /\n\n\n#ICallThisOneStan\n\n  Stan has a content partial.\n  {{#partial name}}He also has a name partial.{{/partial}}\n\n/ICallThisOneStan\n\n\n\n\n\nGo ahead and fill out the two provided views as you like, add anchors to the main instance template, and attach an instance of each view to an anchor on the main instance.\n\n\n\n\nYou can detach a child using the conveniently named \ndetachChild\n method.\n\n\nChild instances can be attached in \nprepend\n, \ninsertAt\n, or \nappend\n (the default) mode. Ractive.js will try to find a matching anchor for each child starting with the first. If there aren't enough anchors, some instances will not be rendered. Each time a child is attached or detached, Ractive.js will adjust any affected anchors so all instances that can be rendered are rendered.\n\n\nEach anchor has its own list of children associated with it, which is what the attachment modes are referreing to - \nprepend\n will insert a child at the front, \nappend\n at the end, and \ninsertAt\n at the specified index. The list of children for a particular anchor, say \n#main /\n, is kept up to date in an observable way so that you can automatically generate anchors as components are attached using \n{{#each @.children.byName.main}}\n#main /\n{{/each}}\n.\n\n\nAn anchored attached child is effectively a component that the host instance doesn't control.", 
            "title": "Components"
        }, 
        {
            "location": "/tutorials/components/#components", 
            "text": "If you've used Backbone Views in the past, you'll be familiar with the basic concept of  extending  the  base class  to create a new  subclass  with default data and additional methods.", 
            "title": "Components"
        }, 
        {
            "location": "/tutorials/components/#step-1", 
            "text": "Start \n   Fix Code   In this tutorial we're first going to learn about Ractive.extend and use it to create an image slideshow, using gifs from  devopsreactions.tumblr.com .  We've got our basic template set up \u2013 we just need to make a few additions. First, we need to add a mustache for the image URL:  div class='main-image'\n     style='background-image: url( {{image.src}} );'  /div   We're using a CSS background rather than an  img  element for this example, because you can use the  background-size: contain  CSS rule to ensure that the image is shown at maximum size without distorting the aspect ratio.  Then, we need to add a mustache for the image caption:  div class='caption' \n   p {{image.caption}} /p  /div   Finally, let's add some event expressions that we can fill in later:  a class='prev' on-click='@.goto(current - 1)' span laquo; /span /a  !-- ... --  a class='next' on-click='@.goto(current + 1)' span raquo; /span /a   Execute the JavaScript to redraw the view, with the placeholder data that's already there.", 
            "title": "Step 1"
        }, 
        {
            "location": "/tutorials/components/#step-2", 
            "text": "Start \n   Fix Code   Time to create our  Slideshow  class:  var Slideshow = Ractive.extend({\n  // this will be applied to all Slideshow instances\n  template: '#slideshow',\n\n  // method for changing the currently displayed image\n  goto: function ( imageNum ) {\n    // goto method goes here...\n  },\n\n  // default data\n  oninit: function () {\n    // return the default data for the component here\n  }\n});  Each  Slideshow  instance will have a  goto  method in addition to the normal  Ractive  instance methods. We'll also provide default data for the component, notably to start with the  current  index as  0 .   When providing data for components, you should always use a data function that returns a data dictionary. If you return the same object from each invocation, then all of your component instances will share the same underlying data, but the properties won't necessarily be kept up-to-date across instances.  Component data and instance data is combined into the final instance's data dictionary starting with Ractive default data, moving through the component hierarchy, and ending with the data supplied to the instance constructor.   Let's write our  goto  method:  function ( index ) {\n  var images = this.get( 'images' );\n\n  // handle wrap around\n  var num = ( index + images.length ) % images.length;\n\n  this.set( 'current', num );\n}  Let's add some code to instantiate the slideshow with our gifs. There's a ready-made images variable you can use for this step:  var slideshow = Slideshow({\n  target: '#target',\n  data: { images: images }\n});  Go ahead and execute the code \u2013 you should now have a working slideshow.   Needless to say, you could add as many bells and whistles as you wanted \u2013 fading or sliding transitions, image preloading, thumbnails, touchscreen gesture controls, and so on.  You could, of course, just use an existing image slideshow library. But then you would have to learn that library, and potentially submit to its design philosophy.  Ractive.js is all about flexibility. If you want to change the design or behaviour of a component (say, adding a class name to a particular element), the power to do so is in your hands \u2013 the template is easy to understand and tweak because it's basically just HTML, and the view logic is straightforward.  It's better to be able to build your own solution than to rely on developers maintaining high quality and up-to-date documentation.", 
            "title": "Step 2"
        }, 
        {
            "location": "/tutorials/components/#step-3", 
            "text": "Start \n   Fix Code   Now we have our lovely slideshow component, but suppose we want to use it in our Ractive.js app rather than mounting it directly on an element. It turns out that that is a pretty simple thing to accomplish. We can register our component with either globally or with our main Ractive.js instance, and anywhere that the template has a  slideshow /  element, Ractive.js will create an instance of  Slideshow  and mount it inline.  Ractive.components.slideshow = Slideshow;\n\n// or\nvar ractive = Ractive({\n    // ...\n\n  components: {\n    slideshow: Slideshow\n  },\n\n  // ...\n});  Now in the template, we just reference the component as if it were a custom element:  div style-height= 40vh \n   slideshow /  /div   We  were  passing the list of pictures to the instance as it was being initialized, but since Ractive.js is now managing the instance, how do we get the list of pictures to the component instance? Well, we create a mapping from the data in the host instance to the  images  keypath in the component by using an attribute:  div style-height= 40vh \n   slideshow images= {{devopsImages}}  /  /div   Update the code with another images array and put two  slideshow  components in the main instance.   Mappings are automatically managed cross-instance  link s. A link is a bit like a filesystem symlink in that the data isn't copied anywhere - it just gets a new path that points to it. Changing the data in either place is effectively the same as changing it everywhere at once.", 
            "title": "Step 3"
        }, 
        {
            "location": "/tutorials/components/#step-4", 
            "text": "Start \n   Fix Code   We have our image slideshow usable from any app now, but what if we wanted to make it slightly more customizable? Perhaps we could allow the user to have a bit more control over the template by, say, letting them include some sort of disclaimer on all of the slides. We could hard-code the disclaimer in a special version for each client, but that sounds like it would be awful to maintain.  Fortunately, Ractive.js allows you to use the content of a component tag to pass partials to the component instance. Any content not within a  {{#patial}}  tag is collected up and exposed to the component as a partial named  content . Any  {{#partial}} s are supplied to the component instance with the names they are given in the  {{#partial}}  tag. We'll use a disclaimer partial for our component:  slideshow \n  {{#partial disclaimer}} div class= disclaimer I don't know what we're disclaiming, but we're disclaiming it  a on-click= @.disclaim(), false  href= # here /a . /div {{/partial}} /slideshow   We can add a reference to the partial in the  Slideshow  component template:  {{ disclaimer}}   It's not a bad idea to supply a default partial with the component, so that Ractive.js doesn't emit any warnings about missing partials. Any partials passed to the component will override any supplied to  extend .   Now what will happen when you click the \"here\" link? Partials exist completely in the context of the instance in which they are used, and there is no  disclaim  method on the  Slideshow  component, so nothing will happen (except an error will be logged to the console). If you want a passed-in partial to render in the context from which it was passed, you can  {{yield}}  it.  {{yield disclaimer}}  Add a  disclaim  method to the main instance, update the  Slideshow  component, and run the code to see it all in action.   Since  yield  puts the partial in the context of the caller, there's not much point in using it within an  #each  block because the array being iterated is unreachable from the  yield .  yield s can also supply aliases to data local to the component e.g.  {{yield disclaimer with current as currentImage}} .  yield ing the  content  partial just requires dropping the name.", 
            "title": "Step 4"
        }, 
        {
            "location": "/tutorials/components/#step-5", 
            "text": "Start \n   Fix Code   Now suppose we wanted to do something to each of our component instances as they're created, like validate that they have certain parameters provided and issue a warning if they don't. Ractive.js components actually have a pretty complete set of lifecycle events that allow component authors to hook into just about every stage of a component's lifecycle - from  construct ion to  destruct ion hitting  init ,  render ,  unrender ,  teardown ,  complete  ( render  complete along with any transitions) and a few others in between. Each lifecycle event also happens to be an instance event.  Lets add our check to make sure the  Slideshow  component receives an  image  parameter. There are a few ways to do this, including using  on  and providing an  oninit  function as an initialization parameter.  var ractive = Ractive({\n  // ...\n  on: {\n    init: function () {}\n  },\n  // ...\n});\n\n// or\n\nvar ractive = Ractive({\n  // ...\n  oninit: function () {},\n  // ...\n});\n\n// for other lifecycle events, you can attach after init\n\nractive.on( 'render', function () {} );  Add an  init  event handler that checks to see if there are no images and issues a warning if there are none.", 
            "title": "Step 5"
        }, 
        {
            "location": "/tutorials/components/#step-6", 
            "text": "Start \n   Fix Code   When we started out with our slideshow, we were rendering it directly to a target element rather than as a component in another Ractive.js instance. It turns out that having self-contained components like that is a pretty convenient pattern for managing complexity in a larger app. All of the related functionality for a feature or group of features can be grouped into one Ractive.js extension known as a  view . Each individual view can then be loaded and/or rendered independently.  In order to use views with a main instance controlling the overall app, you would have to have some sort of big  #if / else  block with each view included as a branch. You could also resort to some sort of partial generation scheme. There's an easier way though.  Ractive.js will allow you to attach one independent instance to another using  attachChild , optionally specifying a  target . If you don't specify a target, then the child instance will not be rendered, but if you  do  specify a target, then the instance will be rendered into the first available matching  anchor . An anchor looks like a component or element, but its name always starts with a  # . You may have as many anchors as you like, and they may each have the same or different names.  #anchor /  #ICallThisOneStan \n  Stan has a content partial.\n  {{#partial name}}He also has a name partial.{{/partial}} /ICallThisOneStan   Go ahead and fill out the two provided views as you like, add anchors to the main instance template, and attach an instance of each view to an anchor on the main instance.   You can detach a child using the conveniently named  detachChild  method.  Child instances can be attached in  prepend ,  insertAt , or  append  (the default) mode. Ractive.js will try to find a matching anchor for each child starting with the first. If there aren't enough anchors, some instances will not be rendered. Each time a child is attached or detached, Ractive.js will adjust any affected anchors so all instances that can be rendered are rendered.  Each anchor has its own list of children associated with it, which is what the attachment modes are referreing to -  prepend  will insert a child at the front,  append  at the end, and  insertAt  at the specified index. The list of children for a particular anchor, say  #main / , is kept up to date in an observable way so that you can automatically generate anchors as components are attached using  {{#each @.children.byName.main}} #main / {{/each}} .  An anchored attached child is effectively a component that the host instance doesn't control.", 
            "title": "Step 6"
        }, 
        {
            "location": "/tutorials/animation/", 
            "text": "Animation\n\n\nAnimation can play an important role in communicating changing states of your webapp. In this tutorial we'll learn about using \nractive.animate()\n.\n\n\nStep 1\n\n\n\n  \nStart\n\n  \nFix Code\n\n\n\n\nHere, we've got a bar chart showing average temperatures throughout the year. We want there to be a smooth transition when the user changes the city using the dropdown menu.\n\n\nFind the code that changes the data in the bar chart when the user makes a selection from the dropdown. Change \nthis.set\n to \nthis.animate\n...\n\n\n...and that's it! We now have a smooth transition between cities \u2013 not just the bar height, but the labels and colours as well.\n\n\n\n\nRactive.js is efficient about how it handles animations. Even though there are a total of 72 properties being animated each time (height, colour and label text for two bars for each of twelve months), there is a single animation loop which uses \nrequestAnimationFrame\n where possible, and which runs as long as there are one or more sets of animations in progress.\n\n\nIf a second animation on a keypath were to start before the first had completed, the first would be cancelled.\n\n\n\n\nStep 2\n\n\n\n  \nStart\n\n  \nFix Code\n\n\n\n\nThat's good, but it looks a bit... robotic. That's because the animation is following a linear path. We can make the whole thing look much slicker with an \neasing function\n. Find the existing animation code and update it:\n\n\nthis.animate( 'selectedCity', cities[ index ], {\n  easing: 'easeOut'\n});\n\n\n\n\nExecute this code, then try changing the city via the drop-down.\n\n\n\n\nRactive.js has four easing functions built in \u2013 \nlinear\n (the default), \neaseIn\n, \neaseOut\n and \neaseInOut\n. I personally find \neaseOut\n and \neaseInOut\n meet 95% of my needs.\n\n\nHowever you can add more easing functions to \nRactive.easing\n, and they will become globally available. Here's an elastic easing function, for example:\n\n\nRactive.easing.elastic = function( pos ) {\n  return -1 * Math.pow(4,-8*pos) * Math.sin((pos*6-1)*(2*Math.PI)/2) + 1;\n};\n\n\n\nThis was taken from \ndanro's easing.js\n, which contains just about every easing function you could imagine. Or you could create your own \u2013 all it is is a function that takes an x value between 0 (animation start) and 1 (animation end) and returns a y value (usually between 0 and 1, but sometimes just outside as in the \nelastic\n example).\n\n\nAs an alternative to making easing functions globally available, you can pass a function in as the \neasing\n parameter rather than a string.\n\n\n\n\nStep 3\n\n\n\n  \nStart\n\n  \nFix Code\n\n\n\n\nAlongside \neasing\n, there are several other options you can pass in when creating an animation:\n\n\nthis.animate( 'selectedCity', cities[ index ], {\n  easing: 'easeOut',\n  duration: 300, // in milliseconds - default 400\n  step: function ( t, value ) {\n    // function that will be called immediately after\n    // each step of the animation loop.\n    //\n    // `t` is a value between 0 (start) and 1 (end),\n    // as determined by the easing function.\n    //\n    // `value` is the intermediate value\n  }\n}).then( function () {\n  // .animate() returns a promise that fulfils\n  // when the animation completes\n});\n\n\n\n\nTry using \nractive.animate()\n to cycle the bar chart through a loop \u2013 each city's data is displayed for a couple of seconds before transitioning to the next one. To make it simple, the \nselect\n has been removed. If you get stuck, use the 'Fix Code' button to see one possible solution.\n\n\n\n\nYou can animate between numerical properties, and arrays or objects that contain numerical properties (nested however deep \u2013 though be aware that Ractive.js doesn't check for cyclical data structures which will cause infinite loops!).\n\n\nStrings, such as the city's \nname\n in this example, are ignored, or rather set immediately on the first animation tick. (Future versions may include clever string interpolators \u00e0 la \nD3\n.)", 
            "title": "Animations"
        }, 
        {
            "location": "/tutorials/animation/#animation", 
            "text": "Animation can play an important role in communicating changing states of your webapp. In this tutorial we'll learn about using  ractive.animate() .", 
            "title": "Animation"
        }, 
        {
            "location": "/tutorials/animation/#step-1", 
            "text": "Start \n   Fix Code   Here, we've got a bar chart showing average temperatures throughout the year. We want there to be a smooth transition when the user changes the city using the dropdown menu.  Find the code that changes the data in the bar chart when the user makes a selection from the dropdown. Change  this.set  to  this.animate ...  ...and that's it! We now have a smooth transition between cities \u2013 not just the bar height, but the labels and colours as well.   Ractive.js is efficient about how it handles animations. Even though there are a total of 72 properties being animated each time (height, colour and label text for two bars for each of twelve months), there is a single animation loop which uses  requestAnimationFrame  where possible, and which runs as long as there are one or more sets of animations in progress.  If a second animation on a keypath were to start before the first had completed, the first would be cancelled.", 
            "title": "Step 1"
        }, 
        {
            "location": "/tutorials/animation/#step-2", 
            "text": "Start \n   Fix Code   That's good, but it looks a bit... robotic. That's because the animation is following a linear path. We can make the whole thing look much slicker with an  easing function . Find the existing animation code and update it:  this.animate( 'selectedCity', cities[ index ], {\n  easing: 'easeOut'\n});  Execute this code, then try changing the city via the drop-down.   Ractive.js has four easing functions built in \u2013  linear  (the default),  easeIn ,  easeOut  and  easeInOut . I personally find  easeOut  and  easeInOut  meet 95% of my needs.  However you can add more easing functions to  Ractive.easing , and they will become globally available. Here's an elastic easing function, for example:  Ractive.easing.elastic = function( pos ) {\n  return -1 * Math.pow(4,-8*pos) * Math.sin((pos*6-1)*(2*Math.PI)/2) + 1;\n};  This was taken from  danro's easing.js , which contains just about every easing function you could imagine. Or you could create your own \u2013 all it is is a function that takes an x value between 0 (animation start) and 1 (animation end) and returns a y value (usually between 0 and 1, but sometimes just outside as in the  elastic  example).  As an alternative to making easing functions globally available, you can pass a function in as the  easing  parameter rather than a string.", 
            "title": "Step 2"
        }, 
        {
            "location": "/tutorials/animation/#step-3", 
            "text": "Start \n   Fix Code   Alongside  easing , there are several other options you can pass in when creating an animation:  this.animate( 'selectedCity', cities[ index ], {\n  easing: 'easeOut',\n  duration: 300, // in milliseconds - default 400\n  step: function ( t, value ) {\n    // function that will be called immediately after\n    // each step of the animation loop.\n    //\n    // `t` is a value between 0 (start) and 1 (end),\n    // as determined by the easing function.\n    //\n    // `value` is the intermediate value\n  }\n}).then( function () {\n  // .animate() returns a promise that fulfils\n  // when the animation completes\n});  Try using  ractive.animate()  to cycle the bar chart through a loop \u2013 each city's data is displayed for a couple of seconds before transitioning to the next one. To make it simple, the  select  has been removed. If you get stuck, use the 'Fix Code' button to see one possible solution.   You can animate between numerical properties, and arrays or objects that contain numerical properties (nested however deep \u2013 though be aware that Ractive.js doesn't check for cyclical data structures which will cause infinite loops!).  Strings, such as the city's  name  in this example, are ignored, or rather set immediately on the first animation tick. (Future versions may include clever string interpolators \u00e0 la  D3 .)", 
            "title": "Step 3"
        }, 
        {
            "location": "/tutorials/svg/", 
            "text": "SVG\n\n\nRactive.js works with SVG just as easily as with HTML. This makes it possible to create data-driven graphics using the same declarative structure as we use with the rest of the web.\n\n\nStep 1\n\n\n\n    \nStart\n\n\n\n\nIn the template, we've got some hard-coded values. Let's replace them with mustaches:\n\n\n!-- the rectangle --\n\n\nrect width='{{width}}' height='{{height}}'/\n\n\n\n\n\nWe can use expressions to replace the other hard-coded values:\n\n\n!-- the area of the rectangle --\n\n\ntext class='area' x='{{ width / 2 }}' y='{{ height / 2 }}'\n\n  {{ Math.round( width * height ) }} px\u00b2\n\n/text\n\n\n\n\n\nNote that we're using \nMath.round()\n to make the end result cleaner.\n\n\nApply similar changes to the labels, then add some data:\n\n\nvar ractive = Ractive({\n  el: output,\n  template: template,\n  data: { width: 100, height: 100 }\n});\n\n\n\n\nExecute this code. Now we can have some fun:\n\n\nvar ractive.animate({ width: 300, height: 200 }, {\n  easing: 'easeOut',\n  duration: 800\n});\n\n\n\n\n\n\nSVG is a big topic; bigger than can be accommodated here. It's well worth learning how to use it though. Unfortunately, the web is littered with bad SVG tutorials, but once you get your head round the basics it all makes a lot of sense.\n\n\nSince you're a better (and more charismatic) developer than most, I predict you'll pick it up easily.\n\n\n\n\nStep 2\n\n\n\n    \nStart\n\n\n\n\nIn this example, we're using the same data as in the previous tutorial to draw a combination area range and line chart. It's more of a demo than a lesson.\n\n\nThere are some points worth noting here. Firstly, we're mixing HTML and SVG together in the same ractive - the two languages are treated as equals.\n\n\nSecondly, we haven't had to write a \nrender\n or \nupdate\n function \u2013 our intentions are expressed \ndeclaratively\n. There's some custom logic to create the shape of the temperature band polygon, for example, but we don't need to specify when that logic should be invoked \u2013 the system simply reacts to new data and internal changes in state. The temperature labels don't need an event handler to tell them when to switch from \u00b0C to \u00b0F.\n\n\nThirdly, because this is based on a template, it's much easier to understand and extend than we've come to expect data visualisations to be. Ordinarily, you'd have to maintain a complex mental model of the \nflow\n of your application in order to understand which bits of code affected the result in which ways \u2013 here, the link between code and result is much more obvious.\n\n\nStep 3\n\n\n\n    \nStart\n\n    \nFix Code\n\n\n\n\nSince SVG gets along with the regular DOM pretty well, you can also interact with stuff \ninside\n an SVG just like you would with HTML. Using our simple square example from above, add a click event handler to the rectangle that makes it toggle back and forth between 100px sides and 140px by 160px sides.\n\n\nrect on-click=\n@.animate('width', 140, { easing: 'easeOut' })\n /\n\n\n\n\n\nIf you like, you can add separate \nanimate\n calls for width and height with different easings. Then your square will rectangle in an elastic-y way.", 
            "title": "SVG"
        }, 
        {
            "location": "/tutorials/svg/#svg", 
            "text": "Ractive.js works with SVG just as easily as with HTML. This makes it possible to create data-driven graphics using the same declarative structure as we use with the rest of the web.", 
            "title": "SVG"
        }, 
        {
            "location": "/tutorials/svg/#step-1", 
            "text": "Start   In the template, we've got some hard-coded values. Let's replace them with mustaches:  !-- the rectangle --  rect width='{{width}}' height='{{height}}'/   We can use expressions to replace the other hard-coded values:  !-- the area of the rectangle --  text class='area' x='{{ width / 2 }}' y='{{ height / 2 }}' \n  {{ Math.round( width * height ) }} px\u00b2 /text   Note that we're using  Math.round()  to make the end result cleaner.  Apply similar changes to the labels, then add some data:  var ractive = Ractive({\n  el: output,\n  template: template,\n  data: { width: 100, height: 100 }\n});  Execute this code. Now we can have some fun:  var ractive.animate({ width: 300, height: 200 }, {\n  easing: 'easeOut',\n  duration: 800\n});   SVG is a big topic; bigger than can be accommodated here. It's well worth learning how to use it though. Unfortunately, the web is littered with bad SVG tutorials, but once you get your head round the basics it all makes a lot of sense.  Since you're a better (and more charismatic) developer than most, I predict you'll pick it up easily.", 
            "title": "Step 1"
        }, 
        {
            "location": "/tutorials/svg/#step-2", 
            "text": "Start   In this example, we're using the same data as in the previous tutorial to draw a combination area range and line chart. It's more of a demo than a lesson.  There are some points worth noting here. Firstly, we're mixing HTML and SVG together in the same ractive - the two languages are treated as equals.  Secondly, we haven't had to write a  render  or  update  function \u2013 our intentions are expressed  declaratively . There's some custom logic to create the shape of the temperature band polygon, for example, but we don't need to specify when that logic should be invoked \u2013 the system simply reacts to new data and internal changes in state. The temperature labels don't need an event handler to tell them when to switch from \u00b0C to \u00b0F.  Thirdly, because this is based on a template, it's much easier to understand and extend than we've come to expect data visualisations to be. Ordinarily, you'd have to maintain a complex mental model of the  flow  of your application in order to understand which bits of code affected the result in which ways \u2013 here, the link between code and result is much more obvious.", 
            "title": "Step 2"
        }, 
        {
            "location": "/tutorials/svg/#step-3", 
            "text": "Start \n     Fix Code   Since SVG gets along with the regular DOM pretty well, you can also interact with stuff  inside  an SVG just like you would with HTML. Using our simple square example from above, add a click event handler to the rectangle that makes it toggle back and forth between 100px sides and 140px by 160px sides.  rect on-click= @.animate('width', 140, { easing: 'easeOut' })  /   If you like, you can add separate  animate  calls for width and height with different easings. Then your square will rectangle in an elastic-y way.", 
            "title": "Step 3"
        }, 
        {
            "location": "/tutorials/transitions/", 
            "text": "Transitions\n\n\nNormally, when an element is rendered, it just sort of gets plonked on the page. With Ractive you have more control.\n\n\nStep 1\n\n\n\n    \nStart\n\n    \nFix Code\n\n\n\n\n\nYou can specify intro transitions:\n\n\ndiv fade-in\n\n  This div will fade into view\n\n/div\n\n\n\n\n\nTry adding intros to the three buttons in the template, choosing from \nfade\n, \nslide\n and \nfly\n, which have been included on this page.\n\n\n\n\nAs with custom events, transitions are distributed as plugins.\n\n\nWhere possible, Ractive uses CSS transitions, but in older browsers it will fall back to timer-based animation.\n\n\n\n\nStep 2\n\n\n\n    \nStart\n\n    \nFix Code\n\n\n\n\nSimilarly, we can specify outro transitions. When an element is no longer needed on the page, it will exit gracefully.\n\n\nTry adding outro transitions to the three buttons;\n\n\nbutton fade-in fly-out on-click='[\nshow\n, 2]'\n\n  Click me!\n\n/button\n\n\n\n\n\nExecute the code. Aaargh! It looks horrible!\n\n\nThat's because new elements are being rendered before the old ones get removed from the DOM. What we need to do is \nchain\n the transitions \u2013 trigger the removal, wait, and then trigger rendering of the new element.\n\n\nCalling \nractive.set()\n returns a \nPromise\n, which resolves on completion of any transitions that are caused by the change. So you can do this:\n\n\nractive.on({\n  show: function ( event, which ) {\n    ractive.set( 'visible', null ).then( function () {\n      ractive.set( 'visible', which );\n    });\n  }\n});\n\n\n\n\n\n\nSeveral methods return a promise, not just \nractive.set()\n \u2013 \nractive.update()\n, \nractive.teardown()\n, \nractive.render()\n, and all of the array methods such as \nractive.push()\n.\n\n\n\n\nStep 3\n\n\n\n    \nStart\n\n    \nFix Code\n\n\n\n\nYou can pass in parameters to add fine-grained control over transitions:\n\n\nbutton intro='fade:{duration:2000}'\n        outro='fly'\n        on-tap='show:2'\n\n  Click me!\n\n/button\n\n\n\n\n\nThe transition function will receive an argument corresponding to these parameters. In this case, the default \nduration\n property will be overridden, so the \nfade\n transition will take 2000 milliseconds (more popularly known as '2 seconds').\n\n\nBy convention, if you pass in a number, it will be treated as the duration property:\n\n\nbutton fade-in=\n2000\n\n        fly-out\n        on-click=\n['show', 2]\n\n  Click me!\n\n/button\n\n\n\n\n\nIn place of a number, you can use \nfast\n (200 milliseconds) or \nslow\n (600 milliseconds), just like jQuery.\n\n\nThe parameters available to you depend on the transition.", 
            "title": "Transitions"
        }, 
        {
            "location": "/tutorials/transitions/#transitions", 
            "text": "Normally, when an element is rendered, it just sort of gets plonked on the page. With Ractive you have more control.", 
            "title": "Transitions"
        }, 
        {
            "location": "/tutorials/transitions/#step-1", 
            "text": "Start \n     Fix Code   You can specify intro transitions:  div fade-in \n  This div will fade into view /div   Try adding intros to the three buttons in the template, choosing from  fade ,  slide  and  fly , which have been included on this page.   As with custom events, transitions are distributed as plugins.  Where possible, Ractive uses CSS transitions, but in older browsers it will fall back to timer-based animation.", 
            "title": "Step 1"
        }, 
        {
            "location": "/tutorials/transitions/#step-2", 
            "text": "Start \n     Fix Code   Similarly, we can specify outro transitions. When an element is no longer needed on the page, it will exit gracefully.  Try adding outro transitions to the three buttons;  button fade-in fly-out on-click='[ show , 2]' \n  Click me! /button   Execute the code. Aaargh! It looks horrible!  That's because new elements are being rendered before the old ones get removed from the DOM. What we need to do is  chain  the transitions \u2013 trigger the removal, wait, and then trigger rendering of the new element.  Calling  ractive.set()  returns a  Promise , which resolves on completion of any transitions that are caused by the change. So you can do this:  ractive.on({\n  show: function ( event, which ) {\n    ractive.set( 'visible', null ).then( function () {\n      ractive.set( 'visible', which );\n    });\n  }\n});   Several methods return a promise, not just  ractive.set()  \u2013  ractive.update() ,  ractive.teardown() ,  ractive.render() , and all of the array methods such as  ractive.push() .", 
            "title": "Step 2"
        }, 
        {
            "location": "/tutorials/transitions/#step-3", 
            "text": "Start \n     Fix Code   You can pass in parameters to add fine-grained control over transitions:  button intro='fade:{duration:2000}'\n        outro='fly'\n        on-tap='show:2' \n  Click me! /button   The transition function will receive an argument corresponding to these parameters. In this case, the default  duration  property will be overridden, so the  fade  transition will take 2000 milliseconds (more popularly known as '2 seconds').  By convention, if you pass in a number, it will be treated as the duration property:  button fade-in= 2000 \n        fly-out\n        on-click= ['show', 2] \n  Click me! /button   In place of a number, you can use  fast  (200 milliseconds) or  slow  (600 milliseconds), just like jQuery.  The parameters available to you depend on the transition.", 
            "title": "Step 3"
        }, 
        {
            "location": "/tutorials/decorators/", 
            "text": "Decorators\n\n\nIf you've worked through the tutorials in order to this point, you may have wondered if there's some sort of hook to let you modify an element as it's created. Well, wonder no more!\n\n\nDecorators are plugins, somewhat like custom events and transitions, that are attached to individual elements using a decorator directive. A decorator typically adds some sort of behavior to an element - makes it act like something - the decorator directive begins with \nas-\n and the decorator name.\n\n\nStep 1\n\n\n\n  \nStart\n\n  \nFix Code\n\n\n\n\nStarting with something simple, let's make a decorator that tracks certain nodes to which we want a direct reference. First, here's what a decorator looks like:\n\n\nfunction tracked ( node, ...args ) {\n  // do stuff with node\n  // `this` is the Ractive instance\n\n  // return a control handle\n  return {\n    // called when decorator args change\n    function update () {},\n\n    // undo stuff with node\n    function teardown () {}\n  }\n}\n\n\n\n\nThere's not a \nwhole lot\n going on there. When the decorator is called, it can do whatever it needs to with the node and return a control handle that lets Ractive tell it when arguments change or tear it down when the node is being unrendered. All we need to do is take an \nid\n argument, create a \nnodes\n hash on the Ractive instance if there's not already once there, and store the \nnode\n at the given \nid\n. Fill in the missing code and then add decorator directive to the second \ndiv\n.\n\n\ndiv as-tracked=\n'special-div'\nI am the special div.\n/div\n\n\n\n\n\nThen throw a manual style setting at the end of the script just to show everything worked:\n\n\nractive.node['special-div'].style.color = 'blue';\n\n\n\n\nWhile that example is a bit contrived, you can probably see the benefit of using decorators when integrating with third party libraries that focus on adding functionality to a single node, like CodeMirror and Ace editor - in fact, the editors in the playground are handled by an Ace editor decorator.\n\n\nStep 2\n\n\n// TODO: formatting decorator", 
            "title": "Decorators"
        }, 
        {
            "location": "/tutorials/decorators/#decorators", 
            "text": "If you've worked through the tutorials in order to this point, you may have wondered if there's some sort of hook to let you modify an element as it's created. Well, wonder no more!  Decorators are plugins, somewhat like custom events and transitions, that are attached to individual elements using a decorator directive. A decorator typically adds some sort of behavior to an element - makes it act like something - the decorator directive begins with  as-  and the decorator name.", 
            "title": "Decorators"
        }, 
        {
            "location": "/tutorials/decorators/#step-1", 
            "text": "Start \n   Fix Code   Starting with something simple, let's make a decorator that tracks certain nodes to which we want a direct reference. First, here's what a decorator looks like:  function tracked ( node, ...args ) {\n  // do stuff with node\n  // `this` is the Ractive instance\n\n  // return a control handle\n  return {\n    // called when decorator args change\n    function update () {},\n\n    // undo stuff with node\n    function teardown () {}\n  }\n}  There's not a  whole lot  going on there. When the decorator is called, it can do whatever it needs to with the node and return a control handle that lets Ractive tell it when arguments change or tear it down when the node is being unrendered. All we need to do is take an  id  argument, create a  nodes  hash on the Ractive instance if there's not already once there, and store the  node  at the given  id . Fill in the missing code and then add decorator directive to the second  div .  div as-tracked= 'special-div' I am the special div. /div   Then throw a manual style setting at the end of the script just to show everything worked:  ractive.node['special-div'].style.color = 'blue';  While that example is a bit contrived, you can probably see the benefit of using decorators when integrating with third party libraries that focus on adding functionality to a single node, like CodeMirror and Ace editor - in fact, the editors in the playground are handled by an Ace editor decorator.", 
            "title": "Step 1"
        }, 
        {
            "location": "/tutorials/decorators/#step-2", 
            "text": "// TODO: formatting decorator", 
            "title": "Step 2"
        }, 
        {
            "location": "/api/", 
            "text": "API\n\n\nThis page contains \nall\n of the main API available in Ractive, including that provided by templates. This can be a little bit overwhelming, but it's also very searchable. If you're new to Ractive and not exactly sure what you're looking for, we recommend starting with \nthe tutorial\n to get the basics and circling back here later. Here's a basic breakdown of the sections and what you can find in them:\n\n\n\n\n\n\nMustaches\n\n\nThis section describes the main template constructs that are used in Ractive. Plain mustaches \n{{like_this}}\n are used to inject values into the DOM. \n{{#if conditionals}}\n are used to conditionally add or remove content. \n{{#each iterations}}\n are used to display content for every element in a list or object. \n{{#with contexts}}\n are used to scope data for a section of template.\n\n\n\n\n\n\nData Binding, Directives, Special References\n\n\nThese sections make up the remainder of the template constructs that are used in Ractive. Directives control things like how an element transitions in an out of the DOM, what event listeners are installed on an element, and how two-way bindings are handled. Data Binding describes the different form element bindings available and the special directives that are used to apply them. Special References describes all of the template context-based magic variables that are automatically supplied to your template by Ractive.\n\n\n\n\n\n\nInitialization Options\n\n\nThese are the options you can pass into a Ractive constructor to control how the instance behaves. Some of them can also be passed to \nextend\n and \nextendWith\n to control how a Ractive component behaves. This is where you'll find how to specify your template, data, event listeners, and observers that define your app, as well as options to control other behavior.\n\n\n\n\n\n\nStatic Properties\n\n\nThese are properties available either solely on the \nRactive\n constructor singleton or on component constructors that have been created by \nextend\n or augmented by \nextendWith\n. Global plugin registries and prototypes are found here. \n\n\n\n\n\n\nStatic Methods\n\n\nThis is a collection of helper functions that do things like parse a template, provide instance-free access to cross-instance state, create or augment Ractive components, and perform utility functions, like escaping keypaths.\n\n\n\n\n\n\nInstance Properties\n\n\nThese are mostly instance-local plugin registries, but they also include things like references to parent and root instances for components.\n\n\n\n\n\n\nInstance Methods\n\n\nAlong with the template and a few init options, these make up your primary interface with Ractive. You can interact with data (\nget\n, \nset\n, \ntoggle\n, array methods), invalidate data (\nupdate\n), find child DOM nodes and components (\nfind\n, \nfindComponent\n, etc), handle event subscriptions (\non\n, \noff\n, etc), manage rendering (\nrender\n, \ninsert\n, \ndetach\n, \nunrender\n), and get a handle to a Context based on a selector or a DOM node (\ngetContext\n).\n\n\n\n\n\n\nContext Object\n\n\nContext objects are a handle to a specific point in a template, usually based on a DOM node. They bridge the gap between the template and the DOM, so that you can interact with the template directly. Context objects contain analogs to all of the instance methods available on a Ractive instance, but these methods are scoped to the context with which they are associated. This allows you to do things like set relative paths, check to see if an element has an event directive, and interact with any bindings. Context objects are automatically provided as the first argument to any event listener. They can also be acquired from a template using the \n@context\n special reference and from the API using \ngetContext\n.\n\n\n\n\n\n\nMustaches\n\n\nVariables\n\n\n{{ }}\n, \n{{\n }}\n and \n{{{ }}}\n render a reference. They are also used for binding when used on directives. \n{{ }}\n escapes the reference while \n{{\n }}\n and \n{{{ }}}\n do not.\n\n\nRactive({\n  data: {\n    name: \nChris\n,\n    company: \nb\nGitHub\n/b\n\n  },\n  template: `\n    {{name}}      \n!-- Chris --\n\n    {{age}}       \n!--  --\n\n    {{company}}   \n!-- \nlt;b\ngt;GitHub\nlt;/b\ngt; --\n\n    {{\ncompany}}  \n!-- \nb\nGitHub\n/b\n --\n\n    {{{company}}} \n!-- \nb\nGitHub\n/b\n --\n\n  `\n})\n\n\n\n\nSections\n\n\nSections render a block of markup depending on the value referenced.\n\n\nIf the reference is an array, it renders the block of markup for each item in the array. The context of the section is the value of the currently iterated item. The iteration index is made available by adding a \n:\n after the array reference followed by the index reference.\n\n\nRactive({\n  data: {\n    people: [{name: 'Alice'},{name: 'Bob'},{name: 'Eve'}]\n  },\n  template: `\n    {{#people}} {{name}} {{/people}}\n    {{#people:i}} {{i}} {{name}} {{/people}}\n  `\n})\n\n\n\n\nIf the reference is an object \nand the key reference is provided\n, the section iterates through the object properties. The context of the section is the value of the currently iterated property. The iteration key is made available by adding a \n:\n after the object reference followed by the key reference.\n\n\nRactive({\n  data: {\n    places: { loc1: 'server room', loc2: 'networking lab', loc3: 'pantry'}\n  },\n  template: `\n    {{#places:key}}\n      {{ key }} {{ this }}\n    {{/places}}\n  `\n})\n\n\n\n\nIf the reference is some other truthy value or an object but not providing the iteration key reference, it renders the block of markup using the reference as context.\n\n\nRactive({\n  data: {\n    isAdmin: true,\n    foo: {\n      bar: {\n        baz: {\n          qux: 'Hello, World!'\n        }\n      }\n    }\n  },\n  template: `\n    {{#isAdmin}} Hello Admin! {{/isAdmin}}\n\n    {{#foo.bar.baz}} {{qux}} {{/foo.bar.baz}}\n  `\n})\n\n\n\n\nInverted Sections\n\n\n{{^ }}\n renders a block of markup if the reference is falsy or is an empty iterable.\n\n\nRactive({\n  data: {\n    real: false,\n    people: []\n  },\n  template: `\n    {{^real}} Nope, not real {{/real}}\n\n    {{^people}} There's no people {{/people}}\n  `\n})\n\n\n\n\nOptional section closing text\n\n\nRegular (\n{{# }}\n) and inverted (\n{{^ }}\n) sections can be closed with optional closing text. If the closing text is provided and the section is opened with a reference, the closing text must match the opening text. Otherwise, a warning will be issued for the mismatch. If the section is opened with an expression, the closing text will always be ignored.\n\n\nRactive({\n  data: {\n    items: [1,2,3]\n  },\n  template: `\n    {{#items}}\n      {{this}}\n    {{/items}}\n\n    {{#items}}\n      {{this}}\n    {{/}}\n\n    {{# a.concat(b) }}\n      {{this}}\n    {{/ I'm actually ignored but should be something meaningful like a.concat(b) }}\n  `\n})\n\n\n\n\nIf sections\n\n\n{{#if }}\n renders a block of markup if the reference is truthy or a non-empty iterable. \n{{else}}\n and \n{{elseif}}\n are supported and render if the previous condition failed.\n\n\nRactive({\n  data: {\n    foo: false,\n    bar: false\n  },\n  template: `\n    {{#if foo}}\n      foo\n    {{elseif bar}}\n      bar\n    {{else}}\n      baz\n    {{/if}}\n  `\n})\n\n\n\n\nUnless sections\n\n\n{{#unless }}\n renders a block of markup if the reference is falsy or is an empty iterable. Unlike \n{{#if }}\n, the \n{{#unless }}\n section does not support \n{{else}}\n nor \n{{elseif}}\n.\n\n\nRactive({\n  data: {\n    real: false,\n  },\n  template: `\n    {{#unless real}} Fake {{/unless}}\n  `\n})\n\n\n\n\nEach sections\n\n\n{{#each }}\n renders the block of markup for each item in the iterable. The context of the section is the value of the currently iterated item. \n{{else}}\n and \n{{elseif}}\n are supported and render if the iterable is empty. The iterable may be an array or an object, and if it is an object, the keys will be iterated with the context of each iteration being the value at the key associated with it.\n\n\nRactive({\n  data: {\n    people: [{name: 'Alice'},{name: 'Bob'},{name: 'Eve'}]\n  },\n  template: `\n    {{#each people}}\n      Hi! I'm {{.name}}!\n    {{else}}\n      There's nobody here\n    {{/each}}\n  `\n})\n\n\n\n\nIf you want to refer to the item in an iteration by name, you can optionally supply an alias for it.\n\n\n{{#each people as person}}Hi! I'm {{person.name}}!{{/each}}\n\n\n\n\nIf you would also like to refer to the current index or key for an iteration by something other than the special refs \n@key\n and \n@index\n, you can also provide an alias for each of those. When aliasing key and index, only the first key alias is required, and it will always be the same as the index alias for an array because the key and index are the same thing. For an object iteration, the index alias will be the 0-based index of the key in the keys of the object being iterated.\n\n\n{{#each people: index, key}}index and key are the same for an array{{/each}}\n\n!-- this works with a context alias as well --\n\n{{#each people as person: index, key}}...{{/each}}\n\n!-- the second alias is not required --\n\n{{#each people: i}}...{{/each}}\n\n!-- and it's only really useful when iterating an object --\n\n{{#each someObject: k, i}}k is the current key and i is the current index{{/each}}\n\n\n\n\n@index\n and \n@key\n aliases are useful for nested \n{{#each}}\n blocks so that you have a way to refer to the outer key or index in any given iteration. It's also sometimes useful to give a more meaningful name to a key or index.\n\n\nFrom 0.10.0\n\n\nIn addition to a context alias, you can also include aliases for \n@keypath\n, \n@rootpath\n, \n@index\n, and \n@key\n instead of using the \n: k, i\n syntax. This tends to be slightly less confusing than trying to remember whether the first or second name is the key.\n\n\n{{#each people as person, i as @index, path as @keypath}}...{{/each}}\n\n!-- the context alias is not required --\n\n{{#each people, i as @index, path as @keypath}}...{{/each}}\n\n\n\n\nThere are also special aliases that can control the behavior of the \n{{#each}}\n block in special circumstances.\n\n\nFirst, it's not possible to have a computed array shuffle (a keyed update, which moves iterated elements around the DOM to match new array positions rather than simply updating contents in place) because there's no way to tell the computation when an index is moved. With a plain old model, an \n{{#each}}\n block will automatically know how to shuffle itself if you use an array method like \nsplice\n or a \nset\n with the \nshuffle\n option set. By setting the \nshuffle\n alias to either \ntrue\n or a keypath string to use to return an identity for each iteration, you can tell an \n{{#each}}\n with a computed array how to shuffle itself when the array changes. \ntrue\n will cause the identity of each element to be used to determine its new index, and a keypath will cause the identity of the value at that keypath from each element to determine its new index.\n\n\n{{#each people, true as shuffle}}...{{/each}}\n{{#each people, 'profile.id' as shuffle}}...each person's profile id determines where they are in the list...{{/each}}\n\n\n\n\nSecond, computed contexts make two-way binding problematic, as updates don't propagate back to the source model automatically, or expensive, as using \nsyncComputedChildren\n will invalidate everything involved with the computation any time the computed context is changed. The \nsource\n alias of an \n{{#each}}\n block with a computed array can be set to have it map each of its iterations' contexts back to the plain model that is the basis of the computed array.\n\n\n{{#each filter(people, { name: 'joe' }), people as source}}\n  {{@keypath}} will be something like `people.0` rather than a computed\n  keypath based on `filter(people, { name: 'joe' }).0`\n{{/each}}\n\n\n\n\nThe \nas\n in aliases is also optional, so \n{{#each people person, @index i}}\n is equivalent to \n{{#each people as person, @index as i}}\n.\n\n\nWith sections\n\n\n{{#with }}\n alters the current section's context by sticking a reference in front of the resolution order. This causes everything within the section to resolve to that reference's context and data hierarchy first before the original section's.\n\n\nRactive({\n  el: 'body',\n  append: true,\n  data: {\n    foo: {\n      qux: 2,\n      bar: {\n        baz: 1\n      }\n    },\n    fee: {\n      baz: 'a'\n    }\n  },\n  template: `\n    \n!-- context becomes foo --\n\n    {{#foo}}\n\n      \n!-- context becomes foo.bar --\n\n      {{#bar}}\n\n        \n!-- resolution order: [foo.bar.baz], foo.baz, baz --\n\n        {{baz}}\n\n        \n!-- resolution order: foo.bar.qux, [foo.qux], baz --\n\n        {{qux}}\n\n        \n!-- sticks fee in front of foo.bar on the resolution order --\n\n        {{#with ~/fee}}\n\n          \n!-- resolution order: [fee.baz], foo.bar.baz, foo.baz, baz --\n\n          {{baz}}\n\n          \n!-- resolution order: fee.qux, foo.bar.qux, [foo.qux], qux --\n\n          {{qux}}\n        {{/with}}\n\n      {{/}}\n    {{/}}\n  `\n})\n\n\n\n\n{{else}}\n and \n{{elseif}}\n are supported and render when the context reference does not exist.\n\n\nRactive({\n  data: {},\n  template: `\n    {{#with people}}\n      {{joe}}\n    {{/else}}\n      Context missing\n    {{/with}}\n  `\n})\n\n\n\n\n{{#with }}\n also allows aliasing of references, including special references. Aliasing is in the form of \nreference as alias\n pairs. Multiple alias pairs can be done by separating each with a comma. In this mode, the context within the block is not altered.\n\n\nRactive({\n  el: 'body',\n  append: true,\n  data: {\n    foo: 1,\n    bar: {\n      foo: 2,\n      baz: 3\n    }\n  },\n  template: `\n    {{foo}} \n!-- 1 --\n\n\n    {{#with foo as qux, @global as world}}\n      {{#bar}}\n        {{qux}} \n!-- 1 --\n\n        {{foo}} \n!-- 2 --\n\n        {{baz}} \n!-- 3 --\n\n      {{/}}\n    {{/with}}\n  `\n})\n\n\n\n\nFrom 0.10.0\n\n\nThe \nas\n in aliases is also optional, so \n{{#with foo qux, @global world}}\n is equivalent to \n{{#with foo as qux, @global as world}}\n.\n\n\nAwait sections\n\n\nFrom 0.10.0\n\n\n{{#await}}\n sections take a value, preferrably a \nPromise\n, and allow you to render a pending template, while waiting, a success template if resolution completes, an error template if resolution fails, and an alternate template if the value is \nundefined\n.\n\n\n{{#await value}}\n  This bit of template displays while value is unresolved.\n{{then val}}\n  This bit of template displays when value is resolved, and the resolved value is available as val.\n{{catch err}}\n  This bit of template displays if the resolution results in an error, and the error is available as err.\n{{else}}\n  This bit of template displays if the value === undefined.\n{{/await}}\n\n\n\n\nAll of the aliases (\nval\n and \nerr\n in the example) are optional, as are each of the sections. There's also a shorthand if you don't want to use a pending template:\n\n\n{{#await value then val}}{{val}} has resolved{{/await}}\n\n\n\n\nIn-template partials\n\n\n{{#partial }}\n defines a partial that is scoped to the nearest enclosing element or the containing component if defined at the top level of the template.\n\n\nRactive({\n  data: {\n    people: [{name: 'Alice'},{name: 'Bob'},{name: 'Eve'}],\n    places: [{name: 'server room'},{name: 'networking lab'},{name: 'pantry'}]\n  },\n  template: `\n    {{#partial item}}\n      \nli class=\nitem\n{{this}}!\n/li\n\n    {{/partial}}\n\n    \nul\n\n      {{#each people}}\n        {{\n item }}\n      {{/each}}\n    \n/ul\n\n\n    \nul\n\n      {{#each places}}\n        {{\n item }}\n      {{/each}}\n    \n/ul\n\n\n    \ndiv\n\n      {{#partial scopedPartial}}\n        \nli class=\nitem\n{{this}}!\n/li\n\n      {{/partial}}\n\n      \nul\n\n        {{#each things}}\n          {{\n scopedPartial }}\n        {{/each}}\n      \n/ul\n\n    \n/div\n\n  `\n})\n\n\n\n\nStatic mustaches\n\n\n[[ ]]\n, \n[[\n ]]\n and \n[[[ ]]]\n render the reference only during the initial render. After the initial render, any changes to the referece will not update the UI, nor does any change on bound UI elements cause the reference to change. They are the one-time render counterparts of \n{{ }}\n, \n{{\n }}\n and \n{{{ }}}\n, respectively.\n\n\nconst instance = Ractive({\n  data: {\n    msg: 'Hello, World!',\n    admin: false\n  },\n  template: `\n    Will change when updated: {{ msg }}     \n!-- changes to \nMe, Hungry!\n after the change --\n\n    Will not change when updated: [[ msg ]] \n!-- remains \nHello, World!\n after the change --\n\n\n    [[# if admin ]]\n      Hello, admin\n    [[else]]\n      Hello, normal user\n    [[/if]]\n  `\n})\n\ninstance.set({ msg: 'Me, Hungry!' })\ninstance.set('admin', true) // rendering remains 'Hello, normal user'\n\n\n\n\nExpressions\n\n\nExpressions in mustaches are evaluated, and its result is used as the referenced value. Any changes to the expression's dependencies will re-evaluate the expression and update the rendered value. References to variables are taken from the current context and follow the regular reference resolution routine.\n\n\nRactive({\n  data: {\n    num1: 2,\n    num2: 3,\n    a: [1,2,3],\n    b: [4,5,6],\n    fn: () =\n true\n  },\n  template: `\n    {{ num1 + num2 }}\n\n    {{# a.concat(b) }} {{this}} {{/}}\n    {{#each a.concat(b) }} {{this}} {{/each}}\n\n    {{# fn() }} Yasss!!! {{/}}\n    {{#if fn() }} Yasss!!! {{/if}}\n  `\n})\n\n\n\n\nAlmost any valid JavaScript expression can be used, with a few exceptions:\n\n\n\n\nNo assignment operators (i.e. \na = b\n, \na += 1\n, \na--\n and so on).\n\n\nNo \nnew\n, \ndelete\n, or \nvoid\n operators.\n\n\nNo function literals (i.e. anything that involves the \nfunction\n keyword).\n\n\n\n\nExpressions support only a subset of globals:\n\n\n\n\nArray\n\n\nDate\n\n\nJSON\n\n\nMath\n\n\nNaN\n\n\nRegExp\n\n\ndecodeURI\n\n\ndecodeURIComponent\n\n\nencodeURI\n\n\nencodeURIComponent\n\n\nisFinite\n\n\nisNaN\n\n\nnull\n\n\nparseFloat\n\n\nparseInt\n\n\nundefined\n\n\nconsole\n\n\n\n\nComments\n\n\n{{! }}\n defines a template comment. Comments are ignored by the parser and never make it to the AST.\n\n\nRactive({\n  template: `\n    \nh1\nToday{{! ignore me }}.\n/h1\n\n  `\n})\n\n\n\n\nNote:\n \n{{!foo}}\n is also a valid expression, and expressions have a higher precedence in the parser than comments. To ensure that your comments are always treated as such, you can add a \n#\n after the \n!\n e.g. \n{{!# comment }}\n because \n#\n is never valid in an expression.\n\n\nCustom delimiters\n\n\n{{= =}}\n defines custom delimiters. Custom delimiters should not contain whitespace or the equals sign.\n\n\nRactive({\n  data: {\n    msg: 'Hello, World!'\n  },\n  template: `\n    {{ msg }}\n\n    {{=\n% %\n=}}\n    \n% msg %\n\n  `\n})\n\n\n\n\nEscaping mustaches\n\n\n\\\n prepended on a mustache interprets the mustache as literal text.\n\n\n{{ ref }} \\{{ ref }} \n!-- value {{ ref }} --\n\n\n\n\n\nFor multi-mustache structures, \n\\\n must be prepended on all involved mustaches.\n\n\n\\{{#if foo }} \\{{ bar }} \\{{/if}} \n!-- {{#if foo }} {{ bar }} {{/if}} --\n\n\n\n\n\nTo interpret a \n\\\n as a literal slash before a mustache, simply prepend another \n\\\n. Any further \n\\\n prepended will be treated in this manner.\n\n\nRactive({\n  data: {\n    msg: 'Hello, World!'\n  },\n  template: `\n    \\\\{{ msg }}   \n!-- \\Hello, World! --\n\n    \\\\\\{{ msg }}  \n!-- \\\\Hello, World! --\n\n    \\\\\\\\{{ msg }} \n!-- \\\\\\Hello, World! --\n\n  `\n})\n\n\n\n\nAnchors\n\n\n# /\n define anchors which are mounting points where instances can be mounted to dynamically during runtime.\n\n\nExamples\n\n\nExample 1\n\n\n\n\n\nconst MyComponent = Ractive.extend({\n  template: `\n    \ndiv\n{{ message }}\n/div\n\n  `\n})\n\nRactive({\n  target: 'body',\n  data: {\n    msg: 'Hello, World!'\n  },\n  template: `\n    \n# mountpoint7 /\n\n  `,\n  oninit () {\n    // Create new instance\n    const myComponent = MyComponent()\n\n    // Link msg of parent to message of instance\n    myComponent.link('msg', 'message', { ractive: this })\n\n    // It's mount'in time!\n    this.attachChild(myComponent, { target: 'mountpoint7'})\n  }\n})\n\n\n\n\nExample 2\n: Attaching, detaching, firing events, creating two-way bindings within the template\n\n\n\n\n\nMyComponent = Ractive.extend({\n    template: ...\n})\n\nRactive({\n    ...\n    template: `\n        \nbutton on-click=\nmove\nmove it\n/button\n\n        \n# mountpoint-one on-click=\nhello\n message=\n{{msg}}\n /\n\n        \n# mountpoint-two on-click=\nhello\n message=\n{{ msg + ' + ' + msg }}\n /\n\n        \ninput value=\n{{msg}}\n /\n\n    `,\n    onrender () {\n        // Create new instance\n        myInstance = MyComponent()\n        this.attachChild(myInstance, { target: 'mountpoint-one'})\n        this.on({\n            move () {\n                this.detachChild(myInstance)\n                this.attachChild(myInstance, { target: 'mountpoint-two'})\n            },\n            hello(ctx) {\n                // fire an event as you would do with a regular component\n            }\n        })\n    }\n})\n\n\n\n\n{{\ncontent}}\n\n\n{{\ncontent}}\n renders the inner HTML in the context of the component. Partials, components, and any other valid template items can be used as inner HTML.\n\n\nRactive.components.ChildComponent = Ractive.extend({\n  template: `\n    \ndiv class=\nchild-component\n{{\ncontent}}\n/div\n\n  `\n})\n\nconst ractive = Ractive({\n  el: 'body',\n  data: {\n    message: 'Hello World!'\n  },\n  template: `\n    \ndiv class=\nractive\n\n      \nChildComponent message=\nLorem Ipsum\n\n        \n!-- Prints \nLorem Ipsum\n --\n\n        \ndiv class=\ninner-content\n{{ message }}\n/div\n\n      \n/ChildComponent\n\n    \n/div\n\n  `\n})\n\n\n\n\nPartials defined in the inner HTML can be used to override partials defined on the component.\n\n\nRactive.components.ChildComponent = Ractive.extend({\n  partials: {\n    messageWrapper: '\nstrong\n{{message}}\n/strong\n'\n  },\n  template: `\n    \ndiv class=\nchild-component\n{{\ncontent}}\n/div\n\n  `\n})\n\nconst ractive = Ractive({\n  el: 'body',\n  data: {\n    message: 'Hello World!'\n  },\n  template: `\n    \ndiv class=\nractive\n\n      \nChildComponent message=\nLorem Ipsum\n\n\n        \n!-- Override component's messageWrapper --\n\n        {{#partial messageWrapper}}\nem\n{{message}}\n/em\n{{/}}\n\n        \ndiv class=\ninner-content\n\n          \n!-- Renders emphasized instead of strong --\n\n          {{\n messageWrapper }}\n        \n/div\n\n\n      \n/ChildComponent\n\n    \n/div\n\n  `\n})\n\n\n\n\n{{yield}}\n\n\n{{yield}}\n renders the inner HTML in the context of the parent component. Partials, components, and any other valid template items can be used as inner HTML.\n\n\nRactive.components.ChildComponent = Ractive.extend({\n  template: `\n    \ndiv class=\nchild-component\n{{ yield }}\n/div\n\n  `\n})\n\nconst ractive = Ractive({\n  el: 'body',\n  data: {\n    message: 'Hello, World!'\n  },\n  template: `\n    \ndiv class=\nractive\n\n      \nChildComponent message=\nLorem Ipsum\n\n        \n!-- Prints \nHello, World!\n --\n\n        \ndiv class=\ninner-content\n{{ message }}\n/div\n\n      \n/ChildComponent\n\n    \n/div\n\n  `\n})\n\n\n\n\nYields can also be customized using named yields. A named yield will look for a partial of the same name in the inner HTML and render that partial instead.\n\n\nRactive.components.ChildComponent = Ractive.extend({\n  template: `\n    \ndiv class=\nchild-component\n\n      {{ yield }}\n      {{ yield italicYield }}\n      {{ yield boldYield }}\n    \n/div\n\n  `\n})\n\nconst ractive = Ractive({\n  el: 'body',\n  data: {\n    message: 'Hello World!'\n  },\n  template: `\n    \ndiv class=\nractive\n\n      \nChildComponent message=\nLorem Ipsum\n\n\n        \n!-- Printed by {{ yield italicYield }} --\n\n        {{#partial italicYield }}\nem\n{{message}}\n/em\n{{/}}\n\n        \n!-- Printed by {{ yield boldYield }} --\n\n        {{#partial boldYield }}\nstrong\n{{message}}\n/strong\n{{/}}\n\n        \n!-- Anything not a partial is printed by {{ yield }} --\n\n        {{message}}\n      \n/ChildComponent\n\n    \n/div\n\n  `\n})\n\n\n\n\nSince the yielded content exists entirely in the context of the container (as opposed to the component), there's no way for the yielded content to access data in the component that is yielding. To address that, yields may supply aliases that are made available to the yielded content:\n\n\nconst list = Ractive.extend({\n  template: `\n    \nul\n\n      {{#each items}}\n        \n!-- Expose item and index to yield context. --\n\n        \nli\n{{yield with . as item, @index as index}}\n/li\n\n      {{/each}}\n    \n/ul\n\n  `\n})\n\nconst ractive = Ractive({\n  el: 'body',\n  data: {\n    some: {\n      list: [ 1, 2, 3 ]\n    }\n  },\n  select(i) { console.log('you picked', i); },\n  template: `\n    \n!-- Pass in some.list as items into list. --\n\n    \nlist items=\n{{some.list}}\n\n\n      \n!-- Access item and index aliases. --\n\n      \na href=\n#\n on-click=\n@.select(item)\nItem {{index}}\n/a\n\n    \n/list\n\n  `,\n  components: { list }\n})\n\n\n\n\nWithout the given alises, iterating a list within the component to yield the content would be useless, because the content would not have access to the current iteration. You could get around that by using a normal partial rather than a yield, but at that point, the click event on the content would result in an error because the \nselect\n method does not exist on the \nlist\n component.\n\n\nYield aliases are also available for named yields.\n\n\nconst Pager = Ractive.extend({\n  template: `\n    \nul\n\n      \nli\n{{ yield prev }}\n/li\n\n      {{#each pages}}\n        \nli\n{{yield link with . as page}}\n/li\n\n      {{/each}}\n      \nli\n{{ yield next }}\n/li\n\n    \n/ul\n\n  `\n})\n\nconst ractive = Ractive({\n  components: { Pager },\n  el: 'body',\n  data: {\n    book: {\n      pages: [ 1, 2, 3 ]\n    }\n  },\n  template: `\n    \nPager pages=\n{{ book.pages }}\n\n      {{#partial prev}}\na href=\n#prev\nPrev\n/a\n{{/partial}}\n      {{#partial link}}\na href=\n#{{ page }}\n{{ page }}\n/a\n{{/partial}}\n      {{#partial next}}\na href=\n#next\nNext\n/a\n{{/partial}}\n    \n/Pager\n\n  `,\n})\n\n\n\n\nFrom 0.10.0\n\n\nYou can also inject a context into a yield rather than aliases, in the same way that you can supply a context to a partial. When injecting a context, the container context will be accessible from the yielded template via the context parent prefix (\n^^/\n). The component context for the yield will still be the container.\n\n\nconst Loopy = Ractive.extend({\n  template: `\nul\n{{#each list}}\nli\n{{yield with .}}\n/li\n{{/each}}\n/ul\n`\n});\n\nconst ractive = new Ractive({\n  components: { Loopy },\n  target: 'body',\n  data: {\n    things: [ 1, 2, 3 ],\n    clicks: 0,\n    label: ' thing'\n  },\n  template: `{{clicks}}\nLoopy list=\n{{things}}\nbutton on-click=\n@.add('clicks')\n{{.}}{{^^/label}}\n/button\n/Loopy\n`\n});\n\n\n\n\nData binding\n\n\nText inputs\n\n\nData can be bound to text inputs via the \nvalue\n directive. This includes text-like inputs such as password, email, color, tel, date, etc.\n\n\nRactive({\n  template: `\n    \ninput type=\ntext\n value=\n{{ msg }}\n\n  `,\n  data: {\n    msg: 'Hello, World!'\n  }\n})\n\n\n\n\nNumber inputs\n\n\nNumeric data can be bound to number inputs via the \nvalue\n directive. This includes number-like inputs such as range. The value from the input will automatically be converted into a number. When the input is blank, the value returned is \nundefined\n.\n\n\nRactive({\n  template: `\n    \ninput type=\nnumber\n value=\n{{ daysWithoutSleep }}\n\n  `,\n  data: {\n    daysWithoutSleep: 2\n  }\n})\n\n\n\n\nFile inputs\n\n\nFile data can be bound to file inputs via the \nvalue\n directive. The value from the input is an instance of \nFileList\n.\n\n\nRactive({\n  template: `\n    \ninput type=\nfile\n value=\n{{ file }}\n\n  `,\n  data: {\n    file: /* FileList instance */\n  }\n})\n\n\n\n\nor by using events:\n\n\n\n\n\nRactive({\n  ...\n  template: `\n    {{#each foo}}\n    \np\n\n      {{.}} : \ninput on-change=\nhello\n type=\nfile\n /\n\n    \n/p\n\n    {{/each}}\n  `,\n  on:{\n    hello (ctx) {\n      files = ctx.node.files\n      keypath = ctx.resolve()\n      console.log('selected files:', files)\n      console.log('first file:', files[0])\n      console.log('current context: ', keypath)\n    }\n  },\n  data:{\n    foo: [1, 2, 3]\n  }\n})\n\n\n\n\nCheckboxes\n\n\nBoolean data can be bound to checkboxes via the \nchecked\n directive.\n\n\nRactive({\n  template: `\n    \ninput type=\ncheckbox\n checked=\n{{ isChecked }}\n\n  `,\n  data: {\n    isChecked: true\n  }\n})\n\n\n\n\nArray data can also be bound to checkboxes via the \nname\n directive.\n\n\nRactive({\n  template: `\n    \ninput type=\ncheckbox\n name=\n{{ selectedItems }}\n value=\n1\n\n    \ninput type=\ncheckbox\n name=\n{{ selectedItems }}\n value=\n2\n\n    \ninput type=\ncheckbox\n name=\n{{ selectedItems }}\n value=\n3\n\n  `,\n  data: {\n    selectedItems: ['1', '2']\n  }\n})\n\n\n\n\nWhen both \nchecked\n and \nname\n bindings are present, the binding to \nchecked\n will be honored and the binding to \nname\n will be treated as a regular interpolation.\n\n\nRadio buttons\n\n\nBoolean data can be bound to radio buttons via the \nchecked\n directive.\n\n\nRactive({\n  template: `\n    \ninput type=\nradio\n name=\noptions\n checked=\n{{ option1 }}\n\n    \ninput type=\nradio\n name=\noptions\n checked=\n{{ option2 }}\n\n    \ninput type=\nradio\n name=\noptions\n checked=\n{{ option3 }}\n\n  `,\n  data: {\n    option1: false,\n    option2: true,\n    option3: false\n  }\n})\n\n\n\n\nData can also be bound to radio buttons via the \nname\n directive.\n\n\nRactive({\n  template: `\n    \ninput type=\nradio\n name=\n{{ selectedOption }}\n value=\n1\n\n    \ninput type=\nradio\n name=\n{{ selectedOption }}\n value=\n2\n\n    \ninput type=\nradio\n name=\n{{ selectedOption }}\n value=\n3\n\n  `,\n  data: {\n    selectedOption: '1'\n  }\n})\n\n\n\n\nText areas\n\n\nData can be bound to text areas via the \nvalue\n directive.\n\n\nRactive({\n  template: `\n    \ntextarea value=\n{{ msg }}\n/textarea\n\n  `,\n  data: {\n    msg: 'Hello, World!'\n  }\n})\n\n\n\n\nData can also be bound to text areas via its contents.\n\n\nRactive({\n  template: `\n    \ntextarea\n{{ msg }}\n/textarea\n\n  `,\n  data: {\n    msg: 'Hello, World!'\n  }\n})\n\n\n\n\nSelect lists\n\n\nData can be bound to select lists via the \nvalue\n directive.\n\n\nRactive({\n  template: `\n    \nselect value=\n{{ selectedOption }}\n\n      \noption value=\n1\nRed\n/option\n\n      \noption value=\n2\nGreen\n/option\n\n      \noption value=\n3\nBlue\n/option\n\n    \n/select\n\n  `,\n  data: {\n    selectedOption: '2'\n  }\n})\n\n\n\n\nArray data can also be bound to select lists with the \nmultiple\n attribute via the \nvalue\n directive.\n\n\nRactive({\n  template: `\n    \nselect multiple value=\n{{ selectedItems }}\n\n      \noption value=\n1\nRed\n/option\n\n      \noption value=\n2\nGreen\n/option\n\n      \noption value=\n3\nBlue\n/option\n\n    \n/select\n\n  `,\n  data: {\n    selectedItems: [ '2', '3' ]\n  }\n})\n\n\n\n\ncontenteditable\n\n\nData can be bound to elements that have the \ncontenteditable\n attribute via the \nvalue\n directive.\n\n\nRactive({\n  template: `\n    \ndiv contenteditable=\ntrue\n value=\n{{ msg }}\n/div\n\n  `,\n  data: {\n    msg: 'Hello, World!'\n  }\n})\n\n// Rendered as:\n// \ndiv contenteditable=\ntrue\nHello, World!\n/div\n\n\n\n\n\nThere are a few caveats when binding to an element with \ncontenteditable\n:\n\n\n\n\nThe returned string may or may not always be HTML.\n\n\nThe returned string may be different from browser to browser.\n\n\nAny value set on the bound data will always be rendered as HTML.\n\n\n\n\nDirectives\n\n\nThere are two contexts in which directives are parsed: string and expression. In a string context, mustaches must be used to reference data. In an expression context, mustaches should not be used, as the expression context effectively the same as inside of mustaches. This means that \nclass-\n, \non-\n, \nas-\n, \n-in\n, \n-out\n, \n-in-out\n, and \nbind-\n directive values, being parsed in an expression context, should never contain mustaches. Other attributes and directives are parsed in a string context.\n\n\nOne of the nice things about expression context is that, combined with Ractive's unquoted attribute value support, you can avoid quote plileup for string expressions using backticks. Some text editors don't really like backticks on attributes, though.\n\n\ndiv as-tracked=`id-${.id}`\n\n  The tracked decorator will be passed the string \nid-\n + .id as an argument.\n\n/div\n\n\n\n\n\ntwoway\n\n\nThe element-specific directive form of the \ntwoway\n initialization option.\n\n\n!-- By default, two-way is enabled. Editing the input updates foo. --\n\nTwo-way: \ninput type=\ntext\n value=\n{{ foo }}\n {{ foo }}\n\n\n!-- With twoway=\nfalse\n, editing the input will not update bar. --\n\nOne-way: \ninput type=\ntext\n value=\n{{ bar }}\n twoway=\nfalse\n {{ bar }}\n\n\n!-- Updating bar via the data will update the UI --\n\n\nbutton type=\nbutton\n on-click=\n@this.set('bar', 'baz')\nSet value to bar\n/button\n\n\n\n\n\nlazy\n\n\nThe element-specific directive form of the \nlazy\n initialization option.\n\n\n!-- Editing the input updates foo on keypress. --\n\nEager: \ninput type=\ntext\n value=\n{{ foo }}\n {{ foo }}\n\n\n!-- Editing the input updates bar only when focus moves away from the input. --\n\nLazy: \ninput type=\ntext\n value=\n{{ bar }}\n lazy=\ntrue\n {{ bar }}\n\n\n!-- Editing the input updates bar only five seconds after the change. --\n\nLazy: \ninput type=\ntext\n value=\n{{ bar }}\n lazy=\n5000\n {{ bar }}\n\n\n\n\nas-*\n\n\nas-*\n directives augment the element with decorators. It accepts optional, comma-separated expressions as arguments to the decorator function.\n\n\ndiv as-modal\nDiv appearing as modal\n/div\n\n\ndiv as-modal=\ntrue, true, true, false\nDiv appearing as modal\n/div\n\n\n\n\n\nclass-*\n\n\nclass-*\n directives toggle individual class names based on the truthiness of its value. The part of the directive name following \nclass-\n will be used as the class name. \nclass-*\n directive values are processed as expressions. If there is no expression, the implicit value is \ntrue\n, which is useful for applying multiple classes to an element using component \nextra-attributes\n.\n\n\ndiv class-foo=\nisFoo\nAdds \nfoo\n if isFoo is truthy\n/div\n\n\ndiv class-foo-bar=\nisFooBar\nAdds \nfoo-bar\n if isFooBar is truthy\n/div\n\n\ndiv class-fooBar=\nisFooBar\nAdds \nfooBar\n if isFooBar is truthy\n/div\n\n\ndiv class-baz\nAlways has \nbaz\n/div\n\n\n\n\n\non-*\n\n\non-*\n directives attach event handlers to DOM elements and components. \non-*\n can be used in two ways: proxy syntax or the expression syntax.\n\n\nRactive({\n  template: `\n    \nbutton type=\nbutton\n on-click=\nclickedproxy\nPush me!\n/button\n\n    \nbutton type=\nbutton\n on-click=\n['clickedArray', 'Hello, World!']\nPush me!\n/button\n\n    \nbutton type=\nbutton\n on-click=\n@this.clickedMethod('Hello, World!')\nPush me!\n/button\n\n  `,\n  on: {\n    clickedproxy (context) {\n      console.log('Hello, World!')\n    },\n    clickedArray (context, msg) {\n      console.log(msg)\n    }\n  },\n  clickedMethod(msg) {\n    console.log(msg)\n  }\n})\n\n\n\n\nMultiple events can also be tied to the same handler by appending event names to the directive, separating them by hyphens:\n\n\nRactive({\n  template: `\n    \nbutton type=\nbutton\n on-hover-click=\n@this.someMethod()\nPush me!\n/button\n\n  `,\n  someMethod () {\n    console.log('Fires on hover and on click!')\n  }\n})\n\n\n\n\n*-in, *-out, *-in-out\n\n\n*-in\n, \n*-out\n, and \n*-in-out\n directives apply transitions to the element. \n*-in\n specifies intro-only, \n*-out\n specifies outro-only, and \n*-in-out\n for both intro and outro. All three directives accept optional, comma-separated expressions as arguments to the transition function.\n\n\ndiv fade-in\nFades on render\n/div\n\n\ndiv fade-out\nFades before removal\n/div\n\n\ndiv fade-in-out\nFades on render and before removal\n/div\n\n\ndiv fade-in-out=\n{ duration: 500 }, someOtherArg\nFades with 500ms duration\n/div\n\n\n\n\n\nstyle-*\n\n\nstyle-*\n directives update individual \nstyle\n properties of the element. The part of the directive following \nstyle-\n will be used as the style property name. Style names can either be in kebab case or camel case, and will be normalized on application.\n\n\ndiv style-vertical-align=\nmiddle\nApplies style.verticalAlign\n/div\n\n\ndiv style-textAlign=\ncenter\nApplies style.textAlign\n/div\n\n\n\n\n\nstyle-*\n directive values are processed as strings. Mustaches can also be used to supply the values. When the values are updated, the appropriate style property on the element will update to the new value.\n\n\ndiv style-vertical-align=\n{{ vAlign }}\n style-textAlign=\n{{ tAlign }}\n...\n/div\n\n\n\n\n\nbind-*\n\n\nbind-*\n directives are the same as regular attributes, except they are parsed in an expression context rather than a string context.\n\n\ninput value=\n{{foo}}\n /\n\nis the same as\n\ninput bind-value=\nfoo\n /\n\n\n\n\n\nKeypath prefixes\n\n\nNormally, keypaths are resolved following a defined routine. But there are times where you want to skip the normal resolution routine and resolve a keypath relative to a specific data context. Keypath prefixes allow you to specify which data context a keypath resolves to, regardless if it resolves to something or not.\n\n\nCurrent context\n\n\nResolves the keypath relative to the current data context.\n\n\n\n\n\nRactive({\n  target: 'body',\n  data: {\n    spoon: 'SPOON',\n    matrix: {\n      agent: 'Smith'\n      // There is no spoon\n    }\n  },\n  template: `\n    \ndiv\nOutside the matrix, you have {{ spoon }}\n/div\n\n    {{# matrix }}\n      \ndiv\nInside the matrix, you think you have {{ spoon }}.\n/div\n\n      \ndiv\nIn reality, there is no {{ ./spoon }}\n/div\n\n    {{/}}\n  `\n})\n\n// Outside the matrix, you have SPOON\n// Inside the matrix, you think you have SPOON.\n// In reality, there is no\n\n\n\n\nParent keypath\n\n\nResolves the keypath relative to the parent data. This prefix can be used more than once to reference ancestors.\n\n\n\n\n\nRactive({\n  target: 'body',\n  data: {\n    id: 'reality',\n    dream: {\n      id: 'dream1',\n      dream: {\n        id: 'dream2',\n        dream: {\n          id: 'dream3',\n        }\n      }\n    }\n  },\n  template: `\n    \ndiv\nYou are in {{ id }}\n/div\n\n    {{# dream }}\n      \ndiv\nYou are in {{ id }}\n/div\n\n      {{# dream }}\n        \ndiv\nYou are in {{ id }}\n/div\n\n        {{# dream }}\n          \ndiv\nYou are in {{ id }}\n/div\n\n\n          \ndiv\nEscaping...\n/div\n\n          \ndiv\nYou are in {{ ../id }}\n/div\n\n          \ndiv\nYou are in {{ ../../id }}\n/div\n\n          \ndiv\nYou are in {{ ../../../id }}\n/div\n\n        {{/}}\n      {{/}}\n    {{/}}\n  `\n})\n\n// You are in reality\n// You are in dream1\n// You are in dream2\n// You are in dream3\n// Escaping...\n// You are in dream2\n// You are in dream1\n// You are in reality\n\n\n\n\nParent context\n\n\nWhile parent keypaths and parent contexts are often the same thing, there are some scenarios in which they are very, very different. For instance, in this horribly contrived example:\n\n\n\n\n\nRactive({\n  target: 'body',\n  data: {\n    homebase: {\n      building1: { name: 'Operations' }\n    },\n    bases: [\n      {\n        building1: { name: 'Mess Hall' }\n      },\n      {\n        building1: { name: 'Medical Tent' }\n      }\n    ]\n  },\n  template: `\n    {{#each bases}}\n      {{#with ~/homebase}}\n        \ndiv\nthe home base bulding1 is {{.building1.name}}\n/div\n\n        \ndiv\nthe current iteration base building1 is {{^^/building1.name}}\n/div\n\n      {{/with}}\n    {{/each}}\n  `\n})\n\n// the home base bulding1 is Operations\n// the current iteration base building1 is Mess Hall\n// the home base bulding1 is Operations\n// the current iteration base building1 is Medical Tent\n\n\n\n\nInstance root context\n\n\nResolves the keypath relative to the instance's root data context.\n\n\n\n\n\nRactive({\n  target: 'body',\n  data: {\n    room: '1',\n    portal: {\n      room: '2',\n      portal: {\n        room: '3',\n        portal: {\n          room: '4',\n        }\n      }\n    }\n  },\n  template: `\n    {{# portal }}\n      {{# portal }}\n        {{# portal }}\n          \ndiv\nEntering...\n/div\n\n          \ndiv\nYou are in room {{ ~/room }}\n/div\n\n          \ndiv\nYou are in room {{ ~/portal.room }}\n/div\n\n          \ndiv\nYou are in room {{ ~/portal.portal.room }}\n/div\n\n          \ndiv\nYou are in room {{ ~/portal.portal.portal.room }}\n/div\n\n        {{/}}\n      {{/}}\n    {{/}}\n  `\n})\n\n// Entering...\n// You are in room 1\n// You are in room 2\n// You are in room 3\n// You are in room 4\n\n\n\n\nSpecial references\n\n\nSpecial references are template keywords that act like data references but do not actually exist in your data. These references provide metadata regarding the current instance, context, environment, operation and more.\n\n\nthis\n\n\nThe current data context.\n\n\n\n\n\nRactive({\n  el: 'body',\n  data: {\n    info: {\n      message: 'Hello World!',\n      info: {\n        message: 'The quick brown fox',\n        info: {\n          message: 'jumps over the lazy dog',\n          info: {\n            message: 'Thats all folks'\n          }\n        }\n      }\n    }\n  },\n  template: `\n    \ndiv\nroot: {{ JSON.stringify(this) }}\n/div\n\n    {{# info }}\n      \ndiv\ninfo 1: {{ JSON.stringify(this) }}\n/div\n\n      {{# info }}\n        \ndiv\ninfo 2: {{ JSON.stringify(this) }}\n/div\n\n        {{# info }}\n          \ndiv\ninfo 3: {{ JSON.stringify(this) }}\n/div\n\n          {{# info }}\n            \ndiv\ninfo 4: {{ JSON.stringify(this) }}\n/div\n\n          {{/}}\n        {{/}}\n      {{/}}\n    {{/}}\n  `,\n})\n\n// info 1: {\ninfo\n:{\nmessage\n:\nHello World!\n,\ninfo\n:{\nmessage\n:\nThe quick brown fox\n,\ninfo\n:{\nmessage\n:\njumps over the lazy dog\n,\ninfo\n:{\nmessage\n:\nThats all folks\n}}}}}\n// info 2: {\nmessage\n:\nHello World!\n,\ninfo\n:{\nmessage\n:\nThe quick brown fox\n,\ninfo\n:{\nmessage\n:\njumps over the lazy dog\n,\ninfo\n:{\nmessage\n:\nThats all folks\n}}}}\n// info 3: {\nmessage\n:\nThe quick brown fox\n,\ninfo\n:{\nmessage\n:\njumps over the lazy dog\n,\ninfo\n:{\nmessage\n:\nThats all folks\n}}}\n// info 4: {\nmessage\n:\njumps over the lazy dog\n,\ninfo\n:{\nmessage\n:\nThats all folks\n}}\n// info 5: {\nmessage\n:\nThats all folks\n}\n\n\n\n\n@this\n\n\nThe current Ractive instance.\n\n\n\n\n\nRactive({\n  el: 'body',\n  data: {\n    count: 1\n  },\n  template: `\n    \ndiv\nCount: {{ count }}\n/div\n\n    \nbutton type=\nbutton\n on-click=\n@this.add('count')\nIncrement\n/button\n\n    \nbutton type=\nbutton\n on-click=\n@this.myMethod()\nLog count\n/button\n\n  `,\n  myMethod () {\n    console.log(`current count is ${this.get('count')}`)\n  }\n})\n\n\n\n\n@this\n can also be referenced by using its shorthand \n@\n.\n\n\n\n\n\nRactive({\n  el: 'body',\n  data: {\n    count: 1\n  },\n  template: `\n    \ndiv\nCount: {{ count }}\n/div\n\n    \nbutton type=\nbutton\n on-click=\n@.add('count')\nIncrement\n/button\n\n    \nbutton type=\nbutton\n on-click=\n@.myMethod()\nLog count\n/button\n\n  `,\n  myMethod () {\n    console.log(`current count is ${this.get('count')}`)\n  }\n})\n\n\n\n\n@index\n\n\nThe current iteration index of the containing repeated section.\n\n\n\n\n\nRactive({\n  el: 'body',\n  data: {\n    users: [\n      { name: 'bob' },\n      { name: 'alice' },\n      { name: 'eve' },\n    ]\n  },\n  template: `\n    {{#each users}}\n      \ndiv\nUser #{{ @index }} says: Hi! I'm {{ name }}!\n/div\n\n    {{/each}}\n  `\n})\n\n// User #0 says: Hi! I'm bob!\n// User #1 says: Hi! I'm alice!\n// User #2 says: Hi! I'm eve!\n\n\n\n\nFor objects, \n@index\n is still the iteration index.\n\n\n\n\n\nRactive({\n  el: 'body',\n  data: {\n    users: {\n      bob: 'Hi! I am bob!',\n      alice: 'Hi! I am alice!',\n      eve: 'Hi! I am eve!'\n    }\n  },\n  template: `\n    {{#each users}}\n      \ndiv\nUser #{{ @index }} says: {{ this }}\n/div\n\n    {{/each}}\n  `\n})\n\n// User #0 says: Hi! I am bob!\n// User #1 says: Hi! I am alice!\n// User #2 says: Hi! I am eve!\n\n\n\n\n@key\n\n\nThe current key name of the containing object iteration section.\n\n\n\n\n\nRactive({\n  el: 'body',\n  data: {\n    users: {\n      bob: 'Hi! I am bob!',\n      alice: 'Hi! I am alice!',\n      eve: 'Hi! I am eve!'\n    }\n  },\n  template: `\n    {{#each users}}\n      \ndiv\nUser {{ @key }} says: {{ this }}\n/div\n\n    {{/each}}\n  `\n})\n\n// User bob says: Hi! I am bob!\n// User alice says: Hi! I am alice!\n// User eve says: Hi! I am eve!\n\n\n\n\nFor arrays, \n@key\n's value will be the iteration index.\n\n\n\n\n\nRactive({\n  el: 'body',\n  data: {\n    users: [\n      { name: 'bob' },\n      { name: 'alice' },\n      { name: 'eve' },\n    ]\n  },\n  template: `\n    {{#each users}}\n      \ndiv\nUser #{{ @key }} says: Hi! I'm {{ name }}!\n/div\n\n    {{/each}}\n  `\n})\n\n// User #0 says: Hi! I'm bob!\n// User #1 says: Hi! I'm alice!\n// User #2 says: Hi! I'm eve!\n\n\n\n\n@last\n\n\nThe index of the last iteration of the nearest iterative block. This is helpful for detecting the end of an object iteration.\n\n\nRactive({\n  el: 'body',\n  data: {\n    users: {\n      bob: 'Hi! I am bob!',\n      alice: 'Hi! I am alice!',\n      eve: 'Hi! I am eve!'\n    }\n  },\n  template: `\n    {{#each users}}\n      \ndiv\n{{@key}}{{#if @last === @index}} is the last user{{/if}}\n/div\n\n    {{/each}}\n  `\n})\n\n// bob\n// alice\n// eve is the last user\n\n\n\n\n@keypath\n\n\nThe keypath to the current data context relative to the instance's root data context.\n\n\n\n\n\nRactive({\n  el: 'body',\n  data: {\n    foo: {\n      bar: {\n        baz: {\n          message: 'hello world'\n        }\n      }\n    }\n  },\n  template: `\n    \ndiv\nKeypath: {{ @keypath }}\n/div\n\n    {{# foo }}\n      \ndiv\nKeypath: {{ @keypath }}\n/div\n\n      {{# bar }}\n        \ndiv\nKeypath: {{ @keypath }}\n/div\n\n        {{# baz }}\n          \ndiv\nKeypath: {{ @keypath }}\n/div\n\n        {{/}}\n      {{/}}\n    {{/}}\n  `\n})\n\n// Keypath:\n// Keypath: foo\n// Keypath: foo.bar\n// Keypath: foo.bar.baz\n\n\n\n\nIf the keypath is a mapping, the keypath will remain relative to the instance.\n\n\n\n\n\nRactive.components.Message = Ractive.extend({\n  data: () =\n ({\n    info : {},\n  }),\n  template: `\n    {{# info }}\n      \ndiv\nSender: {{ name }}\n/div\n\n      \ndiv\nMessage: {{ message }}\n/div\n\n      \ndiv\nKeypath: {{ @keypath }}\n/div\n\n    {{/}}\n  `\n})\n\nRactive({\n  el: 'body',\n  data: {\n    mail: {\n      inbox: {\n        messages: [{\n          name: 'bob',\n          message: 'Hi alice!'\n        },{\n          name: 'bob',\n          message: 'Hi eve!'\n        }]\n      }\n    }\n  },\n  template: `\n    {{# mail.inbox.messages }}\n      \nMessage info=\n{{ this }}\n /\n\n    {{/}}\n  `\n})\n\n// Sender: bob\n// Message: Hi alice!\n// Keypath: info\n// Sender: bob\n// Message: Hi eve!\n// Keypath: info\n\n\n\n\n@rootpath\n\n\nThe keypath to the current data context relative to the originating instance's root data context.\n\n\n\n\n\nRactive({\n  el: 'body',\n  data: {\n    foo: {\n      bar: {\n        baz: {\n          message: 'hello world'\n        }\n      }\n    }\n  },\n  template: `\n    \ndiv\nKeypath: {{ @rootpath }}\n/div\n\n    {{# foo }}\n      \ndiv\nKeypath: {{ @rootpath }}\n/div\n\n      {{# bar }}\n        \ndiv\nKeypath: {{ @rootpath }}\n/div\n\n        {{# baz }}\n          \ndiv\nKeypath: {{ @rootpath }}\n/div\n\n        {{/}}\n      {{/}}\n    {{/}}\n  `\n})\n\n// Keypath:\n// Keypath: foo\n// Keypath: foo.bar\n// Keypath: foo.bar.baz\n\n\n\n\nIf the keypath is a mapping, it will be adjusted relative to the originating instance's root data context. This is what primarily sets \n@rootpath\n apart from \n@keypath\n.\n\n\n\n\n\nRactive.components.Message = Ractive.extend({\n  data: () =\n ({\n    info : {},\n  }),\n  template: `\n    {{# info }}\n      \ndiv\nSender: {{ name }}\n/div\n\n      \ndiv\nMessage: {{ message }}\n/div\n\n      \ndiv\nKeypath: {{ @rootpath }}\n/div\n\n    {{/}}\n  `\n})\n\nRactive({\n  el: 'body',\n  data: {\n    mail: {\n      inbox: {\n        messages: [{\n          name: 'bob',\n          message: 'Hi alice!'\n        },{\n          name: 'bob',\n          message: 'Hi eve!'\n        }]\n      }\n    }\n  },\n  template: `\n    {{# mail.inbox.messages }}\n      \nMessage info=\n{{ this }}\n /\n\n    {{/}}\n  `\n})\n\n// Sender: bob\n// Message: Hi alice!\n// Keypath: mail.inbox.messages.0\n// Sender: bob\n// Message: Hi eve!\n// Keypath: mail.inbox.messages.1\n\n\n\n\n@global\n\n\nThe global object of the current environment. For browsers, it references the \nwindow\n object. For Node.js, it references the \nglobal\n object.\n\n\n\n\n\nwindow.message = 'Hello World!'\n\nRactive({\n  el: 'body',\n  template: `\n    {{ @global.message }}\n  `\n})\n\n// Hello World!\n\n\n\n\nRactive can automatically update properties on \n@global\n via two-way binding. However, for changes caused externally, \nractive.update()\n must be called to re-render the UI.\n\n\n\n\n\nwindow.message = 'Hello World!'\n\nRactive({\n  el: 'body',\n  template: `\n    {{ @global.message }}\n    \ninput type=\ntext\n value=\n{{ @global.message }}\n\n    \nbutton type=\nbutton\n on-click=\n@this.logReference()\nLog reference value\n/button\n\n    \nbutton type=\nbutton\n on-click=\n@this.logGlobal()\nLog global value\n/button\n\n    \nbutton type=\nbutton\n on-click=\n@this.setFooBarBaz()\nChange to \nfoo bar baz\n directly\n/button\n\n    \nbutton type=\nbutton\n on-click=\n@this.update('@global.message')\nClick to update\n/button\n\n\n    \nol\n\n      \nli\nClick \nLog reference value\n and look at the console\n/li\n\n      \nli\nClick \nLog global value\n and look at the console\n/li\n\n      \nli\nChange the input value and repeat steps 1 and 2\n/li\n\n      \nli\nClick \nChange to 'foo bar baz' directly\n/li\n\n      \nli\nRepeat steps 1 and 2 and notice that step 1 was not aware of the direct change\n/li\n\n      \nli\nClick \nClick to update\n/li\n\n      \nli\nRepeat steps 1 and 2 and notice that both steps are now aware\n/li\n\n    \n/ol\n\n  `,\n  logReference () {\n    console.log(this.get('@global.message'))\n  },\n  logGlobal () {\n    console.log(window.message)\n  },\n  setFooBarBaz () {\n    window.message = \nfoo bar baz\n\n  }\n})\n\n\n\n\n@shared\n\n\n@shared\n is a Ractive-global model similar to \n@global\n but not subject to interference from outside of Ractive.\n\n\n@context\n\n\nThe context object associated with the current context.\n\n\n@event\n\n\nThe DOM event that is triggering an event directive. This reference is only available to event directive expressions.\n\n\n@node\n\n\nThe DOM node associated with an event directive. This reference is only available to event directive expressions.\n\n\n@local\n\n\nSpecial context-local storage associated with the current context. This is intended more for library use with decorators and parser transforms.\n\n\n@style\n\n\nFrom 0.9.4\n\n\nThe cssData associated with the current instance based on its constructor.\n\n\n$n\n\n\n$n\n is a reference available when handing events using the expression syntax that points to a specific argument passed by the event. Argument positions are denoted by the \nn\n which is a one-indexed integer.\n\n\nconst CustomButton = Ractive.extend({\n  template: `\n    \nbutton on-click=\n@this.fire('buttonevent', 'foo', 'bar')\nClick Me\n/button\n\n  `\n})\n\nRactive({\n  components: { CustomButton },\n  template: `\n    \n!-- Use with proxy expression syntax --\n\n    \nCustomButton on-buttonevent=\n['proxy', $1, $2]\n /\n\n\n    \n!-- Use with method call --\n\n    \nCustomButton on-buttonevent=\n@this.method($1, $2)\n /\n\n  `,\n  on: {\n    proxy (context, foo, bar) {\n      console.log(foo, bar)\n    }\n  },\n  method (foo,bar) {\n    console.log(foo, bar)\n  }\n})\n\n\n\n\narguments\n\n\narguments\n is a reference available when handling events using the expression syntax that points to an array of arguments passed by the event.\n\n\nconst CustomButton = Ractive.extend({\n  template: `\n    \nbutton on-click=\n@this.fire('buttonevent', 'foo', 'bar')\nClick Me\n/button\n\n  `\n})\n\nRactive({\n  components: { CustomButton },\n  template: `\n    \n!-- Use with proxy expression syntax --\n\n    \nCustomButton on-buttonevent=\n['proxy', arguments]\n /\n\n\n    \n!-- Use with method call --\n\n    \nCustomButton on-buttonevent=\n@this.method(arguments)\n /\n\n  `,\n  on: {\n    proxy (context, args) {\n      console.log(args)\n    }\n  },\n  method (foo,bar) {\n    console.log(args)\n  }\n})\n\n\n\n\narguments\n is a normal array instance and not the special \narguments\n JavaScript variable.\n\n\nInitialization Options\n\n\nThe following is an exhaustive list of initialisation options that you can pass to \nRactive()\n and \nRactive.extend()\n. Extra properties passed as options that are not initialization options are added as properties or methods of the instance.\n\n\nvar ractive = Ractive({\n  myMethod () {\n    alert( 'my method was called' )\n  }\n})\n\nractive.myMethod(); // triggers the alert\n\n\n\n\nadapt\n\n\n(Array\nstring|Object\n)\n\n\nAn array of adaptors to use. Values can either be names of registered adaptors or an adaptor definition.\n\n\nadapt: [ 'MyAdaptor', AdaptorDefinition ]\n\n\n\n\nadapt\n is not required if you registered adaptors via the \nadaptors\n initialization property. The adaptors registered via \nadaptors\n initialization property are automatically used as if they were set with \nadapt\n.\n\n\nconst instance = Ractive({\n  adaptors: { MyAdaptor: AdaptorDefinition }\n  // No need to use adapt\n})\n\nconst Component = Ractive.extend({\n  adaptors: { MyAdaptor: AdaptorDefinition }\n  // No need to use adapt\n})\n\nnew Component({\n  // No need to use adapt\n})\n\n\n\n\nadaptors\n\n\n(Object\nstring, Object\n)\n\n\nA map of adaptors where the key is the adaptor name and the value is an adaptor definition.\n\n\nadaptors: {\n  MyAdaptor: AdaptorDefinition\n}\n\n\n\n\nRegistering an adaptor via \nadaptors\n is not required if you directly specified the adaptor definition via \nadapt\n.\n\n\nconst Adaptor = { ... }\n\nconst instance = Ractive({\n  adapt: [ AdaptorDefinition ]\n  // No need to use adaptors\n})\n\n\n\n\nallowExpressions\n\n\nFrom 0.10.0\n\n\n(boolean)\n\n\nIndicates whether or not Ractive should process expressions. Defaults to \ntrue\n.\n\n\nSetting this to \nfalse\n effectively avoids the use of the \nFunction\n constructor at the cost of not being able to use expressions such as those found in templates and computed properties.\n\n\nappend\n\n\n(boolean|string|HTMLElement|array-like)\n\n\nControls how the instance is attached to \nel\n. Defaults to \nfalse\n.\n\n\nfalse\n replaces the contents of \nel\n.\n\n\n!-- before --\n\n\ndiv id='container'\n\n  \np\nexisting content\n/p\n\n\n/div\n\n\n\n\n\nel: '#container',\nappend: false,\ntemplate: '\np\nnew content\n/p\n'\n\n\n\n\n!-- after --\n\n\ndiv id='container'\n\n  \np\nnew content\n/p\n\n\n/div\n\n\n\n\n\ntrue\n appends the instance to \nel\n.\n\n\n!-- before --\n\n\ndiv id='container'\n\n  \np\nexisting content\n/p\n\n\n/div\n\n\n\n\n\nel: '#container',\nappend: true,\ntemplate: '\np\nnew content\n/p\n'\n\n\n\n\n!-- after --\n\n\ndiv id='container'\n\n  \np\nexisting content\n/p\n\n  \np\nnew content\n/p\n\n\n/div\n\n\n\n\n\nAn \nid\n of the element, a CSS selector to an element, an HTML element, or an array-like object whose first item is an HTML element, which is a child of \nel\n will render the instance before that element.\n\n\n!-- before --\n\n\ndiv id='container'\n\n  \np\nred\n/p\n\n  \np\norange\n/p\n\n  \np\nyellow\n/p\n\n\n/div\n\n\n\n\n\nel: '#container',\nappend: document.querySelector('p:nth-child(2)'),\ntemplate: '\np\ngrey\n/p\n'\n\n\n\n\n!-- after --\n\n\ndiv id='container'\n\n  \np\nred\n/p\n\n  \np\ngrey\n/p\n\n  \np\norange\n/p\n\n  \np\nyellow\n/p\n\n\n/div\n\n\n\n\n\nattributes\n\n\n(Object\nstring, [string]|Object\nstring, [string]\n)\n\n\nAn array of optional attributes or a map of optional and required attributes. Defaults to \nundefined\n.\n\n\nYou can supply a list of optional attributes using an array. You can also supply an object with an \noptional\n array of attribute names and a \nrequired\n array of attribute names. At runtime, if a component is created missing a required attribute, Ractive will issue a warning about missing required attributes. Any attributes that are passed to the component that are \nnot\n included in either of the \noptional\n or \nrequired\n lists of attributes will be collected into a partial named \nextra-attributes\n so that they can be included on a top-level element in the component template or split apart to be used in a component \ninit\n event.\n\n\nconst Component = Ractive.extend({\n  template: `\ndiv class-component-wrapper {{yield extra-attributes}}\nFancy component doing something with list and type\n/div\n`,\n  attributes: {\n    required: [ 'list' ],\n    optional: [ 'type' ]\n  }\n})\n\n// \nComponent type=\nfoo\n /\n will issue a warning about missing list\n// \nComponent list=\n{{things}}\n style-color=\ngreen\n /\n will not warn, but will include the style-color=\ngreen\n on the wrapper div\n\n\n\n\nThe extra attributes passed to a component are not limited to simple attributes - they can also include directives, but any mustache sections will not have their contents checked. By default, the \nextra-attributes\n will \nnot\n be mapped, meaning that the values won't be available with \nget\n from the component, so the partial should be yielded. If you need the extra attributes to be mapped, include an additional setting in the attributes map \nmapAll: true\n.\n\n\ncomponents\n\n\n(Object\nstring, Function|Promise)\n\n\nA map of components available to the instance or component being configured. The key is the registered name of the component, which is used in the template.\n\n\nA component can be registered statically by assinging a component definition.\n\n\nconst MyStaticComponent = Ractive.extend({ ... })\n\nconst MyComponent = Ractive.extend({\n  components: { MyStaticComponent },\n  template: `\n    \nMyStaticComponent /\n\n  `\n})\n\n\n\n\nA component can be registered dynamically by assinging a function that returns either a component definition, or a name of a registered component. The function receives \ndata\n as first argument.\n\n\nRactive.components.GlobalComponent = Ractive.extend({ ... })\n\nconst NonGlobalComponent = Ractive.extend({ ... })\n\nconst MyComponent = Ractive.extend({\n  data: { isGlobal: false },\n  components: {\n    MyDynamicComponent: (data) =\n data.isGlobal ? 'GlobalComponent' : NonGlobalComponent\n  },\n  template: `\n    \nMyDynamicComponent /\n\n  `\n})\n\n\n\n\nA component can be loaded asynchronously by assingning a promise that resolves with a component definition.\n\n\n // Assuming MyAsyncComponent.js does `export default Ractive.extend({ ... })`\n\nconst MyComponent = Ractive.extend({\n  components: {\n    MyAsyncComponent: import('./path/to/MyAsyncComponent.js')\n  },\n  template: `\n    \nMyAsyncComponent /\n\n  `\n})\n\n\n\n\nA component can be loaded lazily by assinging a function that returns a promise that resolves with a component definition. Ractive only loads the component when it's being rendered.\n\n\n // Assuming MyAsyncComponent.js does `export default Ractive.extend({ ... })`\n\nconst MyComponent = Ractive.extend({\n  components: {\n    MyAsyncComponent: () =\n import('./path/to/MyAsyncComponent.js')\n  },\n  template: `\n    \nMyAsyncComponent /\n\n  `\n})\n\n\n\n\nIn both asynchronous cases, instances will be rendered immediately while the asynchronous components load. Once the asynchronous components are available, their placeholders will be re-rendered. Two reserved partial names, \nasync-loading\n and \nasync-loaded\n, can be used to define markup when the asynchronous component is loading and loaded, respectively. A special partial named \ncomponent\n is also available to render the component's contents inside \nasync-loaded\n.\n\n\n // Assuming MyAsyncComponent.js does `export default Ractive.extend({ ... })`\n\nconst MyComponent = Ractive.extend({\n  components: {\n    MyAsyncComponent: import('./path/to/MyAsyncComponent.js')\n  },\n  template: `\n    \nspan\nI'm rendered immediately. I don't wait for MyAsyncComponent\n/span\n\n    \nMyAsyncComponent\n\n      {{#partial async-loading}}I'm rendered when MyAsyncComponent is loading{{/partial}}\n      {{#partial async-loaded}}I'm rendered when MyAsyncComponent is loaded{{/partial}}\n      {{#partial async-loaded}}MyAsyncComponent contents: {{\ncomponent}}{{/partial}}\n    \n/MyAsyncComponent\n\n  `\n})\n\n\n\n\nDuring a \nractive.reset()\n, components registered using a function are re-evaluated. If the return value changes, the Ractive instance will be re-rendered.\n\n\ncomputed\n\n\n(Object\nstring, function|Object\n)\n\n\nA map of computed properties where the key is the name of the computed property and the value is either a computed property expression, a function that returns a value, or an object that has \nget\n and \nset\n functions.\n\n\n// Imagine a square...\ncomputed: {\n  // Computed property expression\n  diagonal: '${side} * Math.sqrt(2)',\n\n  // A function\n  perimeter () {\n    return 4 * this.get('side')\n  },\n\n  // An object with get and set functions\n  area: {\n    get () {\n      return Math.pow(this.get('side'), 2)\n    },\n    set (value) {\n      this.set('side', Math.sqrt(value))\n    }\n  },\n}\n\n\n\n\ncsp\n\n\n(boolean)\n\n\nWhether or not to add inline functions for expressions after parsing. Defaults to \nfalse\n.\n\n\nThis can effectively eliminate \neval\n caused by expressions in templates. It also makes the resulting template no longer JSON compatible, so the template will have to be served via \nscript\n tag.\n\n\ncss\n\n\n(string|function)\n\n\nScoped CSS for a component and its descendants.\n\n\ncss: `\n  .bold { font-weight: bold }\n`\n\n\n\n\nAt the moment, only applies to components.\n\n\n// This works\nconst Component = Ractive.extend({\n  css: '...'\n})\n\n// This will not work\nRactive({\n  css: '...'\n})\n\n\n\n\nFrom 0.9.4\n, if \ncss\n is a function, the function will be called with a handle to the component's style data and is expected to return a string of CSS.\n\n\nconst Component = Ractive.extend({\n  css(data) {\n    // you can use Ractive.styleSet('colors.special', 'pink') or Component.styleSet('colors.special', 'pink')\n    // at any time to override the default here, which is green\n    return `\n      .super-special { color: ${data('colors.special') || 'green'}; }\n    `\n  }\n})\n\n\n\n\ncssData\n\n\nFrom 0.9.4\n\n\n(object)\n\n\nLike \ncss\n, this also only applies to components. This is the default data for a component's style computation, if it has one. It is inherited from parent components all the way back to Ractive, and any changes that are made at any point in the hierarchy are automatically propagated down from that point. This means that if a component uses \nfoo\n in its style computation but does not define a value for it in its \ncssData\n, then calling \nRactive.styleSet('foo', ...)\n will cause the component style to recompute.\n\n\ncssId\n\n\n(string)\n\n\nThis value is used to scope CSS defined on a component's \ncss\n initialization option only to the instances of the component. By default, the value is a randomly generated UUID.\n\n\ndata\n\n\n(Object\nstring, any\n|Function)\n\n\nThe data for an instance, or default data for a component. Can either be an object or a function that returns an object.\n\n\n// Object form\ndata: {\n  foo: 'bar'\n}\n\n// Function form\ndata () {\n  return { foo: 'bar' }\n}\n\n// Function form using arrow function for less verbosity\ndata: () =\n ({\n  foo: 'bar'\n})\n\n\n\n\nWhen using the object form, the data is attached to the component's prototype. Standard prototype rules apply.\n\n\nconst Component = Ractive.extend({\n  data: {\n    foo: { bar: 42 }\n  }\n})\n\nvar component1 = Component()\nvar component2 = Component()\ncomponent1.set( 'foo.bar', 12 )\ncomponent2.get( 'foo.bar' ); // returns 12\n\n\n\n\nWhen using the function form, the function is executed to give each instance a copy of the data. Standard prototype rules apply.\n\n\nconst Component = Ractive.extend({\n  data () {\n    return {\n      foo: { bar: 42 }\n    }\n  }\n})\n\nvar component1 = Component()\nvar component2 = Component()\ncomponent1.set( 'foo.bar', 12 )\ncomponent2.get( 'foo.bar' ); // returns 42\n\n\n\n\nWhen extending from a constructor, data from the parent constructor will be shallow-copied over to the child data. Child data takes precedence in the event of collisions.\n\n\nconst Parent = Ractive.extend({\n  data: {\n    foo: 'Hello',\n    bar: 'World'\n  }\n})\n\nconst Child = Parent.extend({\n  data: {\n    foo: 'Goodbye'\n  }\n})\n\nParent().get(); // { foo: 'Hello', bar: 'World' }\nChild().get();  // { foo: 'Goodbye', bar: 'World' }\n\n\n\n\ndecorators\n\n\n(Object\nstring, Function\n)\n\n\nA map of decorators where the key is the decorator name and the value is a decorator definition.\n\n\ndecorators: {\n  MyDecorator: DecoratorDefinition\n}\n\n\n\n\ndelegate\n\n\n(boolean)\n\n\nWhether or not to enable automatic event delegation for iterative sections within an element. Defaults to \ntrue\n.\n\n\nWhen enabled, DOM events subscribed within iterative sections will not add a DOM event listener to each element. Instead, a single listener will be installed on the element containing the iterative section, and that listener will find appropriate event directives starting from the target element and working back to the containing element with the listener.\n\n\ndelimiters\n\n\n(Array[string])\n\n\nSets the template delimiters. Defaults to \n[ '{{', '}}' ]\n.\n\n\ndelimiters: [ '\n%=', '%\n' ],\ntemplate: 'hello \n%= world %\n',\ndata: { world: 'earth' }\n\n// result:\n// hello earth\n\n\n\n\neasing\n\n\n(Object\nstring, Function\n)\n\n\nA map of easing functions where the key is the easing function name and the value is the easing function.\n\n\neasing: {\n  MyEasing: EasingDefinition\n}\n\n\n\n\nel\n\n\n(string|HTMLElement|array-like)\n\n\nThe element to render an instance to. Can either be an \nid\n of the element, a CSS selector to an element, an HTML element, or an array-like object whose first item is an HTML element.\n\n\nel: 'container'\nel: '#container'\nel: document.getElementById('container')\nel: jQuery('#container')\n\n\n\n\nenhance\n\n\n(boolean)\n\n\nWhether or not to apply progressive enhancement by inspecting the contents of \nel\n and try to reuse as much of the existing tree as possible. Defaults to \nfalse\n.\n\n\nThere are a few limitations to this feature:\n\n\n\n\n\n\nThis option cannot be used with \nappend\n.\n\n\n\n\n\n\nUnescaped HTML mustaches (triples) don't play nicely with enhance because there's no easy way to match up the string content to the target DOM nodes.\n\n\n\n\n\n\nAll matching elements will be reused, except for a few cases regarding text nodes.\n\n\ndiv\nleft text {{#if foo}} middle text {{/if}} right text\n/div\n\n\nHTML does not have markup representation for adjacent text nodes. Rendering the snippet above from the server, regardless of \nfoo\n's value, the browser creates one contiguous text node. However, Ractive will need \nthree\n adjacent text nodes to represent it: One for \nouter text\n, another for \nright text\n and another for \nmiddle text\n when \nfoo\n becomes truthy.\n\n\nIt has been suggested that Ractive could deal with merged text nodes, but that would lead to extra complexity as there are certain scenarios where the text node would have to split and rejoin. When \nfoo\n is falsey, \nleft text\n and \nright text\n could be merged. But when \nfoo\n becomes truthy, that text node would have to split in order to accomodate \nmiddle text\n.\n\n\n\n\n\n\nevents\n\n\n(Object\nstring, Function\n)\n\n\nA map of events where the key is the event name and value is an event definition.\n\n\nevents: {\n  MyEvent: EventDefinition\n}\n\n\n\n\ninterpolate\n\n\n(Object\nstring, boolean\n)\n\n\nA map of elements that controls whether or not interpolation is allowed within the element. If an element is present in the map, then nested tags are treated as text rather than elements, as in a \nscript\n tag. If the value associated with the element is \nfalse\n, mustaches within the element are also treated as text rather than blocks or interpolators.\n\n\ninterpolate: {\n  textarea: true,\n  script: true,\n  style: true,\n  template: true\n}\n\n\n\n\ninterpolators\n\n\n(Object\nstring, Function\n)\n\n\nA map of interpolators where the key is the interpolator name and the value is an interpolator definition.\n\n\ninterpolators: {\n  MyInterpolator: InterpolatorDefinition\n}\n\n\n\n\nisolated\n\n\n(boolean)\n\n\nControls whether the component will try to resolve data and plugins on its ancestors. Defaults to \ntrue\n.\n\n\nRelevant only to Components.\n\n\nlazy\n\n\n(boolean|number)\n\n\nWhether or not to update data using late-firing DOM events (i.e. \nchange\n, \nblur\n) instead of events that fire immediately on interaction (i.e. \nkeyup\n, \nkeydown\n). Defaults to \nfalse\n.\n\n\nvar ractive = Ractive({\n  lazy: true,\n  data: { foo: 'bar' },\n  template: `\n    \ninput value=\n{{foo}}\n\n\n    \n!-- Updates when the input loses focus --\n\n    {{ foo }}\n  `\n})\n\n\n\n\nlazy\n also accepts a number value, a millisecond value, that indicates the delay between the last UI interaction and Ractive updating the data. Losing element focus is not required for the update to kick in.\n\n\nvar ractive = Ractive({\n  lazy: 1000,\n  data: { foo: 'bar' },\n  template: `\n    \ninput value=\n{{foo}}\n\n\n    \n!-- Updates 1000ms after the last interaction on input --\n\n    {{ foo }}\n  `\n})\n\n\n\n\nlazy\n is only applicable if \ntwoway\n is \ntrue\n.\n\n\nnestedTransitions\n\n\n(boolean)\n\n\nWhether or not to allow transitions to fire if they are already downstream from a transitioning element. Defaults to \ntrue\n.\n\n\n{{#if outer}}\n  \ndiv fade-in='slow'\n\n    Outer text.\n    {{#if inner}}\n      \ndiv fly-in=\nfast\nInner text.\n/div\n\n    {{/if}}\n  \n/div\n\n{{/if}}\n\n\n\n\nIn this example, if \ninner\n is \ntrue\n when \nouter\n becomes \ntrue\n, then all of the \ndiv\ns will render at the same time. If \nnestedTransitions\n is disabled, then the \nfly\n transition on inner \ndiv\n will not be run, since the \nfade\n will already be running on the outer \ndiv\n.\n\n\nThis can also be controlled per transition using the \nnested\n boolean parameter for transitions:\n\n\ndiv fade-in=\n{ duration: 'slow', nested: false }\n...\n/div\n\n\n\n\n\nnoCssTransform\n\n\n(boolean)\n\n\nPrevents component CSS from being transformed with scoping guids. Defaults to \nfalse\n.\n\n\nnoIntro\n\n\n(boolean)\n\n\nWhether or not to skip intro transitions on initial render. Defaults to \nfalse\n.\n\n\nvar ractive = Ractive({\n  template: '\nul\n{{#items}}\nli fade-in\n{{.}}\n/li\n{{/items}}\n/ul\n',\n  data: { items: [ 'red', 'blue' ] },\n  transitions: {\n    fade ( t, params ) {...}\n  },\n  noIntro: true\n})\n// 'red' and 'blue' list items do not fade in\n\nractive.push( 'items', 'green' )\n// 'green' list item will fade in\n\n\n\n\nnoOutro\n\n\n(boolean)\n\n\nWhether or not to skip outro transitions during an instance unrender. Defaults to \nfalse\n.\n\n\nvar ractive = Ractive({\n  template: '\nul\n{{#items}}\nli fade-out\n{{.}}\n/li\n{{/items}}\n/ul\n',\n  data: { items: [ 'red', 'blue' ] },\n  transitions: {\n    fade ( t, params ) {...}\n  },\n  noOutro: true\n})\n\nractive.pop( 'items' )\n// 'blue' list item will fade out\n\nractive.unrender()\n// 'red' list item will not fade out\n\n\n\n\nobserve\n\n\n(Object\nstring, Function|Object\n)\n\n\nA hash of observers to subscribe during initialization and unsubscribe during teardown. Defaults to \nundefined\n.\n\n\nThe keys of the hash may be any string that is accepted by \nractive.observe()\n, and the values may be either callback functions, as would be passed to \nractive.observe()\n, or objects with a \nhandler\n property that is a callback function. The object form also takes other options that control the behavior of the observer.\n\n\nRactive({\n  // ..\n  observe: {\n    show ( value ) {\n      console.log( `show changed to '${value}'` )\n    },\n    'users.*.name people.*.name': {\n      handler ( value, old, path, idx ) {\n        console.log( `${path} changed to '${value}'` )\n      },\n      init: false,\n      strict: true\n    }\n  }\n})\n\n\n\n\nThe options that may be specified in the object form are (see the \nractive.observe()\n docs for more detailed option descriptions):\n\n\n\n\nhandler (Function)\n: The callback function for the observer.\n\n\nonce (boolean)\n: Use \nractive.observeOnce()\n rather than \nractive.observe()\n to install the observer, meaning the observer is implicitly \ninit: false\n, will only fire for the first change to the observed path, and will by removed after the first change.\n\n\nstrict (boolean)\n: Use strict equality when determining whether or not a value has changed.\n\n\narray (boolean)\n: Use an array observer rather than a plain observer.\n\n\ndefer (boolean)\n: Defer the observer until after the DOM is settled.\n\n\ninit (boolean)\n: Whether or not to fire an initial change event.\n\n\nlinks (boolean)\n: Whether or not to follow links.\n\n\ncontext (any)\n: Context for the callback function.\n\n\nold (Function)\n: Modifier function for the \nold\n value passed to the callback function.\n\n\n\n\nWhen a sublcass created with \nRactive.extend()\n is passed an \nobserve\n hash, then any further subclasses or instances created with an \nobserve\n hash will be combined. Any superclass observers are installed first following the inheritance hierarchy, and finally, any instance observers are installed.\n\n\non\n\n\n(Object\nstring, Function|Object\n)\n\n\nA hash of event listeners to subscribe during initialization and unsubscribe during teardown. Defaults to \nundefined\n.\n\n\nThe keys of the hash may be any string that is accepted by \nractive.on()\n, and the values may be either callback functions, as would be passed to \nractive.on()\n, or objects with a \nhandler\n property that is a callback function. The object form also takes other options that control the behavior of the event handler.\n\n\nRactive({\n  // ...\n  on: {\n    init () {\n      console.log('I will print during init')\n    },\n    '*.somethingHappened': {\n      handler ( ctx ) {\n        console.log('I will fire when this instance or any child component fires an instance event named \nsomethingHappened\n')\n      },\n      once: true\n    }\n  },\n  // ...\n})\n\n\n\n\nThe options that may be specified in the object form are:\n\n\n\n\nhandler (Function)\n: The callback function for the event.\n\n\nonce (boolean)\n: Use \nractive.once()\n rather than \nractive.on()\n to subscribe the listener, meaning that the handler will only be called the first time the event is fired and then it will be unsubscribed.\n\n\n\n\non\n event listeners may subscribe to any instance event, including lifecycle events. When a sublcass created with \nRactive.extend()\n is passed an \non\n hash, then any further subclasses or instances created with an \non\n hash will be combined. Any superclass event handlers are installed first following the inheritance hierarchy, and finally, any instance event handlers are installed.\n\n\noncomplete\n\n\n(Function)\n\n\nA lifecycle event that is called when the instance is rendered and all the transitions have completed.\n\n\nonconfig\n\n\n(Function)\n\n\nA lifecycle event that is called when an instance is constructed and all initialization options have been processed.\n\n\nonconstruct\n\n\n(Function)\n\n\nA lifecycle event that is called when an instance is constructed but before any initialization option has been processed.\n\n\nAccepts the instance's initialization options as argument.\n\n\nondestruct\n\n\n(Function)\n\n\nA lifecycle event that is called when an instance is torn down and any associated transitions are complete.\n\n\nondetach\n\n\n(Function)\n\n\nA lifecycle event that is called whenever \nractive.detach()\n is called.\n\n\nNote that \nractive.insert()\n implicitly calls \nractive.detach()\n if needed.\n\n\noninit\n\n\n(Function)\n\n\nA lifecycle event that is called when an instance is constructed and is ready to be rendered.\n\n\noninsert\n\n\n(Function)\n\n\nA lifecycle event that is called when \nractive.insert()\n is called.\n\n\nonrender\n\n\n(Function)\n\n\nA lifecycle event that is called when the instance is rendered but \nbefore\n transitions start.\n\n\nonteardown\n\n\n(Function)\n\n\nA lifecycle event that is called when the instance is being torn down.\n\n\nonunrender\n\n\n(Function)\n\n\nA lifecycle event that is called when the instance is being undrendered.\n\n\nonupdate\n\n\n(Function)\n\n\nA lifecycle event that is called when \nractive.update()\n is called.\n\n\npartials\n\n\n(Object\nstring, string|Object|Function\n)\n\n\nA map of partials where the key is the partial name and the value is either a template string, a parsed template object or a function that returns any of the previous options. The function form accepts processed \ndata\n and  Parse Object as arguments.\n\n\npartials: {\n  stringPartial: '\np\n{{greeting}} world!\n/p\n',\n  parsedPartial: {\nv\n:3,\nt\n:[{\nt\n:7,\ne\n:\np\n,\nf\n:[{\nt\n:2,\nr\n:\ngreeting\n},\n world!\n]}]},\n  functionPartial (data, p) {\n    return data.condition ? '\np\nhello world\n/p\n' : '\ndiv\nyes, we have no foo\n/div\n'\n  }\n}\n\n\n\n\nDuring a \nractive.reset()\n, function partials are re-evaluated. If the return value changes, the Ractive instance will be re-rendered.\n\n\npreserveWhitespace\n\n\n(boolean|Object\nstring, boolean\n)\n\n\nWhether or not to preserve whitespace in templates when parsing. Defaults to \nfalse\n.\n\n\nWhitespace in \npre\n elements is always preserved. The browser will still deal with whitespace in the normal fashion.\n\n\nIf the value is a map, whitespace is not preserved by default, and the elements named in the map will have whitespace preserved based on the value of the boolean associated with their name.\n\n\nvar ractive = Ractive({\n  template: '\np\nhello\\n\\n  \\tworld   \n/p\n',\n  preserveWhitespace: false //default\n})\n\nconsole.log( ractive.toHTML() )\n// \np\nhello world\n/p\n\n\nvar ractive = Ractive({\n  template: '\np\nhello\\n\\n  \\tworld   \n/p\n',\n  preserveWhitespace: true\n})\n\nconsole.log( ractive.toHTML() )\n//\np\nhello\n//\n//  world   \n/p\n\n\n\n\n\nresolveInstanceMembers\n\n\n(boolean)\n\n\nWhether or not to include members of the Ractive instance at the end of the reference resolution process. Defaults to \nfalse\n.\n\n\nPrior to \n0.10.0\n defaults to \ntrue\n.\n\n\nbutton on-click=\ntoggle('show')\nToggle\n/button\n\n\n\n\n\nIf there is no data member \ntoggle\n in the context of the template, with \nresolveInstanceMembers\n enabled, the reference will resolve to the \nractive.toggle()\n method of the instance.\n\n\nsanitize\n\n\n(boolean|Object)\n\n\nWhether or not certain elements will be stripped from the template during parsing.  Defaults to \nfalse\n.\n\n\ntrue\n strips out blacklisted elements and event attributes. See \nRactive.parse()\n for the default list of blacklisted elements.\n\n\ntemplate: `\n  \np\nsome content\n/p\n\n  \nframe\nAm I a bad element or just misunderstood?\n/frame\n\n`,\nsanitize: true\n\n// result:\n// \np\nsome content\n/p\n\n\n\n\n\nThe object form should have \nelements\n which is an array of blacklisted elements and \neventAttributes\n boolean which, when \ntrue\n, also strips out event attributes.\n\n\ntemplate: `\n  \np\nsome content\n/p\n\n  \ndiv onclick=\ndoEvil()\nthe good stuff\n/div\n\n`,\nsanitize: {\n  elements: [ 'p' ],\n  eventAttributes: true\n}\n\n// result:\n// \ndiv\nthe good stuff\n/div\n\n\n\n\n\nstaticDelimiters\n\n\n(Array[string])\n\n\nSets the static (one-time binding) delimiters. Defaults to \n[ '[[', ']]' ]\n.\n\n\nvar ractive = Ractive({\n  template: 'hello [[foo]]',\n  staticDelimiters: [ '[[', ']]' ], //default\n  data: { foo: 'world' }\n})\n// result: \nhello world\n\n\nractive.set( 'foo', 'mars' )\n// still is: \nhello world\n\n\n\n\n\nstaticTripleDelimiters\n\n\n(Array\nstring\n)\n\n\nSets the static (one-time binding) triple delimiters. Defaults to \n[ '[[[', ']]]' ]\n.\n\n\nvar ractive = Ractive({\n  template: 'hello [[[html]]]',\n  staticTripleDelimiters: [ '[[[', ']]]' ], //default\n  data: { html: '\nspan\nworld\n/span\n' }\n})\n// result: \nhello \nspan\nworld\n/span\n\n\nractive.set( 'html', '\nspan\nmars\n/span\n' )\n// still is: \nhello world\n\n\n\n\n\nstripComments\n\n\n(boolean)\n\n\nWhether or not to remove comments in templates when parsing. Defaults to \ntrue\n.\n\n\ntemplate: '\n!-- html comment --\nhello world',\nstripComments: false\n\n// result:\n// \n!-- html comment --\nhello world\n\n\n\n\nsyncComputedChildren\n\n\n(boolean)\n\n\nWhether or not to invalidate the dependencies of an expression when child keypaths of the expression are updated. Defaults to \nfalse\n. \nNote\n: setting this to \ntrue\n may cause performance issues for complex expressions involving large arrays.\n\n\ninput value=\n{{pattern}}\n /\n\n{{#each filter(users, pattern)}}\n  \ninput value=\n{{.name}}\n /\n\n{{/each}}\n\n\n\n\nIn this example, the \ninput\n inside the iteration is bound to a computation e.g. \nfilter(users, pattern).0.name\n that isn't actually an addressable model. With \nsyncComputedChildren\n enabled, when that virtual keypath is updated by a user changing the \ninput\n, the expression will invalidate its dependencies (\nfilter\n, \nusers\n, and \npattern\n), which will cause any other references to the \nuser\n that happens to coincide with result of the expression to also update.\n\n\ntarget\n\n\n(string|HTMLElement|array-like)\n\n\nAlias for \nel\n.\n\n\ntemplate\n\n\n(string|array|object|function)\n\n\nThe template to use. Must either be a CSS selector string pointing to an element on the page containing the template, an HTML string, an object resulting from \nRactive.parse()\n or a function that returns any of the previous options. The function form accepts processed \ndata\n and a Parse Object.\n\n\n// Selector\ntemplate: '#my-template',\n\n// HTML\ntemplate: '\np\n{{greeting}} world!\n/p\n',\n\n// Template AST\ntemplate: {\nv\n:3,\nt\n:[{\nt\n:7,\ne\n:\np\n,\nf\n:[{\nt\n:2,\nr\n:\ngreeting\n},\n world!\n]}]},\n\n// Function\ntemplate (data, p) {\n  return '\np\n{{greeting}} world!\n/p\n'\n},\n\n\n\n\nDuring a \nractive.reset()\n, templates provided using a function are re-evaluated. If the return value changes, the Ractive instance will be re-rendered.\n\n\ntransitions\n\n\n(Object\nstring, Function\n)\n\n\nA map of transitions where the key is the name of the transition and the value is a transition definition.\n\n\ntransitionsEnabled\n\n\n(boolean)\n\n\nWhether or not transitions are enabled. Defaults to \ntrue\n.\n\n\ntripleDelimiters\n\n\n(Array[string])\n\n\nSets the triple delimiters. Defaults to \n[ '{{{', '}}}' ]\n.\n\n\ntemplate: 'hello @html@',\ntripleDelimiters: [ '@', '@' ],\ndata: { html: '\nspan\nworld\n/span\n' }\n\n// result:\n// hello \nspan\nworld\n/span\n\n\n\n\n\ntwoway\n\n\n(boolean)\n\n\nWhether or not two-way binding is enabled. Defaults to \ntrue\n.\n\n\nvar ractive = Ractive({\n  template: '\ninput value=\n{{foo}}\n',\n  data: { foo: 'bar' },\n  twoway: false\n})\n\n// user types \nfizz\n into \ninput\n, but data value is not changed:\n\nconsole.log( ractive.get( 'foo' ) ); //logs \nbar\n\n\n// updates from the model are still pushed to the view\n\nractive.set( 'foo', 'fizz' )\n\n// input now displays \nfizz\n\n\n\n\n\nuse\n\n\n([plugin])\n\n\nAn array of plugins to install on the instance or component. This is more or less a shorthand for calling the \nuse\n method on a component or instance.\n\n\nimport neato from 'some/neato/plugin';\nimport thingy from 'thingy/plugin';\n\n// install a plugin in a component\nconst Component = Ractive.extend({\n  use: [neato]\n});\n\n// install a plugin in an instance\nconst app = window.app = new Component({\n  use: [thingy]\n});\n\n\n\n\nwarnAboutAmbiguity\n\n\n(boolean)\n\n\nWhether or not to warn about references that don't resolve to their immediate context. Defaults to \nfalse\n.\n\n\nAmbiguous references can be the cause of some strange behavior when your data changes structure slightly. With \nwarnAboutAmbiguity\n enabled, Ractive will warn you any time a reference isn't scoped and resolves in a context above the immediate context of the reference.\n\n\nStatic Properties\n\n\nRactive.adaptors\n\n\n(Object\nstring, Object\n)\n\n\nThe registry of globally available adaptors.\n\n\nRactive.components\n\n\n(Object\nstring, Function\n)\n\n\nThe registry of globally available component definitions.\n\n\nRactive.Context\n\n\nFrom 0.9.4\n\n\n(Object)\n\n\nThe prototype for \nContext\n objects. This is provided so that you can extend context objects provided by Ractive with your own methods and properties.\n\n\n[Component].css\n\n\nFrom 0.10.0\n\n\n(string|(CSSData) =\n string)\n\n\nThe CSS string or function that is set on the constructor. Setting this will cause the CSS for the component in the Rative-managed \nstyle\n element to be updated.\n\n\nRactive.DEBUG\n\n\n(boolean)\n\n\nTells Ractive if it's in debug mode or not. When set to \ntrue\n, non-fatal errors are logged. When set to \nfalse\n, non-fatal errors are suppressed. By default, this is set to \ntrue\n.\n\n\nRactive.DEBUG_PROMISES\n\n\n(boolean)\n\n\nTells Ractive to log errors thrown inside promises. When set to \ntrue\n, errors thrown in promises are logged. When set to \nfalse\n, errors inside promises are suppressed. By default, this is set to \ntrue\n.\n\n\nRactive.decorators\n\n\n(Object\nstring, Function\n)\n\n\nThe registry of globally available decorators.\n\n\nRactive.defaults\n\n\n(Object\nstring, any\n)\n\n\nGlobal defaults for initialisation options with the exception of plugin registries.\n\n\n// Change the default mustache delimiters to [[ ]] globally\nRactive.defaults.delimiters = [ '[[', ']]' ]\n\n// Future instances now use [[ ]]\nractive1 = Ractive({\n    template: 'hello [[world]]'\n})\n\n\n\n\nDefaults can be specified for a subclass of Ractive, overriding global defaults.\n\n\nvar MyRactive = Ractive.extend()\n\nMyRactive.defaults.el = document.body\n\n\n\n\nConfiguration on the instance overrides subclass and global defaults.\n\n\nRactive.defaults.delimiters = [ '[[', ']]' ]\n\n// Uses the delimiters specified above\nRactive({\n  template: 'hello [[world]]'\n})\n\n// Uses the delimiters specified in the init options\nRactive({\n  template: 'hello //world\\\\',\n  delimiters: [ '//', '\\\\' ]\n})\n\n\n\n\nGlobal data attributes may be specified:\n\n\nRactive.defaults.data.people = [{id:4, name:'Fred'},{id:5, name:'Wilma'},...]\n\n//or alternatively:\nObject.assign(Ractive.defaults.data,{people : [{id:4, name:'Fred'},{id:5, name:'Wilma'},...],\n                                     title : 'Flintstones',\n                                     producer : 'Hanna-Barbera'})\n\n// (Object.assign is provided as a polyfill by Ractive if it's not supported by the browser)\n\n\n\n\nThe data attributes and values are then accessible in all components. Data attributes specified in this way, however, do \nnot\n trigger an automatic component update if the attribute value is changed after the component is instantiated.\n\n\nRactive.easing\n\n\n(Object\nstring, Function\n)\n\n\nThe global registry of easing functions.\n\n\nThe easing functions are used by the \nractive.animate\n method and by transitions. Four are included by default: \nlinear\n, \neaseIn\n, \neaseOut\n and \neaseInOut\n.\n\n\nRactive.events\n\n\n(Object\nstring, Function\n)\n\n\nThe global registry of custom event plugins.\n\n\nRactive.interpolators\n\n\n(Object\nstring, Function\n)\n\n\nA key-value hash of interpolators use by \nractive.animate()\n or non-CSS transitions.\n\n\n[Component].Parent\n\n\nFrom 0.9.1\n\n\n(Ractive|Component constructor)\n\n\nThe parent constructor of a component.\n\n\nconst MyComponent = Ractive.extend()\nconst MySpecialComponent = MyComponent.extend()\n\nMyComponent.Parent === Ractive; // true\nMySpecialCompoennt.Parent === MyComponent; // true\n\n\n\n\nRactive.partials\n\n\n(Object\nstring, string|Object|Function\n)\n\n\nThe global registry of partial templates.\n\n\nLike templates, partials are parsed at the point of use. The parsed output is cached and utilized for future use.\n\n\n[Component].Ractive\n\n\nFrom 0.9.1\n\n\n(Ractive)\n\n\nThe root Ractive constructor that is the first ancestor of this component.\n\n\nconst MyComponent = Ractive.extend()\nconst MySpecialComponent = MyComponent.extend()\n\nMyComponent.Ractive === Ractive; // true\nMySpecialCompoennt.Ractive === Ractive; // true\n\n\n\n\nRactive.svg\n\n\n(boolean)\n\n\nIndicates whether or not the browser supports SVG.\n\n\nRactive.transitions\n\n\n(Object\nstring, Function\n)\n\n\nThe global registry of transition functions.\n\n\nRactive.VERSION\n\n\n(string)\n\n\nThe version of the currently loaded Ractive.\n\n\nStatic Methods\n\n\nRactive.addCSS()\n\n\nFrom 0.10.0\n\n\nAdd CSS to the Ractive-managed \nstyle\n tag. This is particularly useful for plugins that aren't based on a component or macro. If you try to add the same \nid\n more than once, an error will be thrown.\n\n\nSyntax\n\n\n\n\nRactive.addCSS(id, css)\n\n\n\n\nArguments\n\n\n\n\nid (string)\n: An identifier for the styles.\n\n\ncss (string|(CSSData) =\n string)\n: A string of CSS or a function that receives CSS data (see \nRactive.styleSet\n) and returns a string of CSS.\n\n\n\n\nExample\n\n\nRactive.addCSS(\n  'fancy-buttons',\n  `button {\n    border-radius: 0.2em;\n    outline: 3px red;\n    color: blue;\n    background-color: yellow;\n    animation: buttonblink 1s linear infinite;\n    box-shadow: 2px 2px 5px rgba(0, 255, 255, 0.5);\n  }\n  @keyframes buttonblink {\n    50% {\n      color: transparent;\n    }\n  }`\n);\n\n\n\n\nRactive.escapeKey()\n\n\nEscapes the given key so that it can be concatenated with a keypath string.\n\n\nSyntax\n\n\n\n\nRactive.escapeKey(key)\n\n\n\n\nArguments\n\n\n\n\nkey (string)\n: The key to escape.\n\n\n\n\nReturns\n\n\n\n\n(string)\n: The escaped key.\n\n\n\n\nExamples\n\n\nExample 1\n\n\nRactive.escapeKey('foo.bar'); // 'foo\\\\.bar'\n\n\n\n\nExample 2\n\n\n\n\n\nRactive({\n    ...\n  on:{\n    changeUrl () {\n      this.set('img.a\\\\.jpg.url', \n/my/new/path.jpg\n)\n    },\n    changeUrl2 () {\n      mykey = 'a.jpg'\n      this.set('img.' + Ractive.escapeKey(mykey) + '.url', \n/the/other/path.jpg\n)\n    }\n  },\n  data: {\n    img: {\n      'a.jpg': {\n        url: \n/path/to/a.jpg\n\n      }\n    }\n  }\n})\n\n\n\n\nRactive.extend()\n\n\nCreates a \"subclass\" of the Ractive constructor or a subclass constructor. See \nComponents\n for an in-depth discussion on the use of \nRactive.extend\n.\n\n\nSyntax\n\n\n\n\nRactive.extend([options[, ...optionsN]])\n\n\n\n\nArguments\n\n\n\n\noptions] (Object)\n: One or more objects that represent the defaults for instances of the subclass, with the latter objects' properties taking precedence over the former. See [Initialization Options for a list of possible options.\n\n\n\n\nReturns\n\n\n\n\n(Function)\n: The subclass constructor function.\n\n\n\n\nExamples\n\n\nconst SubClass = Ractive.extend({\n    template: '\ndiv\n{{message}}\n/div\n',\n    data: {\n        message: 'Hello World!'\n    }\n})\n\n// \ndiv\nHello World!\n/div\n\nconst instance1 = SubClass({\n    el: '.div1'\n})\n\n// \ndiv\nLorem Ipsum\n/div\n\nconst instance2 = SubClass({\n    el: '.div2',\n    data: {\n        message: 'Lorem Ipsum'\n    }\n})\n\n\n\n\nRactive.extendWith()\n\n\nCreates a \"subclass\" of the Ractive constructor or a subclass constructor using an existing constructor. The constructor will be augmented with static methods like \nextend\n, and it will also process the given initialization options.\n\n\nSyntax\n\n\n\n\nRactive.extendWith(constructor[, options])\n\n\n\n\nArguments\n\n\n\n\nconstructor (Function)\n: A class constructor - like an ES6 \nclass\n, a plain JavaScript function with a prototpye, or another similarly constructed function (TypeScript, CoffeeScript, etc).\n\n\noptions (Object)\n: An object with initialization options as properties. See initialization options for a list of possible options.\n\n\n\n\nReturns\n\n\n\n\n(Function)\n: The augmented constructor function.\n\n\n\n\nExamples\n\n\nclass Widget extends Ractive {\n  notify ( message ) {\n    this.push( 'messages', message )\n  }\n\n  show () {\n    this.set( 'visible', true )\n  }\n\n  hide () {\n    this.set( 'visible', false )\n  }\n}\n\nRactive.extendWith( Widget, {\n  template: '{{#if visible}}\nul\n{{#each messages}}\nli\n{{.}}\n/li\n{{/each}}\n/ul\n{{/if}}'\n})\n\n\n\n\nRactive.getCSS()\n\n\nReturns the scoped CSS from Ractive subclasses defined at the time of the call.\n\n\nIf used without arguments, it will return the scoped CSS of all subclasses. If provided an array of scoping IDs, it will return the scoped CSS of all subclasses whose scoping ID is included in the array.\n\n\nSyntax\n\n\n\n\nRactive.getCSS([key])\n\n\n\n\nArguments\n\n\n\n\n[key] (Array\nstring\n)\n: Subclass CSS scoping ID.\n\n\n\n\nReturns\n\n\n\n\n(string)\n: The scoped CSS.\n\n\n\n\nExamples\n\n\n// Assuming the generated ID for this subclass is 'xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx'.\nconst Subclass1 = Ractive.extend({\n    ...\n    css: 'div{ color: red }'\n    ...\n})\n\n// Assuming the generated ID for this subclass is 'yyyyyyyy-yyyy-yyyy-yyyy-yyyyyyyyyyyy'.\nconst Subclass2 = Ractive.extend({\n    ...\n    css: 'div{ color: green }'\n    ...\n})\n\n// CSS contains the scoped versions of div{ color: red } and div{ color: green }.\nconst css = Ractive.getCSS()\n\n// css contains the scoped version of div{ color: red } only.\nconst css = Ractive.getCSS([ 'xxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx' ])\n\n\n\n\n\nRactive.getContext()\n\n\nAccepts a node and returns a Context object containing details of the Ractive instance the node is associated to.\n\n\nSyntax\n\n\n\n\nRactive.getContext(node)\n\n\n\n\nArguments\n\n\n\n\nnode (string|Node)\n: The DOM node or a CSS selector of the DOM node for which you wish to retrieve the Ractive instance or view details.\n\n\n\n\nReturns\n\n\n\n\n(Context)\n: A context object.\n\n\n\n\nExamples\n\n\nconst info = Ractive.getContext(document.getElementById('some-node'))\n\nconst info = Ractive.getContext('#some-node')\n\n\n\n\nRactive.hasCSS()\n\n\nFrom 0.10.0\n\n\nDetermines whether or not CSS has been added with the given \nid\n.\n\n\nSyntax\n\n\n\n\nRactive.hasCSS(id)\n\n\n\n\nArguments\n\n\n\n\nid (string)\n: The id to check.\n\n\n\n\nReturns\n\n\n\n\n(boolean)\n: \ntrue\n if there is already CSS installed with the given \nid\n.\n\n\n\n\nRactive.isInstance()\n\n\nFrom 0.9.1\n\n\nDetermines whether or not the given object is an instance of the Ractive constructor. This is also extended to component constructors, where it will make sure that the given object is an instance of the particular constructor on which it is called.\n\n\nSyntax\n\n\n\n\nRactive.isInstance(obj)\n\n\n\n\nArguments\n\n\n\n\nobj (any)\n: The thing to check.\n\n\n\n\nReturns\n\n\n\n\nboolean\n\n\n\n\nExamples\n\n\nconst MyComponent = Ractive.extend()\nconst MySpecialComponent = MyComponent.extend()\nconst OtherComponent = Ractive.extend()\n\nconst r = new MySpecialCompoennt()\n\nMySpecialComponent.isInstance(r); // true\nMyComponent.isInstance(r); // true\nOtherComponent.isIstance(r); // false\n\nRactive.isInstance(r); //true\n\n\n\n\nRactive.joinKeys()\n\n\nJoins the given keys into a properly escaped keypath.\n\n\nSyntax\n\n\n\n\nRactive.joinKeys(key1 [, ...keyN])\n\n\n\n\nArguments\n\n\n\n\nkey (string)\n: One or more strings to join.\n\n\n\n\nReturns\n\n\n\n\n(string)\n: A properly joined and escaped keypath.\n\n\n\n\nExamples\n\n\nRactive.joinKeys( 'foo', 'bar.baz' ); // foo.bar\\.baz\n\n\n\n\nRactive.macro()\n\n\nCreates a macro partial with the given handler and options. Macro partials sit somewhere between regular partials and components in power and heft. Many things that can't be achieved with regular parials, like adding styles to the managed CSS, easily managing template-local data, and mangling templates before render, can be with macros. Some of the things that can be achieved with components, like having namespaced events and a fully isolated data context, can't be with macros.\n\n\nMacros also have the ability to swap templates at any point in time, like a dynamic partial. Instead of responding to a change in a model though, there is a helper function, \nsetTemplate\n, on the context handle passed to the macro init function.\n\n\nSyntax\n\n\n\n\nRactive.macro(handler [, options])\n\n\n\n\nArguments\n\n\n\n\n\n\nhandler ((context, ...attributes) =\n handle)\n: The defining function for the macro.\n\n\nThe context that is passed into the handler is augmented with a few extra properties and methods.\n\n\nProperties\n\n\n\n\nattributes (Object\nstring, any\n)\n: The map of current attribute values, if any.\n\n\nname\n: The name with which this macro was created in the template.\n\n\npartials\n: A shallow copy of any partials associated with the macro, including \ncontent\n.\n\n\nproxy\n: The VDOM node that is managing the macro.\n\n\ntemplate\n: A shallow copy of the template used to create the macro.\n\n\n\n\nMethods\n\n\n\n\naliasLocal(name [, keypath])\n: Creates an alias to the \n@local\n data associated with the proxy.\n\n\nname (string)\n: The name to use when creating the alias.\n\n\nkeypath (string)\n: If supplied the child keypath of the \n@local\n data to use when creating the alias.\n\n\n\n\n\n\nsetTemplate(template)\n: Sets the template to be rendered in the DOM. This can be called at any time to cause the template to be re-rendered.\n\n\ntemplate\n: This can be any of the values that can be used with a partial. If the template is not parsed and the parser is not available, an error will be thrown.\n\n\n\n\n\n\n\n\nReturn\n\n\nThe handler function can optionally return an object with local lifecycle hooks, much like a decorator:\n\n\n\n\nrender\n: A function to be called when the macro is rendered.\n\n\nupdate\n: A function to be called when the attributes of the macro are updated.\n\n\ninvalidate\n: A function to be called when an part of the template that is controlled by the macro will be updated.\n\n\nteardown\n: A function to be called when the macro is unrendered.\n\n\n\n\n\n\n\n\noptions\n: An optional map of options to use when creating the macro.\n\n\n\n\nattributes (string[])\n: A list of reserved attributes that will be passed to the handler function and optional \nupdate\n hook.\n\n\ncss (string|(data) =\n string)\n: A CSS string or CSS function to set the managed CSS for the macro.\n\n\ncssData (object)\n: Initial CSS data to be passed to a CSS function.\n\n\ncssId (string)\n: An optional id to use when scoping CSS for the macro.\n\n\nnoCssTransform (boolean)\n: If \ntrue\n, macro CSS will not be scoped.\n\n\n\n\n\n\n\n\nReturns\n\n\n\n\n(macro)\n: A macro that can be installed in a \npartials\n registry.\n\n\n\n\nRactive.parse()\n\n\nParses the template into an abstract syntax tree that Ractive can work on.\n\n\nSyntax\n\n\n\n\nRactive.parse(template[, options])\n\n\n\n\nArguments\n\n\n\n\ntemplate (string)\n: A Ractive-compliant HTML template.\n\n\n[options] (Object)\n: Parser options.\n\n\n[delimiters] ([string])\n: Start and end delimiters for normal mustaches. Defaults to \n['{{', '}}']\n.\n\n\n[tripleDelimiters] ([string])\n: Start and end delimiters for triple mustaches. Defaults to \n['{{{', '}}}']\n.\n\n\n[staticDelimiters] ([string])\n: Start and end delimiters for static mustaches. Defaults to \n['[[', ']]']\n.\n\n\n[staticTripleDelimiters] ([string])\n: Start and end delimiters for static triple mustaches. Defaults to \n['[[[', ']]]']\n.\n\n\n[contextLines] (integer)\n: Additional lines above and below a line with a parse error to include in the error output. Defaults to \n0\n.\n\n\n[interpolate] (Object\nstring, boolean\n)\n: Map of elements that indicates whether or not to read mustaches within the element. Defaults to \n{ script: false, textarea: true, template: false, style: false }\n. Elements present within the map treat nested tags as text rather than elements.\n\n\n[csp] (boolean)\n: When \ntrue\n includes pre-compiled expression functions in the template output so that \neval\n is not needed at runtime. Defaults to \ntrue\n.\n\n\n[preserveWhitespace] (boolean|Object\nstring, boolean\n)\n: When \ntrue\n, preserves whitespace in templates. Whitespace inside the \npre\n element is preserved regardless of the value of this option. Defaults to \nfalse\n. If the value is a map, whitespace is not preserved by default, and the elements named in the map will have whitespace preserved based on the value of the boolean associated with their name.\n\n\n[stripComments] (boolean)\n: When \nfalse\n will leave comments in the parsed template. Defaults to \ntrue\n.\n\n\n[sanitize] (boolean|Object)\n: When \ntrue\n, strips inline event attributes and certain elements from the markup. Defaults to \nfalse\n.\n\n\n[elements] (Array\nstring\n)\n: An array of element names to blacklist.\n\n\n[eventAttributes] (boolean)\n: When \ntrue\n, strips off inline event attributes.\n\n\n\n\n\n\n[includeLinePositions] (boolean)\n: When \ntrue\n will include line positions on each node of the parser output. Defaults to \nfalse\n.\n\n\n[textOnlyMode] (boolean)\n: When \ntrue\n parses elements as text rather than elements. This is useful for generating raw HTML from a template, more like a plain text templating processor. Defaults to \nfalse\n.\n\n\n[transforms|parserTransforms] ([Function])`: An array of post-parsing transforms to apply to the output parser AST.\n\n\n\n\n\n\n\n\nWhen \nsanitize\n is \ntrue\n, the following elements are stripped:\n\n\n\n\napplet\n\n\nbase\n\n\nbasefont\n\n\nbody\n\n\nframe\n\n\nframeset\n\n\nhead\n\n\nhtml\n\n\nisindex\n\n\nlink\n\n\nmeta\n\n\nnoframes\n\n\nnoscript\n\n\nobject\n\n\nparam\n\n\nscript\n\n\nstyle\n\n\ntitle\n\n\n\n\nReturns\n\n\n\n\n(Object)\n - The object representation of the provided markup.\n\n\n\n\nExamples\n\n\nAssume the following markup.\n\n\ndiv class='gallery'\n\n  {{#each items}}\n    \n!-- comments get stripped out of the template --\n\n    \nfigure on-tap='select' staggered-in\n\n      \nimg class='thumbnail' src='assets/images/{{id}}.jpg'\n\n      \nfigcaption\n{{( @index+1 )}}: {{description}}\n/figcaption\n\n    \n/figure\n\n  {{/each}}\n\n/div\n\n\n\n\n\nRactive.parse( template );\n will yield the following output:\n\n\n{\nv\n:4,\nt\n:[{\nt\n:7,\ne\n:\ndiv\n,\nm\n:[{\nn\n:\nclass\n,\nf\n:\ngallery\n,\nt\n:13}],\nf\n:[{\nt\n:4,\nf\n:[\n \n,{\nt\n:7,\ne\n:\nfigure\n,\nm\n:[{\nn\n:[\ntap\n],\nt\n:70,\nf\n:\nselect\n},{\nn\n:\nstaggered\n,\nt\n:72,\nv\n:\nt1\n}],\nf\n:[{\nt\n:7,\ne\n:\nimg\n,\nm\n:[{\nn\n:\nclass\n,\nf\n:\nthumbnail\n,\nt\n:13},{\nn\n:\nsrc\n,\nf\n:[\nassets/images/\n,{\nt\n:2,\nr\n:\nid\n},\n.jpg\n],\nt\n:13}]},\n \n,{\nt\n:7,\ne\n:\nfigcaption\n,\nf\n:[{\nt\n:2,\nx\n:{\nr\n:[\n@index\n],\ns\n:\n_0+1\n}},\n: \n,{\nt\n:2,\nr\n:\ndescription\n}]}]}],\nn\n:52,\nr\n:\nitems\n}]}],\ne\n:{'_0+1': function(_0) { return _0+1; }}}\n\n\n\n\nRactive.splitKeypath()\n\n\nSplits the given keypath into an array of unescaped keys.\n\n\nSyntax\n\n\n\n\nRactive.splitKeypath(keypath)\n\n\n\n\nArguments\n\n\n\n\nkeypath (string)\n: The keypath to split into keys.\n\n\n\n\nReturns\n\n\n\n\n(Array)\n: Returns an array of unescaped keys.\n\n\n\n\nExamples\n\n\nRactive.splitKeypath( 'foo.bar\\\\.baz' ); // [ 'foo', 'bar.baz' ]\n\n\n\n\nRactive.sharedSet()\n\n\nFrom 0.9.4\n\n\nSets data in the \n@shared\n object without requiring access to a Ractive instance.\n\n\nSyntax\n\n\n\n\nRactive.sharedSet(keypath, value, options)\n\n\nRactive.sharedSet(hash, options)\n\n\n\n\nArguments\n\n\nArguments are the same as would be supplied to \nractive.set\n.\n\n\nReturns\n\n\n\n\n(Promise)\n: Returns a promise that resolves when any transitions associated with the change have completed.\n\n\n\n\nExamples\n\n\nRactive.sharedSet( '_', lodash )\n\n\n\n\nRactive.styleSet()\n\n\nFrom 0.9.4\n\n\nSets data in the \n@style\n object of Ractive or the component constructor on which it is called. When an applied style that is affected by a change from \nstyleSet\n updates, Ractive will update its manaaged style tag so that the changes show up in the browser immediately.\n\n\nThis function is also available to components created with \nRactive.extend\n. When called on a component constructor, \nstyleSet\n will set the value in the component's \ncssData\n, and any extensions of the component will also be notified that the parent data changed.\n\n\nSyntax\n\n\n\n\nRactive.styleSet(keypath, value, options)\n\n\nRactive.styleSet(hash, options)\n\n\n\n\nArguments\n\n\nArguments are the same as would be supplied to \nractive.set\n with an addition to the \noptions\n hash:\n\n\n\n\napply (boolean)\n: Whether or not to apply any affected styles now. Defaults to \ntrue\n.\n\n\n\n\nReturns\n\n\n\n\n(Promise)\n: Returns a promise that resolves when any transitions associated with the change have completed.\n\n\n\n\nExamples\n\n\nRactive.styleSet( 'colors.fg', '#000' )\n\n\n\n\nRactive.unescapeKey()\n\n\nUnescapes the given key e.g. \nfoo\\\\.bar\n =\n \nfoo.bar\n.\n\n\nSyntax\n\n\n\n\nRactive.unescapeKey(key)\n\n\n\n\nArguments\n\n\n\n\nkey (string)\n: The key to unescape.\n\n\n\n\nReturns\n\n\n\n\n(string)\n: The unescaped key.\n\n\n\n\nExamples\n\n\nRactive.unescapeKey('foo\\\\.bar'); // foo.bar\n\n\n\n\nRactive.use()\n\n\nFrom 0.10.0\n\n\nInstall one or more plugins globally or in a component constructor. If called on a component constructor (the result of \nextend\n), the plugin will be called with the construtor as the \ninstance\n argument and the constructor prototype as the \nproto\n argument, so anything added to the \ninstance\n or \nproto\n will be available to all instances and sub-components of the component.\n\n\nSyntax\n\n\n\n\nRactive.use(plugin[, ...plugin])\n\n\n\n\nArguments\n\n\n\n\nplugin (plugin)\n: A plugin function that receives \n{ Ractive, instance: Ractive, proto: Ractive.defaults }\n as an argument.\n\n\n\n\nReturns\n\n\n\n\n(this)\n: The component on which the method was called.\n\n\n\n\nInstance Properties\n\n\nractive.adaptors\n\n\n(Object\nstring, Object\n)\n\n\nThe instance-only registry of adaptors.\n\n\nractive.components\n\n\n(Object\nstring, Function\n)\n\n\nThe instance-only registry of components.\n\n\nractive.container\n\n\n(Ractive)\n\n\nEach component instance that is in a yielded fragment has a container instance that is accessible using \nthis.container\n.\n\n\nfoo\n\n  \nbar\n\n    \nbaz /\n\n  \n/bar\n\n\n/foo\n\n\n\n\n\nIf \nbar\n \n{{yield}}\ns, then \nbaz\n's container will be the \nfoo\n instance.\n\n\nractive.decorators\n\n\n(Object\nstring, Function\n)\n\n\nThe instance-only registry of decorators.\n\n\nractive.easing\n\n\n(Object\nstring, Function\n)\n\n\nThe instance-only registry of easing functions.\n\n\nractive.events\n\n\n(Object\nstring, Function\n)\n\n\nThe instance-only registry of custom event plugins.\n\n\nractive.interpolators\n\n\n(Object\nstring, Function\n)\n\n\nA key-value hash of interpolators use by \nractive.animate()\n or non-CSS transitions.\n\n\nractive.parent\n\n\n(Ractive)\n\n\nEach component instance can access its parent using \nthis.parent\n.\n\n\nfoo\n\n  \nbar\n\n    \nbaz /\n\n  \n/bar\n\n\n/foo\n\n\n\n\n\nbaz\n's parent is the \nbar\n instance, and \nbar\n's parent is the \nfoo\n instance.\n\n\nractive.partials\n\n\n(Object\nstring, string|Object|Function\n)\n\n\nThe instance-only registry of partials.\n\n\nractive.root\n\n\n(Ractive)\n\n\nEach component instance can access its root Ractive instance using \nthis.root\n.\n\n\nfoo\n\n  \nbar\n\n    \nbaz /\n\n  \n/bar\n\n\n/foo\n\n\n\n\n\nfoo\n, \nbar\n, and \nbaz\n will all have the Ractive instance with this template as their \nroot\n.\n\n\nractive.transitions\n\n\n(Object\nstring, Function\n)\n\n\nThe instance-only registry of transitions.\n\n\nInstance Methods\n\n\nractive._super()\n\n\nCalls the parent method from a child method of the same name.\n\n\nractive._super()\n is not always available. Only when Ractive detects its use does it make this reference to the parent method.\n\n\nSyntax\n\n\n\n\nractive._super([arg[, ...argN]])\n\n\n\n\nArguments\n\n\n\n\n[arg] (any)\n: One or more arguments to pass to the function.\n\n\n\n\nReturns\n\n\n\n\n(any)\n: Depends on the method called.\n\n\n\n\nExamples\n\n\n\n\n\nvar Component = Ractive.extend({\n  oninit () {\n    console.log('super init')\n  }\n})\n\nvar SubComponent = Component.extend({\n  oninit () {\n    this._super()\n    console.log('sub init')\n  }\n})\n\nnew SubComponent()\n\n\n\n\nractive.add()\n\n\nIncrements the selected keypath.\n\n\nSyntax\n\n\n\n\nractive.add(keypath[, number])\n\n\n\n\nArguments\n\n\n\n\nkeypath (string)\n: The keypath of the number we're incrementing.\n\n\n[number] (number)\n: The number to increment by. Defaults to \n1\n.\n\n\n\n\nReturns\n\n\n\n\n(Promise)\n: A promise that resolves when any transitions associated with the operation complete.\n\n\n\n\nExamples\n\n\n\n\n\nvar r = Ractive({\n  el: '#main',\n  template: '#tpl',\n  data: {\n    counter: 0\n  }\n})\n\nsetTimeout(() =\n {\n  r.add('counter')\n  console.log(r.get('counter'))\n}, 1000)\n\nsetTimeout(() =\n {\n  r.add('counter', 10)\n  console.log(r.get('counter'))\n}, 2000)\n\n\n\n\nractive.animate()\n\n\nSimilar to \nractive.set()\n, this will update the data and re-render any affected mustaches and notify observers.\n\n\nAll animations are handled by a global timer that is shared between Ractive instances (and which only runs if there are one or more animations still in progress), so you can trigger as many separate animations as you like without worrying about timer congestion. Where possible, \nrequestAnimationFrame\n is used rather than \nsetTimeout\n.\n\n\nNumeric values and strings that can be parsed as numeric values can be interpolated. Objects and arrays containing numeric values (or other objects and arrays which themselves contain numeric values, and so on recursively) are also interpolated.\n\n\nNote that there is currently no mechanism for detecting cyclical structures! Animating to a value that indirectly references itself will cause an infinite loop.\n\n\nFuture versions of Ractive may include string interpolators - e.g. for SVG paths, colours, transformations and so on, a la D3 - and the ability to pass in your own interpolator.\n\n\nIf an animation is started on a keypath which is \nalready\n being animated, the first animation is cancelled. (Currently, there is no mechanism in place to prevent collisions between e.g. \nractive.animate('foo', { bar: 1 })\n and \nractive.animate('foo.bar', 0)\n.)\n\n\nSyntax\n\n\n\n\nractive.animate(keypath, value[, options])\n\n\n\n\nArguments\n\n\n\n\nkeypath (string)\n: The keypath to animate.\n\n\nvalue (number|string|Object|Array)\n: The value to animate to.\n\n\n[options] (Object)\n:\n\n\n[duration] (number)\n: How many milliseconds the animation should run for. Defaults to \n400\n.\n\n\n[easing] (string|Function)\n: The name of an easing function or the easing function itself. Defaults to \nlinear\n.\n\n\n[interpolator] (string)\n: The name of an interpolator function. Defaults to the built-in number interpolator if the value is numeric, or \nnull\n if none is applicable.\n\n\n[step] (Function)\n: A function called on each step of the animation.\n\n\nt (number)\n: The animation progress between \n0\n and \n1\n with easing function already applied.\n\n\nvalue (number)\n: The value at \nt\n with interpolator function already applied.\n\n\n\n\n\n\n[complete] (Function)\n: A function to be called when the animation completes, with the \nvalue\n passed to \nanimate\n.\n\n\n\n\n\n\n\n\nReturns\n\n\n\n\n(Promise)\n: Returns a Promise which resolves with the target \nvalue\n and has an additional \nstop\n method, which cancels the animation.\n\n\n\n\nExamples\n\n\n\n\n\nvar r = Ractive({\n  el: '#main',\n  template: '#tpl',\n  data: {\n    counter: 0\n  }\n})\n\nsetTimeout(() =\n {\n  r.animate('counter', 20, { duration: 2000 })\n}, 1000)\n\n\n\n\nractive.attachChild()\n\n\nCreates a parent-child relationship between two Ractive instances. The child may be an instance of a component defined by \nRactive.extend()\n, but that is not a requirement, as children may be a plain Ractive instance created with \nRactive()\n.\n\n\nSyntax\n\n\nractive.attachChild( child )\nractive.attachChild( child, options )\n\n\n\n\nArguments\n\n\n\n\nchild (Ractive instance)\n: The child instance to attach.\n\n\n[options] (Object)\n:\n\n\ntarget] (string)\n: An anchor name at which to render the instance. See [\nComponents\n. If the instance is already rendered, it will be unrendered and re-rendered at an appropriate anchor.\n\n\n[append] (boolean)\n: Default \ntrue\n - add the instance to the end of the list for the targeted anchor.\n\n\n[prepend] (boolean)\n: Add the instance to the beginning of the list for the targeted anchor.\n\n\n[insertAt] (number)\n: Index at which to add the instance in the list for the targeted anchor.\n\n\n\n\n\n\n\n\nWhen a child is attached to a parent, the child's \nparent\n property is updated in an observable way, so any references to \n@this.parent\n in the child will be notified of the change.\n\n\nA child may be targeted to a \nComponents\n when it is attached. If a child has no specified target, then it is responsible for managing its own render cycle. If a child does have a specified target, then the parent will manage rendering and unrendering the child as appropriate in the same way that a regular component has a managed render cycle.\n\n\nWhen a child is attached targeting an anchor, only anchors that belong directly to the parent are considered as hosts. However, any element or component queries on the parent instance, including live queries, will consider the child when trying to match both elements and components. There is also an option on the query methods that allows querying remote, unmanaged instances, so that non-anchored children can also be queried for elements and components.\n\n\nReturns\n\n\n\n\n(Promise)\n: A \nPromise\n that resolves with the child instance when any transitions are complete.\n\n\n\n\nChildren can be detached using \nractive.detachChild()\n.\n\n\nExamples\n\n\nExample 1\n: See the example for \nAnchors\n\n\nractive.compute()\n\n\nCreates a new computation. This is the API equivalent of the \ncomputed\n init or extend option.\n\n\nSyntax\n\n\n\n\nractive.compute( keypath, computation )\n\n\n\n\nArguments\n\n\n\n\nkeypath ( string )\n: The keypath at which the computation should be available. This may be more than one level deep and may include wildcards.\n\n\ncomputation ( string | function | object)\n: The computation to be installed at the given keypath.\n\n\nstring\n: The string that will be parsed and turned into a getter function.\n\n\nfunction\n: A getter function to be used for the computation.\n\n\nobject\n: An object with a \nget\n and optionally a \nset\n to be used for the computation.\n\n\n\n\n\n\n\n\nReturns\n\n\n\n\n(Promise)\n: A \nPromise\n that resolves with the child instance when any transitions are complete.\n\n\n\n\nIf there are already bits of template or observers that depend on the target keypath, they will be transitioned to the new computed model.\n\n\nractive.detach()\n\n\nDetaches the instance from the DOM, returning a document fragment. You can reinsert it, possibly in a different place, with \nractive.insert()\n (note that if you are reinserting it immediately you don't need to detach it first - it will happen automatically).\n\n\nSyntax\n\n\n\n\nractive.detach()\n\n\n\n\nArguments\n\n\n\n\nNone\n\n\n\n\nReturns\n\n\n\n\n(DocumentFragment)\n: A document fragment.\n\n\n\n\nExamples\n\n\n\n\n\nvar r = Ractive({\n  el: '#main',\n  template: '#tpl',\n  data: {\n    counter: 0\n  }\n})\n\nsetTimeout(() =\n {\n  var div = document.createElement('div')\n  div.appendChild(r.detach())\n  console.log(div.innerHTML)\n}, 1000)\n\n\n\n\nractive.detachChild()\n\n\nDetaches a child from an instance when it was previously attached with \nractive.attachChild()\n.\n\n\nWhen a child instance that was attached targeting an anchor is detached, its instance is spliced out of the \n@this.children.byName.anchorName\n array so that subsequent children move forward to fill the void.\n\n\nSyntax\n\n\n\n\nractive.detachChild( child )\n\n\n\n\nReturns\n\n\n\n\n(Promise)\n: A \nPromise\n that resolves with the child instance when any transitions are complete.\n\n\n\n\nExamples\n\n\nExample 1\n: See the example for \nAnchors\n\n\nractive.find()\n\n\nReturns the first element inside a given Ractive instance matching a CSS selector. This is similar to doing \nthis.el.querySelector(selector)\n (though it doesn't actually use \nquerySelector()\n).\n\n\nSyntax\n\n\n\n\nractive.find(selector[, options])\n\n\n\n\nArguments\n\n\n\n\nselector (string)\n: A CSS selector representing the element to find.\n\n\n[options] (Object)\n:\n\n\nremote (boolean}\n: Include attached children that are not rendered in anchors when looking for matching elements. Defaults to \nfalse\n.\n\n\n\n\n\n\n\n\nReturns\n\n\n\n\n(Node)\n: A Node.\n\n\n\n\nExamples\n\n\n\n\n\nvar r = Ractive({\n  el: '#main',\n  template: '#tpl'\n})\n\nsetTimeout(() =\n {\n  var p = r.find('p.target')\n  console.log(p.outerHTML)\n}, 1000)\n\n\n\n\nractive.findAll()\n\n\nThis method is similar to [\nractive.find()\n]ractivefind), with an important difference - it returns a list of elements matching the selector, rather than a single node.\n\n\nSyntax\n\n\n\n\nractive.findAll(selector[, options])\n\n\n\n\nArguments\n\n\n\n\nselector (string)\n: A CSS selector representing the elements to find.\n\n\n[options] (Object)\n:\n\n\nremote (boolean)\n: Include attached children that are not rendered in anchors when searching for elements. Defaults to \nfalse\n.\n\n\n\n\n\n\n\n\nReturns\n\n\n\n\n(Array\nNode\n)\n: An array of nodes.\n\n\n\n\nExamples\n\n\n\n\n\nvar r = Ractive({\n  el: '#main',\n  template: '#tpl'\n})\n\nsetTimeout(() =\n {\n  var ps = r.findAll('p')\n  ps.forEach(function(p) {\n    console.log(p.outerHTML)\n  })\n}, 1000)\n\n\n\n\nractive.findAllComponents()\n\n\nReturns all components inside a given Ractive instance with the given \nname\n (or all components of any kind if no name is given).\n\n\nSyntax\n\n\n\n\nractive.findAllComponents([name[, options]])\n\n\n\n\nArguments\n\n\n\n\n[name] (string)\n: The name of the component to find.\n\n\n[options] (Object)\n:\n\n\nremote (boolean)\n: Include attached children that are not rendered in anchors when searching components. Defaults to \nfalse\n.\n\n\n\n\n\n\n\n\nReturns\n\n\n\n\n(Array\nractive\n)\n: An array of ractive instances.\n\n\n\n\nExamples\n\n\n\n\n\nvar Component = Ractive.extend({\n  template: 'Component {{number}}'\n})\n\nvar r = Ractive({\n  el: '#main',\n  template: '#tpl',\n  components: {\n    Component: Component\n  }\n})\n\nsetTimeout(() =\n {\n  var cs = r.findAllComponents('Component')\n  cs.forEach(function(c) {\n    console.log(c.toHTML())\n  })\n}, 1000)\n\n\n\n\nractive.findComponent()\n\n\nReturns the first component inside a given Ractive instance with the given \nname\n (or the first component of any kind if no name is given).\n\n\nSyntax\n\n\n\n\nractive.findComponent([name[, options]])\n\n\n\n\nArguments\n\n\n\n\n[name] (string)\n: The name of the component to find.\n\n\n[options] (Object)\n:\n\n\nremote (boolean)\n: Include attached children that are not rendered in anchors when searching components. Defaults to \nfalse\n.\n\n\n\n\n\n\n\n\nReturns\n\n\n\n\n(Ractive)\n: A ractive instance.\n\n\n\n\nExamples\n\n\n\n\n\nvar Component = Ractive.extend({\n  template: 'Component {{number}}'\n})\n\nvar r = Ractive({\n  el: '#main',\n  template: '#tpl',\n  components: {\n    Component: Component\n  }\n})\n\nsetTimeout(() =\n {\n  var c = r.findComponent('Component')\n  console.log(c.toHTML())\n}, 1000)\n\n\n\n\nractive.findContainer()\n\n\nReturns the first container of this component instance with the given \nname\n.\n\n\nSyntax\n\n\n\n\nractive.findContainer(name)\n\n\n\n\nArguments\n\n\n\n\nname (string)\n: The name of the container to find.\n\n\n\n\nReturns\n\n\n\n\n(Ractive)\n: Returns the first container of this component with the given \nname\n.\n\n\n\n\nExamples\n\n\n// TODO\n\n\n\n\nractive.findParent()\n\n\nReturns the first parent of this component instance with the given \nname\n.\n\n\nSyntax\n\n\n\n\nractive.findParent(name)\n\n\n\n\nArguments\n\n\n\n\nname (string)\n: The name of the parent to find.\n\n\n\n\nReturns\n\n\n\n\n(Ractive)\n: Returns the first parent of this component with the given \nname\n.\n\n\n\n\nExamples\n\n\n// TODO\n\n\n\n\nractive.fire()\n\n\nFires an event, which will be received by handlers that were bound using \nractive.on\n. In practical terms, you would mostly likely use this with \nRactive.extend()\n, to allow applications to hook into your subclass.\n\n\nSyntax\n\n\n\n\nractive.fire(eventName[, context [, arg1[, ...argN]]])\n\n\n\n\nArguments\n\n\n\n\nname (string)\n: The name of the event.\n\n\n[context] (context|object)\n: A context object to use for the event or an object with properties to assign to a new context object. If you need to pass arguments but don't need to provide context, pass an empty object (\n{}\n) before the additional arguments. \nFrom 0.9.4\n, if you want to reuse a context exactly as it exists, it should have a \nrefire\n property that is \n=== true\n.\n\n\n[arg] (any)\n: The arguments that event handlers will be called with.\n\n\n\n\nReturns\n\n\n\n\n(boolean)\n\n\n\n\nExamples\n\n\n\n\n\nvar r = Ractive()\n\nr.on('foo', () =\n {\n  console.log('foo fired')\n})\n\nr.fire('foo')\n\n\n\n\nractive.get()\n\n\nReturns the value at \nkeypath\n.\n\n\nSyntax\n\n\n\n\nractive.get([keypath][, options])\n\n\n\n\nArguments\n\n\n\n\n[keypath] (string)\n: The keypath of the data to retrieve. If omitted, returns a shallow copy of the instance's data.\n\n\n[options] (Object)\n: An options hash that may contain:\n\n\nvirtual (boolean)\n: When set to \nfalse\n, excludes virtual keypaths (computations, links, mappings, etc.). Defaults to \ntrue\n for the root keypath and \nfalse\n for keypaths other than the root.\n\n\nunwrap (boolean)\n: When set to \nfalse\n, returns the adapted value of the data if an adaptor was applied. Defaults to \ntrue\n.\n\n\n\n\n\n\n\n\nReturns\n\n\n\n\n(any)\n: Returns the data that exists at the given keypath, or the root data if no keypath is given.\n\n\n\n\nExamples\n\n\n\n\n\nvar r = Ractive({\n  data: {\n    foo: {\n      bar: [ 'baz' ]\n    }\n  }\n})\n\nconsole.log(r.get('foo.bar.0'))\n\n\n\n\n\n\n\nvar r = new Ractive({\n  data : {\n    name : \nHerbert\n\n  },\n  computed : {\n    foo  () {\n      return 55\n    }\n  }\n})\n\nconsole.log(r.get()) // =\n {name : \nHerbert\n, foo : 55}\n\nconsole.log(r.get({virtual : false})) // =\n {name : \nHerbert\n}\n\n\n\n\nractive.getContext()\n\n\nThis is an instance specific version of \nRactive.getContext()\n that will only search the local instance DOM for a matching node when a selector is given. If the given value is not a string, then it is passed directly through to the static version of this method.\n\n\nSyntax\n\n\n\n\nractive.getContext(node)\n\n\n\n\nArguments\n\n\n\n\nnode (string|Node)\n: The DOM node or a CSS selector of a target node for which you wish to retrieve the Ractive instance or view details.\n\n\n\n\nReturns\n\n\n\n\n(Context)\n: Returns an Context object with helper methods to interact with the Ractive instance and context associated with the given node.\n\n\n\n\nExamples\n\n\n// TODO\n\n\n\n\nractive.insert()\n\n\nInserts the instance to a different location. If the instance is currently in the DOM, it will be detached first. See also \nractive.detach()\n.\n\n\nSyntax\n\n\n\n\nractive.insert(target[, anchor])\n\n\n\n\nArguments\n\n\n\n\ntarget (string|Node|array-like)\n: The new parent element.\n\n\n[anchor] (string|Node|array-like)\n: The sibling element to insert the instance before. If omitted, the instance will be inserted as the last child of the parent.\n\n\n\n\nReturns\n\n\n\n\n(undefined)\n\n\n\n\nExamples\n\n\n\n\n\nRactive.components.aaa = Ractive.extend({\n    template: \nbutton\n{{yield}}\n/button\n\n})\n\nRactive({\n    ...\n    template: `\n        \nbutton on-click=\nmove\nteleport\n/button\n\n        \nbutton on-click=\nrestore\nrestore\n/button\n\n\n        \ndiv id=\ncontainer1\n style=\nborder: 2px solid yellow; min-height: 50px\n\n            \naaa\nhello\n/aaa\n\n        \n/div\n\n\n        \ndiv id=\ncontainer2\n style=\nborder: 1px solid red; min-height: 50px\n\n\n        \n/div\n\n    `,\n    on: {\n        move () {\n          const aaa = this.findComponent('aaa')\n          const target = this.find('#container2')\n          aaa.insert(target)\n        },\n        restore () {\n          const aaa = this.findComponent('aaa')\n          const target = this.find('#container1')\n          aaa.insert(target)\n        }\n    }\n})\n\n\n\n\nractive.link()\n\n\nCreates a link between two keypaths that keeps them in sync. Since Ractive can't always watch the contents of objects, copying an object to two different keypaths in your data usually leads to one or both of them getting out of sync. \nlink\n creates a sort of symlink between the two paths so that Ractive knows they are actually the same object. This is particularly useful for master/detail scenarios where you have a complex list of data and you want to be able to select an item to edit in a detail form.\n\n\nSyntax\n\n\n\n\nractive.link(source, destination, options)\n\n\n\n\nArguments\n\n\n\n\nsource (string)\n: The keypath of the source item.\n\n\ndestination (string)\n: The keypath to use as the destination - or where you'd like the data 'copied'.\n\n\noptions (hash)\n:\n\n\ninstance\n or \nractive\n: The Ractive instance in which to find the source keyapth. This allows cross-instance linking much like mapped paths between components.\n\n\nkeypath\n: \nFrom 0.9.4\n - The keypath to register as the source of the link. This is an advanced option that allows you to specify how the link should shuffle. For instance \nitems.0.name\n will never shuffle, but if the keypath is specified as \n.name\n, then it will shuffle when \nitems.0\n shuffles.\n\n\n\n\nReturns\n\n\n\n\n(Promise)\n: Returns a promise.\n\n\n\n\nExamples\n\n\nractive.link( 'some.nested.0.list.25.item', 'current' )\nractive.set( 'current.name', 'Rich' ); // some.nested.0.list.25.item.name is also updated to be 'Rich'\n\n\n\n\nThis can be used to great effect with method events and the \n@keypath\n special ref:\n\n\n{{#each some.nested}}\n  {{#each list}}\n    {{#with item}}\n      {{.name}}\n      \nbutton on-click=\nevent.link('.', 'current')\nSelect\n/button\n\n    {{/with}}\n  {{/each}}\n{{/each}}\n\nName: \ninput value=\n{{~/current.name}}\n /\n\n\n\n\n\nLinks can be removed using \nractive.unlink()\n.\n\n\nractive.observe()\n\n\nObserves the data at a particular keypath. Unless specified otherwise, the callback will be fired immediately, with \nundefined\n as \noldValue\n. Thereafter it will be called whenever the \nobserved keypath\n changes.\n\n\nSyntax\n\n\n\n\nractive.observe(keypath, callback[, options])\n\n\nractive.observe(map[, options])\n\n\n\n\nArguments\n\n\n\n\n\n\nkeypath (String)\n: The keypath to observe, or a group of space-separated keypaths. Any of the keys can be a \n*\n character, which is treated as a wildcard. A \n**\n means recursive.\n\n\nThe difference between \n*\n and \n**\n is that \n*\n provides your callback function \nvalue\n and \nkeypath\n arguments containing the path of the what actually changed, at any level of the keypath. So instead of getting the same parent value on every change, you get the changed value from whatever arbitrarily deep keypath changed.\n\n\n\n\n\n\ncallback (Function)\n: The function that will be called, with \nnewValue\n, \noldValue\n and \nkeypath\n as arguments (see Observers for more nuance regarding these arguments), whenever the observed keypath changes value. By default the function will be called with \nractive\n as \nthis\n. Any wildcards in the keypath will have their matches passed to the callback at the end of the arguments list as well.\n\n\n\n\nmap (Object)\n: A map of keypath-observer pairs.\n\n\n[options] (Object)\n:\n\n\n[init] (boolean)\n: Defaults to \ntrue\n. Whether or not to initialise the observer, i.e. call the function with the current value of \nkeypath\n as the first argument and \nundefined\n as the second.\n\n\n[defer] (boolean)\n: Defaults to \nfalse\n, in which case observers will fire before any DOM changes take place. If \ntrue\n, the observer will fire once the DOM has been updated.\n\n\nlinks] (boolean)\n: Defaults to \nfalse\n.  Whether or not the observer should \"follow through\" any links created with [\nractive.link()\n.\n\n\n[strict] (boolean)\n: Defaults to \nfalse\n. \nstrict\n uses object identity to determine if there was a change, meaning that unless the primary object changed, it won't trigger the observer. For example with \n{ data: { foo: { bar: 'baz' } } }\n, \nractive.observe('foo', ..., { strict: true })\n will not fire on \nractive.set('foo.bar', 'bat')\n but will on \nractive.set('foo', { bar: 'bip' })\n.\n\n\n[context] (any)\n: Defaults to \nractive\n. The context the observer is called in (i.e. the value of \nthis\n)\n\n\n[array] (boolean)\n: Defaults to \nfalse\n. Whether or not to observe the keypath as an array, meaning that change events will fire with a object containing two lists, \ninserted\n containing added elements, and \ndeleted\n containing removed elements. There is also a \nstart\n integer property indicating the index at which the replacements begin.\n\n\n[old] (function)\n: Defaults to \nundefined\n. A function that can be used to modify the \nold\n value passed to the observer callback. This can be used to freeze the old value, create a deep clone of it for future firings, etc.\n\n\n\n\n\n\n\n\nReturns\n\n\n\n\n(Object)\n: A handle object for controlling any observers created by the call to \nobserve\n\n\ncancel\n: Permanently stops observers controlled by the handle.\n\n\nisSilenced\n: Returns \ntrue\n if this handle is currently silenced.\n\n\nsilence\n: Stop calling callbacks associated with this handle. The observers are still processed by Ractive, so the old value will still be updated. This means that setting a new value on an observer while it is silenced, resuming the observer, and then setting the same value again will \nnot\n result in the callback being fired if it would not be fired by the same sequence without silencing.\n\n\nresume\n: Resume calling callbacks associated with this handle.\n\n\n\n\n\n\n\n\nExamples\n\n\n// TODO\n\n\n\n\nNote that you can observe keypath \npatterns\n...\n\n\nractive.observe( 'items.*.status', function ( newValue, oldValue, keypath) {\n  var index = /items.(\\d+).status/.exec( keypath )[1]\n  alert( 'item ' + index + ' status changed from ' + oldValue + ' to ' + newValue )\n})\n\n\n\n\n...or multiple space-separated keypaths simultaneously:\n\n\nractive.observe( 'foo bar baz', function ( newValue, oldValue, keypath ) {\n  alert( keypath ) + ' changed from ' + oldValue + ' to ' + newValue )\n})\n\n\n\n\nSee Observers for more detail.\n\n\nractive.observeOnce()\n\n\nObserves the data at a particular keypath until the first change. After the handler has been called, it will be unsubscribed from any future changes.\n\n\nSyntax\n\n\n\n\nractive.observeOnce(keypath, callback[, options])\n\n\n\n\nArguments\n\n\n\n\nkeypath (string)\n: The keypath to observe, or a group of space-separated keypaths. Any of the keys can be a `` character, which is treated as a wildcard.\n\n\ncallback (Function)\n: The function that will be called, with \nnewValue\n, \noldValue\n and \nkeypath\n as arguments (see Observers for more nuance regarding these arguments), whenever the observed keypath changes value. By default the function will be called with \nractive\n as \nthis\n. Any wildcards in the keypath will have their matches passed to the callback at the end of the arguments list as well.\n\n\n[options] (Object)\n:\n\n\n[defer] (boolean)\n: Defaults to \nfalse\n, in which case observers will fire before any DOM changes take place. If \ntrue\n, the observer will fire once the DOM has been updated.\n\n\n[context] (any)\n: Defaults to \nractive\n. The context the observer is called in (i.e. the value of \nthis\n)\n\n\n\n\n\n\n\n\nReturns\n\n\n\n\n(Object)\n: An object with a \ncancel\n method, for cancelling the observer.\n\n\n\n\nExamples\n\n\n// TODO\n\n\n\n\nNote that you can observe keypath \npatterns\n...\n\n\nractive.observeOnce( 'items.*.status', function ( newValue, oldValue, keypath ) {\n  var index = /items.(\\d+).status/.exec( keypath )[1]\n  alert( 'item ' + index + ' status changed from ' + oldValue + ' to ' + newValue )\n})\n\n\n\n\n...or multiple space-separated keypaths simultaneously:\n\n\nractive.observeOnce( 'foo bar baz', function ( newValue, oldValue, keypath ) {\n  alert( keypath + ' changed from ' + oldValue + ' to ' + newValue )\n})\n\n\n\n\nSee Observers for more detail.\n\n\nractive.off()\n\n\nRemoves an event handler, several event handlers, or all event handlers.\n\n\nTo remove a single handler, you must specify both the event name and the handler. If you only specify the event name, all handlers bound to that event name will be removed. If you specify neither event name nor handler, \nall\n event handlers will be removed.\n\n\nAn alternative way to remove event handlers is to use the \ncancel\n method of the return value of a call to \nractive.on()\n.\n\n\nSyntax\n\n\n\n\nractive.off([eventName[, handler]])\n\n\n\n\nArguments\n\n\n\n\neventName (string)\n: The event name to which this handler is currently bound.\n\n\nhandler (Function)\n: The handler to remove.\n\n\n\n\nReturns\n\n\n\n\n(Ractive)\n: Returns the \nractive\n instance to allow this call to be chainable.\n\n\n\n\nExamples\n\n\n// TODO\n\n\n\n\nractive.on()\n\n\nSubscribe to events.\n\n\nSyntax\n\n\n\n\nractive.on(eventName, handler)\n\n\nractive.on(obj)\n\n\n\n\nArguments\n\n\n\n\neventName (String)\n: The name of the event to subscribe to\n\n\nhandler (Function)\n: The function that will be called, with \nractive\n as \nthis\n. The arguments depend on the event, but the first argument is always a context object. Returning \nfalse\n from the handler will stop propagation and prevent default of DOM events and cancel event bubbling.\n\n\nobj (Object)\n: An object with keys named for each event to subscribe to. The value at each key is the handler function for that event.\n\n\n\n\nReturns\n\n\n\n\n(Object)\n: A handle object for controlling any listners created by the call to \non\n\n\ncancel\n: Permanently stops listeners controlled by the handle.\n\n\nisSilenced\n: Returns \ntrue\n if this handle is currently silenced.\n\n\nsilence\n: Stop calling callbacks associated with this handle.\n\n\nresume\n: Resume calling callbacks associated with this handle.\n\n\n\n\n\n\n\n\nExamples\n\n\n// single handler to function\nractive.on( 'activate', function () {...})\n\n// wildcard pattern matching\nractive.on( 'foo.*', function () {...} )\n\n// multiple handlers to one function\nractive.on( 'activate select', function () {...} )\n\n// map of handler/function pairs\nractive.on({\n  activate () {...},\n  select () {...}\n})\n\n// knock yourself out:\nractive.on({\n  activate () {...},\n  'bip bop boop' () {...},\n  'select foo.* bar' () {...}\n})\n\n\n\n\nractive.once()\n\n\nSubscribe to an event for a single firing. This is a convenience function on top of \nractive.on()\n.\n\n\nSyntax\n\n\n\n\nractive.once(eventName, handler)\n\n\n\n\nArguments\n\n\n\n\neventName (string)\n: The name of the event to subscribe to.\n\n\nhandler (Function)\n: The function that will be called, with \nractive\n as \nthis\n. The arguments depend on the event, but the first argument is always a context object. Returning \nfalse\n from the handler will stop propagation and prevent default of DOM events and cancel event bubbling.\n\n\n\n\nReturns\n\n\n\n\n(Object)\n: Returns an \nObject\n with a \ncancel\n method, which removes the handler.\n\n\n\n\nExamples\n\n\n// TODO\n\n\n\n\nractive.pop()\n\n\nThe Ractive equivalent to \nArray.pop\n that removes an element from the end of the array at the given keypath and triggers an update event.\n\n\nIf the given keypath does not exist (is \nundefined\n), an empty array will be supplied instead. Otherwise, if the given keypath does not resolve to an array, an error will be thrown.\n\n\nSyntax\n\n\n\n\nractive.pop(keypath)\n\n\n\n\nArguments\n\n\n\n\nkeypath (string)\n: The keypath of the array to change, e.g. \nlist\n or \norder.items\n.\n\n\n\n\nReturns\n\n\n\n\n(Promise)\n: Returns a promise that will resolve with the removed element after the update is complete.\n\n\n\n\nExamples\n\n\n// TODO\n\n\n\n\nractive.push()\n\n\nThe Ractive equivalent to \nArray.push\n that appends one or more elements to the array at the given keypath and triggers an update event.\n\n\nIf the given keypath does not exist (is \nundefined\n), an empty array will be supplied instead. Otherwise, if the given keypath does not resolve to an array, an error will be thrown.\n\n\nSyntax\n\n\n\n\nractive.push(keypath, value[, ...valueN])\n\n\n\n\nArguments\n\n\n\n\nkeypath (string)\n: The keypath of the array to change, e.g. \nlist\n or \norder.items\n.\n\n\nvalue (any)\n: The value to append to the end of the array. One or more values may be supplied.\n\n\n\n\nReturns\n\n\n\n\n(Promise)\n - Returns a Promise that will resolve after the update is complete.\n\n\n\n\nExamples\n\n\n// TODO\n\n\n\n\nractive.readLink()\n\n\nGets the source keypath and instance for a link.\n\n\nSyntax\n\n\n\n\nractive.readLink(link[, options])\n\n\n\n\nArguments\n\n\n\n\nlink (string)\n: The keypath for the link that you would like to read.\n\n\noptions (Object)\n:\n\n\n[canonical] (boolean)\n: Whether or not to read through any intermediate links too. Pass \ncanonical: true\n to read through links to links all the way to the canonical data keypath. Defaults to \nfalse\n.\n\n\n\n\n\n\n\n\nReturns\n\n\n\n\n(Object)\n:\n\n\nkeypath (string)\n: The source keypath to which the link points.\n\n\nractive (Ractive)\n: The source Ractive instance that contains the keypath to which the link points.\n\n\n\n\n\n\n\n\nExamples\n\n\nconst r = Ractive({\n  data: {\n    items: [\n      { name: 'Apple' },\n      { name: 'Banana' },\n      { name: 'Orange' }\n    ]\n  }\n})\n\nr.link( 'items.0', 'currentItem' )\n\nr.readLink( 'currentItem' )\n// returns { ractive: r, keypath: 'items.0' }\n\n\n\n\nractive.render()\n\n\nRenders the component into a DOM element.\n\n\nSyntax\n\n\n\n\nractive.render(target)\n\n\n\n\nArguments\n\n\n\n\ntarget (Node|String|array-like)\n: The DOM element to render to.\n\n\n\n\nReturns\n\n\n\n\n(Promise)\n: A promise that resolves when rendering completes or when the instance is already rendered.\n\n\n\n\nExamples\n\n\n// TODO\n\n\n\n\nractive.reset()\n\n\nResets the entire \nractive.data\n object and updates the DOM.\n\n\nSyntax\n\n\n\n\nractive.reset(data)\n\n\n\n\nArguments\n\n\n\n\ndata (Object)\n: The data to reset with. Defaults to \n{}\n.\n\n\n\n\nReturns\n\n\n\n\n(Promise)\n: A promise.\n\n\n\n\nExamples\n\n\nThis differs from \nractive.set()\n in the following way:\n\n\nractive = Ractive({\n  // ...,\n  data: { foo: 1 }\n})\n\nractive.set({ bar: 2 })\nconsole.log( ractive.get() ); // { foo: 1, bar: 2 }\n\nractive.reset({ bar: 2 })\nconsole.log( ractive.get() ); // { bar: 2 }\n\n\n\n\nractive.resetPartial()\n\n\nResets a partial and re-renders all of its use-sites, including in any components that have inherited it. If a component has a partial with a same name that is its own, that partial will not be affected.\n\n\nInline partials that don't belong directly to a Ractive instance aren't affected by \nresetPartial\n.\n\n\nSyntax\n\n\n\n\nractive.resetPartial(name, partial)\n\n\n\n\nArguments\n\n\n\n\nname (string)\n: The partial to reset.\n\n\npartial (string|Object|Function)\n: A template string, pre-parsed template or a function that returns either.\n\n\n\n\nReturns\n\n\n\n\n(Promise)\n: A promise.\n\n\n\n\nExamples\n\n\nractive = Ractive({\n  // ...,\n  partials: { foo: 'foo' }\n})\n\n// {{\nfoo}} will be replaced with 'foo'\n\nractive.resetPartial('foo', 'bar')\n\n// {{\nfoo}} will be replaced with 'bar'\n\n\n\n\nractive.resetTemplate()\n\n\nResets the template and re-renders the entire instance using the new template.\n\n\nSyntax\n\n\n\n\nractive.resetTemplate(template)\n\n\n\n\nArguments\n\n\n\n\ntemplate (string|Object)\n: The new template to use. If an object, the template should be the result of \nRactive.parse\n with both version and template array properties.\n\n\n\n\nReturns\n\n\n\n\n(Promise)\n: A promise that resolves once any transitions that are triggered during the re-render are completed.\n\n\n\n\nExamples\n\n\nconst ractive = new Ractive({\n  // ...,\n  template: 'replace me'\n});\n\nractive.resetTemplate('you have been replaced');\nractive.set('foo', 'world');\nractive.resetTemplate(Ractive.parse('Hello, {{foo}}'));\n\n\n\n\nractive.reverse()\n\n\nThe Ractive equivalent to \nArray.reverse\n reverses the array at the given keypath and triggers an update event.\n\n\nIf the given keypath does not resolve to an array, an error will be thrown.\n\n\nSyntax\n\n\n\n\nractive.reverse(keypath)\n\n\n\n\nArguments\n\n\n\n\nkeypath (String)\n: The keypath of the array to reverse, e.g. \nlist\n or \norder.items\n\n\n\n\nReturns\n\n\n\n\n(Promise)\n - A promise that will resolve after the update is complete.\n\n\n\n\nExamples\n\n\n// TODO\n\n\n\n\nractive.set()\n\n\nUpdates data and triggers a re-render of any mustaches that are affected (directly or indirectly) by the change. Any observers of affected keypaths will be notified.\n\n\nWhen setting an array value, ractive will reuse the existing DOM nodes for the new array, adding or removing nodes as necessary. This can impact nodes with transitions. Use the \nshuffle\n option for setting a new array value while retaining existing nodes corresponding to individual array item values.\n\n\nSyntax\n\n\n\n\nractive.set(keypath, value[, options])\n\n\nractive.set(map[, options])\n\n\n\n\nArguments\n\n\n\n\nkeypath (string)\n: The keypath of the data we're changing, e.g.\n\n\nuser\n\n\nuser.name\n\n\nuser.friends[1]\n or \nuser.friends.1\n\n\nusers.*.status\n\n\nimages.aaa\\\\.jpg.url\n.\n\n\n\n\n\n\nvalue (any)\n: The value we're changing it to. Can be a primitive or an object (or array), in which case dependants of \ndownstream keypaths\n will also be re-rendered (if they have changed).\n\n\nmap (Object)\n: A map of \nkeypath: value\n pairs, as above.\n\n\n[options] Object\n:\n\n\ndeep (boolean)\n: Whether or not to perform a deep set on with the data at the given keypath. A deep set recursively merges the given data into the data structure at the given keypath. Defaults to \nfalse\n.\n\n\nshuffle (boolean|string|Function)\n: Whether or not to add/move/remove DOM associated with elements rather than just re-using the existing DOM. Defaults to \nfalse\n.\n\n\ntrue\n: Add/move/remove existing items to their new index using a strict equality comparison.\n\n\nstring\n: Add/move/remove existing items to their new index using a property comparison where the property compared is named by the given string.\n\n\nFunction\n: Add/move/remove existing items to their new index using the value returned by the given function for comparison.\n\n\n\n\n\n\nkeep (boolean)\n: Whether or not to keep the virtual DOM that would be disposed by the \nset\n operation. This is useful for hiding components without completely tearing them down and recreating them. It's also a little bit faster, as the virtual DOM doesn't have to be recreated when it would reappear. When the virtual DOM is re-rendered, it will also us the progressive enhancement process to reuse the existing DOM nodes that were detached originalls. Defaults to \nfalse\n.\n\n\n\n\n\n\n\n\nReturns\n\n\n\n\n(Promise)\n: Returns a promise that will resolved after any transitions associated with the operation are complete.\n\n\n\n\nExamples\n\n\n// TODO\n\n\n\n\nThe \nkeypath\n can also contain wildcards pattern-observers. All matching keypaths will be set with the supplied values:\n\n\nractive.on('selectAll', function () {\n  ractive.set('items.*.selected', true)\n})\n\n\n\n\nSee Also\n\n\n\n\nRactive.escapeKey()\n\n\n\n\nractive.shift()\n\n\nThe Ractive equivalent to \nArray.shift\n that removes an element from the beginning of the array at the given keypath and triggers an update event.\n\n\nIf the given keypath does not exist (is \nundefined\n), an empty array will be supplied instead. Otherwise, if the given keypath does not resolve to an array, an error will be thrown.\n\n\nSyntax\n\n\n\n\nractive.shift(keypath)\n\n\n\n\nArguments\n\n\n\n\nkeypath (string)\n: The keypath of the array to change, e.g. \nlist\n or \norder.items\n.\n\n\n\n\nReturns\n\n\n\n\n(Promise)\n: A promise that will resolve with the removed element after the update is complete.\n\n\n\n\nExamples\n\n\n// TODO\n\n\n\n\nractive.sort()\n\n\nThe Ractive equivalent to \nArray.sort\n sorts the array at the given keypath and triggers an update event.\n\n\nIf the given keypath does not resolve to an array, an error will be thrown.\n\n\nSyntax\n\n\n\n\nractive.sort(keypath[, compareFunction])\n\n\n\n\nArguments\n\n\n\n\nkeypath (string)\n: The keypath of the array to sort, e.g. \nlist\n or \norder.items\n.\n\n\ncompareFunction (Function)\n: A function that defines the sort order.\n\n\n\n\nReturns\n\n\n\n\n(Promise)\n: Returns a promise that will resolve after the update is complete.\n\n\n\n\nExamples\n\n\n// TODO\n\n\n\n\nractive.splice()\n\n\nThe Ractive equivalent to \nArray.splice\n that can add new elements to the array while removing existing elements.\n\n\nIf the given keypath does not exist (is \nundefined\n), an empty array will be supplied instead. Otherwise, if the given keypath does not resolve to an array, an error will be thrown.\n\n\nSyntax\n\n\n\n\nractive.splice(keypath, index, [removeCount[, add]])\n\n\n\n\nArguments\n\n\n\n\nkeypath (string)\n: The keypath of the array to change, e.g. \nlist\n or \norder.items\n.\n\n\nindex (number)\n: The index at which to start the operation.\n\n\n[removeCount] (number)\n: The number of elements to remove starting with the element at *\nindex\n. This may be 0 if you don't want to remove any elements.\n\n\n[add] (any)\n: Any elements to insert into the array starting at *\nindex\n. There can be 0 or more elements passed to add to the array.\n\n\n\n\nReturns\n\n\n\n\n(Promise)\n: Returns a promise that will resolve with the removed elements after the update is complete.\n\n\n\n\nExamples\n\n\n// TODO\n\n\n\n\nractive.subtract()\n\n\nDecrements the selected keypath.\n\n\nSyntax\n\n\n\n\nractive.subtract(keypath[, number])\n\n\n\n\nArguments\n\n\n\n\nkeypath (string)\n: The keypath of the number we're decrementing.\n\n\n[number] (number)\n: Defaults to \n1\n. The number to decrement by.\n\n\n\n\nReturns\n\n\n\n\n(Promise)\n: Returns a promise.\n\n\n\n\nExamples\n\n\n// TODO\n\n\n\n\nractive.teardown()\n\n\nUnrenders this Ractive instance, removing any event handlers that were bound automatically by Ractive.\n\n\nCalling \nractive.teardown()\n causes a \nteardown\n event to be fired - this is most useful with \nRactive.extend()\n as it allows you to clean up anything else (event listeners and other bindings) that are part of the subclass.\n\n\nSyntax\n\n\n\n\nractive.teardown()\n\n\n\n\nArguments\n\n\n\n\nNone\n\n\n\n\nReturns\n\n\n\n\n(Promise)\n: A promise.\n\n\n\n\nExamples\n\n\n// TODO\n\n\n\n\nractive.toCSS()\n\n\nReturns the scoped CSS of the current instance and its descendants.\n\n\nAt the moment, this will not work on a direct instance of Ractive and will log a warning. You can only use this method on an instance of a subclass.\n\n\nSyntax\n\n\n\n\nractive.toCSS()\n\n\n\n\nArguments\n\n\n\n\nNone\n\n\n\n\nReturns\n\n\n\n\n(string)\n: The scoped CSS of the instance.\n\n\n\n\nExamples\n\n\nconst Subclass = Ractive.extend({\n    ...\n    css: 'div{ color: red }'\n    ...\n})\n\nconst subclassInstance = Subclass({...})\n\n// Contains the scoped version of div{ color: red }\nsubclassInstance.toCSS()\n\n\n\n\nractive.toHTML()\n\n\nReturns a chunk of HTML representing the current state of the instance. This is most useful when you're using Ractive in node.js, as it allows you to serve fully-rendered pages (good for SEO and initial pageload performance) to the client.\n\n\nSyntax\n\n\n\n\nractive.toHTML()\n\n\n\n\nArguments\n\n\n\n\nNone\n\n\n\n\nReturns\n\n\n\n\n(string)\n: The instance HTML.\n\n\n\n\nExamples\n\n\n// TODO\n\n\n\n\nractive.toggle()\n\n\nToggles the selected keypath. In other words, if \nfoo\n is truthy, then \nractive.toggle('foo')\n will make it \nfalse\n, and vice-versa.\n\n\nSyntax\n\n\n\n\nractive.toggle(keypath)\n\n\n\n\nArguments\n\n\n\n\nkeypath (string)\n: The keypath to toggle the value of. If \nkeypath\n is a pattern, then all matching keypaths will be toggled.\n\n\n\n\nReturns\n\n\n\n\n(Promise)\n: A promise.\n\n\n\n\nExamples\n\n\n// TODO\n\n\n\n\nractive.transition()\n\n\nTriggers a transition on a node managed by this Ractive instance.\n\n\nSyntax\n\n\n\n\nractive.transition(transition, node, options)\n\n\n\n\nArguments\n\n\n\n\ntransition (string|Function)\n: A transition function or a name of a transition function.\n\n\nnode (HTMLElement)\n: The node on which to start the transition - optional if called from within a Ractive event handler, as it will be retrieved from the event if not supplied.\n\n\noptions (Object)\n: Options supplied to the transition.\n\n\n\n\nReturns\n\n\n\n\n(Promise)\n: A promise that resolves when the transition completes.\n\n\n\n\nExamples\n\n\n// TODO\n\n\n\n\nractive.unlink()\n\n\nRemoves a link set up by \nractive.link()\n.\n\n\nSyntax\n\n\n\n\nractive.unlink(destination)\n\n\n\n\nArguments\n\n\n\n\ndestination (string)\n: The destination supplied to [\nractive.link()\n].\n\n\n\n\nReturns\n\n\n\n\n(Promise)\n: A promise.\n\n\n\n\nExamples\n\n\n// TODO\n\n\n\n\nractive.unrender()\n\n\nUnrenders this Ractive instance, throwing away any DOM nodes associated with this instance. This is the counterpart to \nractive.render()\n. The rest of the ractive instance is left intact, unlike \nractive.teardown()\n.\n\n\nNote that if the instance happens to be a component that is managed by another instance, the owning instance may veto the call to \nunrender\n. If you need more precise control over component rendering, you should probably use an anchor and \nractive.attachChild()\n instead.\n\n\nSyntax\n\n\n\n\nractive.unrender()\n\n\n\n\nArguments\n\n\n\n\nNone\n\n\n\n\nReturns\n\n\n\n\n(Promise)\n: A promise.\n\n\n\n\nExamples\n\n\n// TODO\n\n\n\n\nractive.unshift()\n\n\nThe Ractive equivalent to \nArray.unshift\n that prepends one or more elements to the array at the given keypath and triggers an update event.\n\n\nIf the given keypath does not exist (is \nundefined\n), an empty array will be supplied instead. Otherwise, if the given keypath does not resolve to an array, an error will be thrown.\n\n\nSyntax\n\n\n\n\nractive.unshift(keypath, value)\n\n\n\n\nArguments\n\n\n\n\nkeypath (string)\n: The keypath of the array to change, e.g. \nlist\n or \norder.items\n.\n\n\nvalue (any)\n: The value to prepend to the beginning of the array. One or more values may be supplied.\n\n\n\n\nReturns\n\n\n\n\n(Promise)\n: Returns a promise that will resolve after the update is complete.\n\n\n\n\nExamples\n\n\n// TODO\n\n\n\n\nractive.update()\n\n\n\"Dirty checks\" everything that depends directly or indirectly on the specified keypath. If no \nkeypath\n is specified, all keypaths will be checked. Keypaths that involve special references (i.e. \n@global\n) require the keypath to be supplied.\n\n\nThis is useful when manipulating the instance's data without using the built in setter methods (i.e. \nractive.set()\n, \nractive.animate()\n).\n\n\nSyntax\n\n\n\n\nractive.update([keypath][, options])\n\n\n\n\nArguments\n\n\n\n\n[keypath] (string)\n: The keypath to treat as 'dirty'.\n\n\n[options] (Object\nstring, any\n)\n:\n\n\nforce (boolean)\n: Force an update regardless of whether or not the internal change check determines that the keypath has \nactually\n changed. This is useful for forcing all expressions referencing a particular function to recompute.\n\n\n\n\n\n\n\n\nReturns\n\n\n\n\n(Promise)\n: A promise that resolves when any transitions associated with the operation complete.\n\n\n\n\nExamples\n\n\nractive.observe( 'foo', function ( foo ) {\n  alert( foo )\n})\n\nmodel.foo = 'changed';   // Does not cause the instance to update.\nractive.update( 'foo' ); // Informs the instance that foo was changed externally.\n\n\n\n\nractive.updateModel()\n\n\nIf you programmatically manipulate inputs and other elements that have two\u2010way binding set up, your model can get out of sync. In these cases, we need to force a resync with \nractive.updateModel()\n:\n\n\nSyntax\n\n\n\n\nractive.updateModel([keypath[, cascade]])\n\n\n\n\nArguments\n\n\n\n\nkeypath (string)\n: The keypath to treat as 'dirty'. Any two-way bindings linked to this keypath will be checked to see if the model is out of date\n\n\ncascade (boolean)\n: If true, bindings that are \ndownstream\n of \nkeypath\n will also be checked - e.g. \nractive.updateModel( 'items', true )\n would check \nitems.0.foo\n and \nitems.1.foo\n and so on. Defaults to \nfalse\n.\n\n\n\n\nReturns\n\n\n\n\n(Promise)\n: A promise. If a \nkeypath\n is not specified, all two-way bindings will be checked.\n\n\n\n\nExamples\n\n\nractive = Ractive({\n  el: 'container',\n  template: '\ninput value=\n{{name}}\n'\n  data: { name: 'Bob' }\n})\n\nractive.find( 'input' ).value = 'Jim'\nalert( ractive.get( 'name' ) ); // alerts 'Bob', not 'Jim'\n\nractive.updateModel()\nalert( ractive.get( 'name' ) ); // alerts 'Jim'\n\n\n\n\nractive.use()\n\n\nFrom 0.10.0\n\n\nInstall one or more plugins in a Ractive instance.\n\n\nSyntax\n\n\n\n\nractive.use(plugin[, ...plugin])\n\n\n\n\nArguments\n\n\n\n\nplugin (plugin)\n: A plugin function that receives \n{ Ractive, instance: ractive, proto: ractive }\n as an argument.\n\n\n\n\nReturns\n\n\n\n\n(this)\n: The instance on which the method was called.\n\n\n\n\nContext Object\n\n\nThe context object is the type of object you receive when calling getContext(). This object contains various properties and methods that allow you to interact with and obtain information about the Ractive instance, the node associated with it and the context surrounding it.\n\n\nThe special \n@context\n reference is also a context object that is associated with the nearest VDOM item and element. It's frequently used with event directives to interact with the data associated with the immediate context.\n\n\nHelper methods that take a keypath will resolve relative to that node's context. Special references, template aliases, and key and index aliases are supported. If the method doesn't require a keypath, like \nget\n, then the keypath will implicitly be \n.\n rather than \n~/\n, as with regular instance methods.\n\n\ncontext.add()\n\n\nSee ractive.add().\n\n\ncontext.animate()\n\n\nSee ractive.animate().\n\n\ncontext.decorators\n\n\n(Object)\n\n\nA map of decorator name to decorator return object for all of the decorators on the node associated with the context.\n\n\ncontext.event\n\n\n(Event|undefined)\n\n\nThe original event for contexts supplied to event directives. This is \nundefined\n for contexts not associated with an event.\n\n\ncontext.get()\n\n\nSee ractive.get().\n\n\ncontext.getBinding()\n\n\nReturns the value of the binding if the node represented by this info object has a two-way binding.\n\n\nSyntax\n\n\n\n\ncontext.getBinding()\n\n\n\n\nArguments\n\n\n\n\nNone\n\n\n\n\nReturns\n\n\n\n\n(any)\n: The value of the binding.\n\n\n\n\nExamples\n\n\n{{#with foo.bar}}\ninput id=\nfindMe\n value=\n{{.baz}}\n /\n{{/with}}\n\n\n\n\nRactive.getContext('#findMe').getBinding(); // returns value of foo.bar.baz\n\n\n\n\ncontext.getBindingPath()\n\n\nReturns the keypath of the binding if the node represented by this info object has a two-way binding.\n\n\nSyntax\n\n\n\n\ncontext.getBindingPath([ractive])\n\n\n\n\nArguments\n\n\n\n\n[ractive] (Ractive)\n: The instance to resolve the keypath against.\n\n\n\n\nReturns\n\n\n\n\n(string)\n: The keypath of the node binding.\n\n\n\n\nExamples\n\n\n{{#with foo.bar}}\ninput id=\nfindMe\n value=\n{{.baz}}\n /\n{{/with}}\n\n\n\n\nRactive.getContext('#findMe').getBindingPath(); // Returns \nfoo.bar.baz\n\n\n\n\n\ncontext.getParent()\n\n\nFrom 0.9.4\n\n\nGets the parent context of this context. This is finer grained than element access provided by \nRactive.getContext\n, as it can target sections that exist nested between elements.\n\n\nSyntax\n\n\n\n\ncontext.getParent(crossComponentBoundary)\n\n\n\n\nArguments\n\n\n\n\ncrossComponentBoundary (boolean)\n: Whether or not to cross into the context containing a component. Defaults to \nfalse\n.\n\n\n\n\nReturns\n\n\n\n\n(context)\n: The parent context object.\n\n\n\n\nExamples\n\n\ndiv\n{{#with foo.bar}}{{#with .baz}}\nspan /\n{{/with}}{{/with}}\n/div\n\n\n\n\n\nconst ctx = Ractive.getContext('span')\nctx.resolve(); // foo.bar.baz\nconst parent = ctx.getParent()\nparent.resolve(); // foo.bar\n\n\n\n\ncontext.hasListener()\n\n\nReturns \ntrue\n if the element associated with the context has a Ractive-managed event listener for a given event name. The target event does not have to be an actual DOM event, so this method can be used conveniently in conjunction with \ncontext.raise\n.\n\n\nSyntax\n\n\n\n\ncontext.hasListener(event[, bubble])\n\n\n\n\nArguments\n\n\n\n\nevent (string)\n: The name of the event for which to check for listeners.\n\n\nbubble (boolean)\n: Whether or not to check parent elements for the event name as well, should the target element not have a listener. Defaults to \nfalse\n.\n\n\n\n\nReturns\n\n\n\n\n(boolean)\n: \ntrue\n if a listener was found or \nfalse\n otherwise.\n\n\n\n\nExamples\n\n\nsection on-other=\nothered\n\n  \narticle on-thing=\nthinged\nSome text...\n/article\n\n\n/section\n\n\n\n\n\nconst ctx = ractive.getContext('article');\nctx.hasListener('thing'); // true\nctx.hasListener('other'); // false\nctx.hasListener('other', true); // true\n\n\n\n\ncontext.isBound()\n\n\nReturns \ntrue\n if the node represented by this info object has a two-way binding.\n\n\nSyntax\n\n\n\n\ncontext.isBound()\n\n\n\n\nArguments\n\n\n\n\nNone\n\n\n\n\nReturns\n\n\n\n\n(boolean)\n: \ntrue\n if the node represented has a two-way binding.\n\n\n\n\nExamples\n\n\n{{#with foo.bar}}\n  \ninput id=\nfoo\n value=\n{{.baz}}\n /\n\n  \ninput id=\nbar\n value=\n /\n\n{{/with}}\n\n\n\n\nRactive.getContext('#foo').isBound(); // Returns true\nRactive.getContext('#bar').isBound(); // Returns false\n\n\n\n\ncontext.link()\n\n\nSee ractive.link().\n\n\ncontext.listen()\n\n\nSubscribes an event listener either directly on the node associated with the context or as a delegate if appropriate. This is not like the \non\n method, but is instead basically an \naddEventListener\n helper that is delegation-aware.\n\n\nSyntax\n\n\ncontext.listen( event, callback )\n\n\nArguments\n\n\n\n\nevent (string)\n: The name of the event to subscribe.\n\n\ncallback (function)\n: The callback function to be called when the event fires.\n\n\n\n\nReturns\n\n\n\n\n(Object)\n: An object with a \ncancel\n method to unlisten the event.\n\n\n\n\ncontext.node\n\n\n(Node|undefined)\n\n\nThe node associated with the context. Note that it is possible to get a context that is not associated with an element, which will leave the node \nundefined\n.\n\n\ncontext.observe()\n\n\nSee ractive.observe().\n\n\ncontext.observeOnce()\n\n\nSee ractive.observeOnce().\n\n\ncontext.original\n\n\n(Event|undefined)\n\n\nThe original DOM event object. Normally present when the event is a Ractive DOM event. May be \nundefined\n on custom events or events from event plugins.\n\n\ncontext.pop()\n\n\nSee ractive.pop().\n\n\ncontext.push()\n\n\nSee ractive.push().\n\n\ncontext.ractive\n\n\n(Ractive)\n\n\nThis property holds a reference to the Ractive instance that controls the node represented by this info object.\n\n\ncontext.raise()\n\n\nTriggers the nearest matching event directive relative to the context. This is useful for decorators and other library constructs that want to be able to raise their own events that aren't necessarily tied to a DOM event. Raised events do not bubble.\n\n\nSyntax\n\n\n\n\ncontext.raise(eventName[, event[, ...args]])\n\n\n\n\nArguments\n\n\n\n\neventName (string)\n: The name of the event to raise. For \ndiv on-something=\"...\"\n, the event name would be \n'something'\n.\n\n\n[event] (context|object)\n: The context for the event or an object of properties to assign to the context for the event. Defaults to \n{}\n.\n\n\n[args] (...any)\n: Additional arguments to supply to the event handler.\n\n\n\n\nExamples\n\n\n// TODO\n\n\n\n\ncontext.readLink()\n\n\nSee ractive.readLink().\n\n\ncontext.resolve()\n\n\nResolves the given keypath to a full keypath. If a Ractive instance is supplied, the resolved path will also account for any mappings defined for the instance.\n\n\nSyntax\n\n\n\n\ncontext.resolve([keypath[, ractive]])\n\n\n\n\nArguments\n\n\n\n\n[keypath] (string)\n: The keypath to resolve.\n\n\n[ractive] (Ractive)\n: The instance to resolve the keypath against.\n\n\n\n\nReturns\n\n\n\n\n(string)\n: The resolved keypath.\n\n\n\n\nExamples\n\n\n// TODO\n\n\n\n\ncontext.reverse()\n\n\nSee ractive.reverse().\n\n\ncontext.set()\n\n\nSee ractive.set().\n\n\ncontext.setBinding()\n\n\nSets the binding of the node represented by this info object to the specified value.\n\n\nSyntax\n\n\n\n\ncontext.setBinding(value)\n\n\n\n\nArguments\n\n\n\n\nvalue (any)\n. The value to set.\n\n\n\n\nReturns\n\n\n\n\n(Promise)\n\n\n\n\nExamples\n\n\n// TODO\n\n\n\n\ncontext.shift()\n\n\nSee ractive.shift().\n\n\ncontext.splice()\n\n\nSee ractive.splice().\n\n\ncontext.sort()\n\n\nSee ractive.sort().\n\n\ncontext.subtract()\n\n\nSee ractive.subtract().\n\n\ncontext.toggle()\n\n\nSee ractive.toggle().\n\n\ncontext.unlink()\n\n\nSee ractive.unlink().\n\n\ncontext.unlisten()\n\n\nUnsubscribe an event listener that was subscribed with \nlisten\n. This is basically a \nremoveEventListener\n helper that is delegation-aware.\n\n\nSyntax\n\n\ncontext.unlisten( event, callback )\n\n\nArguments\n\n\n\n\nevent (string)\n: The name of the event to unsubscribe.\n\n\ncallback (function)\n: The callback that was previously subscribed.\n\n\n\n\ncontext.unshift()\n\n\nSee ractive.unshift().\n\n\ncontext.update()\n\n\nSee ractive.update().\n\n\ncontext.updateModel()\n\n\nSee ractive.updateModel().\n\n\nParse Object\n\n\nThe parse object is an object you receive as the second argument in function templates. This helper object provides you with essential functions to dissect markup before turning over the template for use.\n\n\np.fromId()\n\n\nRetrieves the template from the DOM \nscript\n tag specified by \nid\n. Make sure to set \ntype='text/ractive'\n on the \nscript\n tag to prevent the browser from running the template as a script.\n\n\nSyntax\n\n\n\n\np.fromId(id)\n\n\n\n\nArguments\n\n\n\n\nid (string)\n: The id of the \nscript\n tag containing the template. The leading \n#\n is optional.\n\n\n\n\nReturns\n\n\n\n\n(string)\n: The template inside the specified element.\n\n\n\n\nExamples\n\n\n// TODO\n\n\n\n\np.isParsed()\n\n\nTest whether the supplied template is already parsed and is in its object form.\n\n\nSyntax\n\n\n\n\np.isParsed(template)\n\n\n\n\nArguments\n\n\n\n\ntemplate (string|Object)\n: The template, either in its string form or object form.\n\n\n\n\nReturns\n\n\n\n\n(boolean)\n: Returns \ntrue\n if the template is already parsed, \nfalse\n if otherwise.\n\n\n\n\nExamples\n\n\n// TODO\n\n\n\n\np.parse()\n\n\nParses the template using Ractive.parse(). Full Ractive runtime must be loaded.\n\n\nSyntax\n\n\n\n\np.parse(template[, parseOptions])\n\n\n\n\nArguments\n\n\n\n\ntemplate (string|Object)\n: The template in its string form or object form.\n\n\nparseOptions] (Object)\n: Template parser options. See [Ractive.parse() for all available options. If \nparseOptions\n is not specified, it defaults to those of the current instance.\n\n\n\n\nReturns\n\n\n\n\n(Object)\n: The parsed template.\n\n\n\n\nExamples\n\n\n// TODO\n\n\n\n\nTransition Object\n\n\nThe transition object is an object you receive when writing transitions. It has a few properties and methods designed to make creating transitions easier.\n\n\nt.animateStyle()\n\n\nAnimates CSS properties to a certain value.\n\n\nSyntax\n\n\n\n\nt.animateStyle(prop, value, options[, complete])\n\n\nt.animateStyle(props, options[, complete])\n\n\n\n\nArguments\n\n\n\n\nprops (Object)\n: A map of animation properties and values.\n\n\nprop (string)\n: The style to animate.\n\n\nvalue (any)\n: The value to animate it to.\n\n\noptions (Object)\n: Animation options.\n\n\nduration (number)\n: The duration of the animation.\n\n\neasing (string)\n: The easing function of the animation.\n\n\ndelay (number)\n: The number of milliseconds before the animation starts.\n\n\n[complete] (Function)\n: A function that is executed when the animation completes, or immediately if no changes were made.\n\n\n\n\nReturns\n\n\n\n\n(Promise)\n: A promise that resolves when the animation completes.\n\n\n\n\nExamples\n\n\n// TODO\n\n\n\n\nt.complete()\n\n\nSignals Ractive that the transition is complete.\n\n\nSyntax\n\n\n\n\nt.complete[noReset])\n\n\n\n\nArguments\n\n\n\n\nnoReset] (boolean)\n: If \ntrue\n, [\nt.resetStyle()\n is not called. Defaults to \nfalse\n.\n\n\n\n\nReturns\n\n\n\n\n(undefined)\n\n\n\n\nExamples\n\n\n// TODO\n\n\n\n\nt.getStyle()\n\n\nRetrieve a CSS property value from \nt.node\n.\n\n\nSyntax\n\n\n\n\nt.getStyle(prop)\n\n\n\n\nArguments\n\n\n\n\nprop (string)\n: An unprefixed CSS property either in camelCase or kebab-case.\n\n\nprop (Array)\n: An array of CSS properties.\n\n\n\n\nReturns\n\n\n\n\n(string)\n: The value of the specified style property.\n\n\n(Object)\n: A key-value pair of properties and their respective values.\n\n\n\n\nExamples\n\n\n// TODO\n\n\n\n\nt.isIntro\n\n\n(boolean)\n\n\nShould be self-explanatory...\n\n\nt.name\n\n\n(string)\n\n\nThe name of the transition.\n\n\nt.node\n\n\n(Node)\n\n\nThe node that's entering or leaving the DOM\n\n\nt.processParams()\n\n\nBuilds a map of parameters whose values are taken from the provided arguments. When used with a single number or string argument, serves as a shorthand for creating a map with a \nduration\n property.\n\n\nSyntax\n\n\n\n\nt.processParams(params[, defaults])\n\n\n\n\nArguments\n\n\n\n\nparams (number)\n: Numeric shorthand for the \nduration\n parameter. Expressed in milliseconds.\n\n\nparams (string)\n: String shorthand for the \nduration\n parameter. Valid values are:\n\n\n\"fast\" - 200ms\n\n\n\"slow\" - 600ms\n\n\nAny other string - 400ms\n\n\n\n\n\n\nparams (Object)\n: A map of parameters and their values.\n\n\n[defaults] (Object)\n: A map of parameters and their default values.\n\n\n\n\nReturns\n\n\n\n\n(Object)\n: A map of parameters and their values.\n\n\n\n\nExamples\n\n\n// TODO\n\n\n\n\nt.setStyle()\n\n\nSets a CSS property on \nt.node\n to a value.\n\n\nSyntax\n\n\n\n\nt.setStyle(prop, value)\n\n\nt.setStyle(props)\n\n\n\n\nArguments\n\n\n\n\nprop (string)\n: An unprefixed CSS property either in camelCase or kebab-case.\n\n\nprops (Object)\n: A key-value pair of CSS properties and their respective values.\n\n\nvalue (string)\n: A valid value for the specified CSS property.\n\n\n\n\nReturns\n\n\n\n\n(undefined)\n\n\n\n\nExamples\n\n\n// TODO\n\n\n\n\nComponent files\n\n\nRemember the good old days? When all CSS went in \nstyle\n elements in \nhead\n? When all JS went in \nscript\n elements just before \n/body\n? When all HTML was written in Mustache inside inert \nscript\n elements? When it felt good when everything just worked after a page refresh? Ractive remembers, and it's bringing those good times back with component files.\n\n\nRactive component files are simply self-contained HTML files that define a component and contains all the markup, data, styles and logic it needs. It's also designed with dependency management in mind, allowing it to declare library and component dependencies. Best of all, component files are written in the same way regardless of the development process involved, build step or none.\n\n\nExample component file\n\n\n!-- Example component file --\n\n\n\n!-- Import a component named Foo from the file foo.html. --\n\n\nlink rel='ractive' href='foo.html' name='foo'\n\n\n\n!-- Define the markup for this component. --\n\n\nh1\n{{ title }}\n/h1\n\n\n\n!-- Use imported foo component --\n\n\np\nThis is an imported 'foo' component: \nfoo/\n/p\n\n\n\n!-- Define the styles for this component. --\n\n\nstyle\n\n  p { color: red; }\n\n/style\n\n\n\n!-- Define the behavior for this component. --\n\n\nscript\n\nconst $ = require( 'jquery' )\n\ncomponent.exports = {\n  onrender () {\n    $('\np /\n').text('component rendered').insertAfter($this.find('p'))\n  },\n  data: {\n    title: 'Hello World!'\n  }\n}\n\n/script\n\n\n\n\n\nThe above component file roughly translates to the following in vanilla JS:\n\n\nimport Ractive from 'ractive'\nimport $ from 'jquery'\nimport foo from './foo.html'\n\nexport default Ractive.extend({\n  components: { foo },\n  onrender () {\n    $('\np /\n').text('component rendered').insertAfter($this.find('p'))\n  },\n  data: {\n    title: 'Hello World!'\n  },\n  template: `\n    \nh1\n{{ title }}\n/h1\n\n    \np\nThis is an imported 'foo' component: \nfoo/\n/p\n\n  `,\n  css: `\n    p { color: red; }\n  `\n})\n\n\n\n\nWriting\n\n\nlink rel=\"ractive\"\n\n\nTop-level \nlink rel=\"ractive\"\n elements define dependencies on other components. It accepts two attributes:\n\n\n\n\n\n\nhref\n - The path to the required component file. Paths that start with \n./\n or \n../\n are resolved relative to the importing component file. Otherwise, resolution is loader-specific.\n\n\n\n\n\n\nname\n (optional) - The registered name of the component. This corresponds to the key used in the \ncomponents\n initialization option. When not defined, the filename of the dependency will be used as the name.\n\n\n\n\n\n\nThe names and the loaded dependency will be assigned to the component's \ncomponents\n initialization option.\n\n\nstyle\n\n\nTop-level \nstyle\n elements define the styles for the component. If more than one \nstyle\n element is found on the component file, their contents are concatenated in the order of appearance of the \nstyle\n elements. Contents of these elements will be concatenated and assigned to the component's \ncss\n initialization option.\n\n\nscript\n\n\nA top-level \nscript\n defines the component's initialization. The script's scope has a \ncomponent\n object that is similar to Node's \nmodule\n object. Initialization options for the component is expected via \ncomponent.exports\n. It also has a special \nrequire\n function that fetches script dependencies. \nrequire\n's behavior depends on the loader used. Refer to the specific loader's documentation to know more.\n\n\nThere can only ever be one \nscript\n in a component file. Defining more than one will result in the loader throwing an error.\n\n\nTemplate\n\n\nAfter yanking out top-level \nlink rel=\"ractive\"\n, \nstyle\n or \nscript\n from the component file, anything that's left becomes a part of the template. The remaining markup will be assigned to the component's \ntemplate\n initialization option.\n\n\nUsing\n\n\nIn order to use component files, you will have to use \nloaders\n, Head over to \nthe loaders page\n to learn more about loaders and help you choose a loader that suits your needs.", 
            "title": "API"
        }, 
        {
            "location": "/api/#api", 
            "text": "This page contains  all  of the main API available in Ractive, including that provided by templates. This can be a little bit overwhelming, but it's also very searchable. If you're new to Ractive and not exactly sure what you're looking for, we recommend starting with  the tutorial  to get the basics and circling back here later. Here's a basic breakdown of the sections and what you can find in them:    Mustaches  This section describes the main template constructs that are used in Ractive. Plain mustaches  {{like_this}}  are used to inject values into the DOM.  {{#if conditionals}}  are used to conditionally add or remove content.  {{#each iterations}}  are used to display content for every element in a list or object.  {{#with contexts}}  are used to scope data for a section of template.    Data Binding, Directives, Special References  These sections make up the remainder of the template constructs that are used in Ractive. Directives control things like how an element transitions in an out of the DOM, what event listeners are installed on an element, and how two-way bindings are handled. Data Binding describes the different form element bindings available and the special directives that are used to apply them. Special References describes all of the template context-based magic variables that are automatically supplied to your template by Ractive.    Initialization Options  These are the options you can pass into a Ractive constructor to control how the instance behaves. Some of them can also be passed to  extend  and  extendWith  to control how a Ractive component behaves. This is where you'll find how to specify your template, data, event listeners, and observers that define your app, as well as options to control other behavior.    Static Properties  These are properties available either solely on the  Ractive  constructor singleton or on component constructors that have been created by  extend  or augmented by  extendWith . Global plugin registries and prototypes are found here.     Static Methods  This is a collection of helper functions that do things like parse a template, provide instance-free access to cross-instance state, create or augment Ractive components, and perform utility functions, like escaping keypaths.    Instance Properties  These are mostly instance-local plugin registries, but they also include things like references to parent and root instances for components.    Instance Methods  Along with the template and a few init options, these make up your primary interface with Ractive. You can interact with data ( get ,  set ,  toggle , array methods), invalidate data ( update ), find child DOM nodes and components ( find ,  findComponent , etc), handle event subscriptions ( on ,  off , etc), manage rendering ( render ,  insert ,  detach ,  unrender ), and get a handle to a Context based on a selector or a DOM node ( getContext ).    Context Object  Context objects are a handle to a specific point in a template, usually based on a DOM node. They bridge the gap between the template and the DOM, so that you can interact with the template directly. Context objects contain analogs to all of the instance methods available on a Ractive instance, but these methods are scoped to the context with which they are associated. This allows you to do things like set relative paths, check to see if an element has an event directive, and interact with any bindings. Context objects are automatically provided as the first argument to any event listener. They can also be acquired from a template using the  @context  special reference and from the API using  getContext .", 
            "title": "API"
        }, 
        {
            "location": "/api/#mustaches", 
            "text": "", 
            "title": "Mustaches"
        }, 
        {
            "location": "/api/#variables", 
            "text": "{{ }} ,  {{  }}  and  {{{ }}}  render a reference. They are also used for binding when used on directives.  {{ }}  escapes the reference while  {{  }}  and  {{{ }}}  do not.  Ractive({\n  data: {\n    name:  Chris ,\n    company:  b GitHub /b \n  },\n  template: `\n    {{name}}       !-- Chris -- \n    {{age}}        !--  -- \n    {{company}}    !--  lt;b gt;GitHub lt;/b gt; -- \n    {{ company}}   !--  b GitHub /b  -- \n    {{{company}}}  !--  b GitHub /b  -- \n  `\n})", 
            "title": "Variables"
        }, 
        {
            "location": "/api/#sections", 
            "text": "Sections render a block of markup depending on the value referenced.  If the reference is an array, it renders the block of markup for each item in the array. The context of the section is the value of the currently iterated item. The iteration index is made available by adding a  :  after the array reference followed by the index reference.  Ractive({\n  data: {\n    people: [{name: 'Alice'},{name: 'Bob'},{name: 'Eve'}]\n  },\n  template: `\n    {{#people}} {{name}} {{/people}}\n    {{#people:i}} {{i}} {{name}} {{/people}}\n  `\n})  If the reference is an object  and the key reference is provided , the section iterates through the object properties. The context of the section is the value of the currently iterated property. The iteration key is made available by adding a  :  after the object reference followed by the key reference.  Ractive({\n  data: {\n    places: { loc1: 'server room', loc2: 'networking lab', loc3: 'pantry'}\n  },\n  template: `\n    {{#places:key}}\n      {{ key }} {{ this }}\n    {{/places}}\n  `\n})  If the reference is some other truthy value or an object but not providing the iteration key reference, it renders the block of markup using the reference as context.  Ractive({\n  data: {\n    isAdmin: true,\n    foo: {\n      bar: {\n        baz: {\n          qux: 'Hello, World!'\n        }\n      }\n    }\n  },\n  template: `\n    {{#isAdmin}} Hello Admin! {{/isAdmin}}\n\n    {{#foo.bar.baz}} {{qux}} {{/foo.bar.baz}}\n  `\n})", 
            "title": "Sections"
        }, 
        {
            "location": "/api/#inverted-sections", 
            "text": "{{^ }}  renders a block of markup if the reference is falsy or is an empty iterable.  Ractive({\n  data: {\n    real: false,\n    people: []\n  },\n  template: `\n    {{^real}} Nope, not real {{/real}}\n\n    {{^people}} There's no people {{/people}}\n  `\n})", 
            "title": "Inverted Sections"
        }, 
        {
            "location": "/api/#optional-section-closing-text", 
            "text": "Regular ( {{# }} ) and inverted ( {{^ }} ) sections can be closed with optional closing text. If the closing text is provided and the section is opened with a reference, the closing text must match the opening text. Otherwise, a warning will be issued for the mismatch. If the section is opened with an expression, the closing text will always be ignored.  Ractive({\n  data: {\n    items: [1,2,3]\n  },\n  template: `\n    {{#items}}\n      {{this}}\n    {{/items}}\n\n    {{#items}}\n      {{this}}\n    {{/}}\n\n    {{# a.concat(b) }}\n      {{this}}\n    {{/ I'm actually ignored but should be something meaningful like a.concat(b) }}\n  `\n})", 
            "title": "Optional section closing text"
        }, 
        {
            "location": "/api/#if-sections", 
            "text": "{{#if }}  renders a block of markup if the reference is truthy or a non-empty iterable.  {{else}}  and  {{elseif}}  are supported and render if the previous condition failed.  Ractive({\n  data: {\n    foo: false,\n    bar: false\n  },\n  template: `\n    {{#if foo}}\n      foo\n    {{elseif bar}}\n      bar\n    {{else}}\n      baz\n    {{/if}}\n  `\n})", 
            "title": "If sections"
        }, 
        {
            "location": "/api/#unless-sections", 
            "text": "{{#unless }}  renders a block of markup if the reference is falsy or is an empty iterable. Unlike  {{#if }} , the  {{#unless }}  section does not support  {{else}}  nor  {{elseif}} .  Ractive({\n  data: {\n    real: false,\n  },\n  template: `\n    {{#unless real}} Fake {{/unless}}\n  `\n})", 
            "title": "Unless sections"
        }, 
        {
            "location": "/api/#each-sections", 
            "text": "{{#each }}  renders the block of markup for each item in the iterable. The context of the section is the value of the currently iterated item.  {{else}}  and  {{elseif}}  are supported and render if the iterable is empty. The iterable may be an array or an object, and if it is an object, the keys will be iterated with the context of each iteration being the value at the key associated with it.  Ractive({\n  data: {\n    people: [{name: 'Alice'},{name: 'Bob'},{name: 'Eve'}]\n  },\n  template: `\n    {{#each people}}\n      Hi! I'm {{.name}}!\n    {{else}}\n      There's nobody here\n    {{/each}}\n  `\n})  If you want to refer to the item in an iteration by name, you can optionally supply an alias for it.  {{#each people as person}}Hi! I'm {{person.name}}!{{/each}}  If you would also like to refer to the current index or key for an iteration by something other than the special refs  @key  and  @index , you can also provide an alias for each of those. When aliasing key and index, only the first key alias is required, and it will always be the same as the index alias for an array because the key and index are the same thing. For an object iteration, the index alias will be the 0-based index of the key in the keys of the object being iterated.  {{#each people: index, key}}index and key are the same for an array{{/each}} !-- this works with a context alias as well -- \n{{#each people as person: index, key}}...{{/each}} !-- the second alias is not required -- \n{{#each people: i}}...{{/each}} !-- and it's only really useful when iterating an object -- \n{{#each someObject: k, i}}k is the current key and i is the current index{{/each}}  @index  and  @key  aliases are useful for nested  {{#each}}  blocks so that you have a way to refer to the outer key or index in any given iteration. It's also sometimes useful to give a more meaningful name to a key or index.  From 0.10.0  In addition to a context alias, you can also include aliases for  @keypath ,  @rootpath ,  @index , and  @key  instead of using the  : k, i  syntax. This tends to be slightly less confusing than trying to remember whether the first or second name is the key.  {{#each people as person, i as @index, path as @keypath}}...{{/each}} !-- the context alias is not required -- \n{{#each people, i as @index, path as @keypath}}...{{/each}}  There are also special aliases that can control the behavior of the  {{#each}}  block in special circumstances.  First, it's not possible to have a computed array shuffle (a keyed update, which moves iterated elements around the DOM to match new array positions rather than simply updating contents in place) because there's no way to tell the computation when an index is moved. With a plain old model, an  {{#each}}  block will automatically know how to shuffle itself if you use an array method like  splice  or a  set  with the  shuffle  option set. By setting the  shuffle  alias to either  true  or a keypath string to use to return an identity for each iteration, you can tell an  {{#each}}  with a computed array how to shuffle itself when the array changes.  true  will cause the identity of each element to be used to determine its new index, and a keypath will cause the identity of the value at that keypath from each element to determine its new index.  {{#each people, true as shuffle}}...{{/each}}\n{{#each people, 'profile.id' as shuffle}}...each person's profile id determines where they are in the list...{{/each}}  Second, computed contexts make two-way binding problematic, as updates don't propagate back to the source model automatically, or expensive, as using  syncComputedChildren  will invalidate everything involved with the computation any time the computed context is changed. The  source  alias of an  {{#each}}  block with a computed array can be set to have it map each of its iterations' contexts back to the plain model that is the basis of the computed array.  {{#each filter(people, { name: 'joe' }), people as source}}\n  {{@keypath}} will be something like `people.0` rather than a computed\n  keypath based on `filter(people, { name: 'joe' }).0`\n{{/each}}  The  as  in aliases is also optional, so  {{#each people person, @index i}}  is equivalent to  {{#each people as person, @index as i}} .", 
            "title": "Each sections"
        }, 
        {
            "location": "/api/#with-sections", 
            "text": "{{#with }}  alters the current section's context by sticking a reference in front of the resolution order. This causes everything within the section to resolve to that reference's context and data hierarchy first before the original section's.  Ractive({\n  el: 'body',\n  append: true,\n  data: {\n    foo: {\n      qux: 2,\n      bar: {\n        baz: 1\n      }\n    },\n    fee: {\n      baz: 'a'\n    }\n  },\n  template: `\n     !-- context becomes foo -- \n    {{#foo}}\n\n       !-- context becomes foo.bar -- \n      {{#bar}}\n\n         !-- resolution order: [foo.bar.baz], foo.baz, baz -- \n        {{baz}}\n\n         !-- resolution order: foo.bar.qux, [foo.qux], baz -- \n        {{qux}}\n\n         !-- sticks fee in front of foo.bar on the resolution order -- \n        {{#with ~/fee}}\n\n           !-- resolution order: [fee.baz], foo.bar.baz, foo.baz, baz -- \n          {{baz}}\n\n           !-- resolution order: fee.qux, foo.bar.qux, [foo.qux], qux -- \n          {{qux}}\n        {{/with}}\n\n      {{/}}\n    {{/}}\n  `\n})  {{else}}  and  {{elseif}}  are supported and render when the context reference does not exist.  Ractive({\n  data: {},\n  template: `\n    {{#with people}}\n      {{joe}}\n    {{/else}}\n      Context missing\n    {{/with}}\n  `\n})  {{#with }}  also allows aliasing of references, including special references. Aliasing is in the form of  reference as alias  pairs. Multiple alias pairs can be done by separating each with a comma. In this mode, the context within the block is not altered.  Ractive({\n  el: 'body',\n  append: true,\n  data: {\n    foo: 1,\n    bar: {\n      foo: 2,\n      baz: 3\n    }\n  },\n  template: `\n    {{foo}}  !-- 1 -- \n\n    {{#with foo as qux, @global as world}}\n      {{#bar}}\n        {{qux}}  !-- 1 -- \n        {{foo}}  !-- 2 -- \n        {{baz}}  !-- 3 -- \n      {{/}}\n    {{/with}}\n  `\n})  From 0.10.0  The  as  in aliases is also optional, so  {{#with foo qux, @global world}}  is equivalent to  {{#with foo as qux, @global as world}} .", 
            "title": "With sections"
        }, 
        {
            "location": "/api/#await-sections", 
            "text": "From 0.10.0  {{#await}}  sections take a value, preferrably a  Promise , and allow you to render a pending template, while waiting, a success template if resolution completes, an error template if resolution fails, and an alternate template if the value is  undefined .  {{#await value}}\n  This bit of template displays while value is unresolved.\n{{then val}}\n  This bit of template displays when value is resolved, and the resolved value is available as val.\n{{catch err}}\n  This bit of template displays if the resolution results in an error, and the error is available as err.\n{{else}}\n  This bit of template displays if the value === undefined.\n{{/await}}  All of the aliases ( val  and  err  in the example) are optional, as are each of the sections. There's also a shorthand if you don't want to use a pending template:  {{#await value then val}}{{val}} has resolved{{/await}}", 
            "title": "Await sections"
        }, 
        {
            "location": "/api/#in-template-partials", 
            "text": "{{#partial }}  defines a partial that is scoped to the nearest enclosing element or the containing component if defined at the top level of the template.  Ractive({\n  data: {\n    people: [{name: 'Alice'},{name: 'Bob'},{name: 'Eve'}],\n    places: [{name: 'server room'},{name: 'networking lab'},{name: 'pantry'}]\n  },\n  template: `\n    {{#partial item}}\n       li class= item {{this}}! /li \n    {{/partial}}\n\n     ul \n      {{#each people}}\n        {{  item }}\n      {{/each}}\n     /ul \n\n     ul \n      {{#each places}}\n        {{  item }}\n      {{/each}}\n     /ul \n\n     div \n      {{#partial scopedPartial}}\n         li class= item {{this}}! /li \n      {{/partial}}\n\n       ul \n        {{#each things}}\n          {{  scopedPartial }}\n        {{/each}}\n       /ul \n     /div \n  `\n})", 
            "title": "In-template partials"
        }, 
        {
            "location": "/api/#static-mustaches", 
            "text": "[[ ]] ,  [[  ]]  and  [[[ ]]]  render the reference only during the initial render. After the initial render, any changes to the referece will not update the UI, nor does any change on bound UI elements cause the reference to change. They are the one-time render counterparts of  {{ }} ,  {{  }}  and  {{{ }}} , respectively.  const instance = Ractive({\n  data: {\n    msg: 'Hello, World!',\n    admin: false\n  },\n  template: `\n    Will change when updated: {{ msg }}      !-- changes to  Me, Hungry!  after the change -- \n    Will not change when updated: [[ msg ]]  !-- remains  Hello, World!  after the change -- \n\n    [[# if admin ]]\n      Hello, admin\n    [[else]]\n      Hello, normal user\n    [[/if]]\n  `\n})\n\ninstance.set({ msg: 'Me, Hungry!' })\ninstance.set('admin', true) // rendering remains 'Hello, normal user'", 
            "title": "Static mustaches"
        }, 
        {
            "location": "/api/#expressions", 
            "text": "Expressions in mustaches are evaluated, and its result is used as the referenced value. Any changes to the expression's dependencies will re-evaluate the expression and update the rendered value. References to variables are taken from the current context and follow the regular reference resolution routine.  Ractive({\n  data: {\n    num1: 2,\n    num2: 3,\n    a: [1,2,3],\n    b: [4,5,6],\n    fn: () =  true\n  },\n  template: `\n    {{ num1 + num2 }}\n\n    {{# a.concat(b) }} {{this}} {{/}}\n    {{#each a.concat(b) }} {{this}} {{/each}}\n\n    {{# fn() }} Yasss!!! {{/}}\n    {{#if fn() }} Yasss!!! {{/if}}\n  `\n})  Almost any valid JavaScript expression can be used, with a few exceptions:   No assignment operators (i.e.  a = b ,  a += 1 ,  a--  and so on).  No  new ,  delete , or  void  operators.  No function literals (i.e. anything that involves the  function  keyword).   Expressions support only a subset of globals:   Array  Date  JSON  Math  NaN  RegExp  decodeURI  decodeURIComponent  encodeURI  encodeURIComponent  isFinite  isNaN  null  parseFloat  parseInt  undefined  console", 
            "title": "Expressions"
        }, 
        {
            "location": "/api/#comments", 
            "text": "{{! }}  defines a template comment. Comments are ignored by the parser and never make it to the AST.  Ractive({\n  template: `\n     h1 Today{{! ignore me }}. /h1 \n  `\n})  Note:   {{!foo}}  is also a valid expression, and expressions have a higher precedence in the parser than comments. To ensure that your comments are always treated as such, you can add a  #  after the  !  e.g.  {{!# comment }}  because  #  is never valid in an expression.", 
            "title": "Comments"
        }, 
        {
            "location": "/api/#custom-delimiters", 
            "text": "{{= =}}  defines custom delimiters. Custom delimiters should not contain whitespace or the equals sign.  Ractive({\n  data: {\n    msg: 'Hello, World!'\n  },\n  template: `\n    {{ msg }}\n\n    {{= % % =}}\n     % msg % \n  `\n})", 
            "title": "Custom delimiters"
        }, 
        {
            "location": "/api/#escaping-mustaches", 
            "text": "\\  prepended on a mustache interprets the mustache as literal text.  {{ ref }} \\{{ ref }}  !-- value {{ ref }} --   For multi-mustache structures,  \\  must be prepended on all involved mustaches.  \\{{#if foo }} \\{{ bar }} \\{{/if}}  !-- {{#if foo }} {{ bar }} {{/if}} --   To interpret a  \\  as a literal slash before a mustache, simply prepend another  \\ . Any further  \\  prepended will be treated in this manner.  Ractive({\n  data: {\n    msg: 'Hello, World!'\n  },\n  template: `\n    \\\\{{ msg }}    !-- \\Hello, World! -- \n    \\\\\\{{ msg }}   !-- \\\\Hello, World! -- \n    \\\\\\\\{{ msg }}  !-- \\\\\\Hello, World! -- \n  `\n})", 
            "title": "Escaping mustaches"
        }, 
        {
            "location": "/api/#anchors", 
            "text": "# /  define anchors which are mounting points where instances can be mounted to dynamically during runtime.  Examples  Example 1   const MyComponent = Ractive.extend({\n  template: `\n     div {{ message }} /div \n  `\n})\n\nRactive({\n  target: 'body',\n  data: {\n    msg: 'Hello, World!'\n  },\n  template: `\n     # mountpoint7 / \n  `,\n  oninit () {\n    // Create new instance\n    const myComponent = MyComponent()\n\n    // Link msg of parent to message of instance\n    myComponent.link('msg', 'message', { ractive: this })\n\n    // It's mount'in time!\n    this.attachChild(myComponent, { target: 'mountpoint7'})\n  }\n})  Example 2 : Attaching, detaching, firing events, creating two-way bindings within the template   MyComponent = Ractive.extend({\n    template: ...\n})\n\nRactive({\n    ...\n    template: `\n         button on-click= move move it /button \n         # mountpoint-one on-click= hello  message= {{msg}}  / \n         # mountpoint-two on-click= hello  message= {{ msg + ' + ' + msg }}  / \n         input value= {{msg}}  / \n    `,\n    onrender () {\n        // Create new instance\n        myInstance = MyComponent()\n        this.attachChild(myInstance, { target: 'mountpoint-one'})\n        this.on({\n            move () {\n                this.detachChild(myInstance)\n                this.attachChild(myInstance, { target: 'mountpoint-two'})\n            },\n            hello(ctx) {\n                // fire an event as you would do with a regular component\n            }\n        })\n    }\n})", 
            "title": "Anchors"
        }, 
        {
            "location": "/api/#content", 
            "text": "{{ content}}  renders the inner HTML in the context of the component. Partials, components, and any other valid template items can be used as inner HTML.  Ractive.components.ChildComponent = Ractive.extend({\n  template: `\n     div class= child-component {{ content}} /div \n  `\n})\n\nconst ractive = Ractive({\n  el: 'body',\n  data: {\n    message: 'Hello World!'\n  },\n  template: `\n     div class= ractive \n       ChildComponent message= Lorem Ipsum \n         !-- Prints  Lorem Ipsum  -- \n         div class= inner-content {{ message }} /div \n       /ChildComponent \n     /div \n  `\n})  Partials defined in the inner HTML can be used to override partials defined on the component.  Ractive.components.ChildComponent = Ractive.extend({\n  partials: {\n    messageWrapper: ' strong {{message}} /strong '\n  },\n  template: `\n     div class= child-component {{ content}} /div \n  `\n})\n\nconst ractive = Ractive({\n  el: 'body',\n  data: {\n    message: 'Hello World!'\n  },\n  template: `\n     div class= ractive \n       ChildComponent message= Lorem Ipsum \n\n         !-- Override component's messageWrapper -- \n        {{#partial messageWrapper}} em {{message}} /em {{/}}\n\n         div class= inner-content \n           !-- Renders emphasized instead of strong -- \n          {{  messageWrapper }}\n         /div \n\n       /ChildComponent \n     /div \n  `\n})", 
            "title": "{{&gt;content}}"
        }, 
        {
            "location": "/api/#yield", 
            "text": "{{yield}}  renders the inner HTML in the context of the parent component. Partials, components, and any other valid template items can be used as inner HTML.  Ractive.components.ChildComponent = Ractive.extend({\n  template: `\n     div class= child-component {{ yield }} /div \n  `\n})\n\nconst ractive = Ractive({\n  el: 'body',\n  data: {\n    message: 'Hello, World!'\n  },\n  template: `\n     div class= ractive \n       ChildComponent message= Lorem Ipsum \n         !-- Prints  Hello, World!  -- \n         div class= inner-content {{ message }} /div \n       /ChildComponent \n     /div \n  `\n})  Yields can also be customized using named yields. A named yield will look for a partial of the same name in the inner HTML and render that partial instead.  Ractive.components.ChildComponent = Ractive.extend({\n  template: `\n     div class= child-component \n      {{ yield }}\n      {{ yield italicYield }}\n      {{ yield boldYield }}\n     /div \n  `\n})\n\nconst ractive = Ractive({\n  el: 'body',\n  data: {\n    message: 'Hello World!'\n  },\n  template: `\n     div class= ractive \n       ChildComponent message= Lorem Ipsum \n\n         !-- Printed by {{ yield italicYield }} -- \n        {{#partial italicYield }} em {{message}} /em {{/}}\n\n         !-- Printed by {{ yield boldYield }} -- \n        {{#partial boldYield }} strong {{message}} /strong {{/}}\n\n         !-- Anything not a partial is printed by {{ yield }} -- \n        {{message}}\n       /ChildComponent \n     /div \n  `\n})  Since the yielded content exists entirely in the context of the container (as opposed to the component), there's no way for the yielded content to access data in the component that is yielding. To address that, yields may supply aliases that are made available to the yielded content:  const list = Ractive.extend({\n  template: `\n     ul \n      {{#each items}}\n         !-- Expose item and index to yield context. -- \n         li {{yield with . as item, @index as index}} /li \n      {{/each}}\n     /ul \n  `\n})\n\nconst ractive = Ractive({\n  el: 'body',\n  data: {\n    some: {\n      list: [ 1, 2, 3 ]\n    }\n  },\n  select(i) { console.log('you picked', i); },\n  template: `\n     !-- Pass in some.list as items into list. -- \n     list items= {{some.list}} \n\n       !-- Access item and index aliases. -- \n       a href= #  on-click= @.select(item) Item {{index}} /a \n     /list \n  `,\n  components: { list }\n})  Without the given alises, iterating a list within the component to yield the content would be useless, because the content would not have access to the current iteration. You could get around that by using a normal partial rather than a yield, but at that point, the click event on the content would result in an error because the  select  method does not exist on the  list  component.  Yield aliases are also available for named yields.  const Pager = Ractive.extend({\n  template: `\n     ul \n       li {{ yield prev }} /li \n      {{#each pages}}\n         li {{yield link with . as page}} /li \n      {{/each}}\n       li {{ yield next }} /li \n     /ul \n  `\n})\n\nconst ractive = Ractive({\n  components: { Pager },\n  el: 'body',\n  data: {\n    book: {\n      pages: [ 1, 2, 3 ]\n    }\n  },\n  template: `\n     Pager pages= {{ book.pages }} \n      {{#partial prev}} a href= #prev Prev /a {{/partial}}\n      {{#partial link}} a href= #{{ page }} {{ page }} /a {{/partial}}\n      {{#partial next}} a href= #next Next /a {{/partial}}\n     /Pager \n  `,\n})  From 0.10.0  You can also inject a context into a yield rather than aliases, in the same way that you can supply a context to a partial. When injecting a context, the container context will be accessible from the yielded template via the context parent prefix ( ^^/ ). The component context for the yield will still be the container.  const Loopy = Ractive.extend({\n  template: ` ul {{#each list}} li {{yield with .}} /li {{/each}} /ul `\n});\n\nconst ractive = new Ractive({\n  components: { Loopy },\n  target: 'body',\n  data: {\n    things: [ 1, 2, 3 ],\n    clicks: 0,\n    label: ' thing'\n  },\n  template: `{{clicks}} Loopy list= {{things}} button on-click= @.add('clicks') {{.}}{{^^/label}} /button /Loopy `\n});", 
            "title": "{{yield}}"
        }, 
        {
            "location": "/api/#data-binding", 
            "text": "", 
            "title": "Data binding"
        }, 
        {
            "location": "/api/#text-inputs", 
            "text": "Data can be bound to text inputs via the  value  directive. This includes text-like inputs such as password, email, color, tel, date, etc.  Ractive({\n  template: `\n     input type= text  value= {{ msg }} \n  `,\n  data: {\n    msg: 'Hello, World!'\n  }\n})", 
            "title": "Text inputs"
        }, 
        {
            "location": "/api/#number-inputs", 
            "text": "Numeric data can be bound to number inputs via the  value  directive. This includes number-like inputs such as range. The value from the input will automatically be converted into a number. When the input is blank, the value returned is  undefined .  Ractive({\n  template: `\n     input type= number  value= {{ daysWithoutSleep }} \n  `,\n  data: {\n    daysWithoutSleep: 2\n  }\n})", 
            "title": "Number inputs"
        }, 
        {
            "location": "/api/#file-inputs", 
            "text": "File data can be bound to file inputs via the  value  directive. The value from the input is an instance of  FileList .  Ractive({\n  template: `\n     input type= file  value= {{ file }} \n  `,\n  data: {\n    file: /* FileList instance */\n  }\n})  or by using events:   Ractive({\n  ...\n  template: `\n    {{#each foo}}\n     p \n      {{.}} :  input on-change= hello  type= file  / \n     /p \n    {{/each}}\n  `,\n  on:{\n    hello (ctx) {\n      files = ctx.node.files\n      keypath = ctx.resolve()\n      console.log('selected files:', files)\n      console.log('first file:', files[0])\n      console.log('current context: ', keypath)\n    }\n  },\n  data:{\n    foo: [1, 2, 3]\n  }\n})", 
            "title": "File inputs"
        }, 
        {
            "location": "/api/#checkboxes", 
            "text": "Boolean data can be bound to checkboxes via the  checked  directive.  Ractive({\n  template: `\n     input type= checkbox  checked= {{ isChecked }} \n  `,\n  data: {\n    isChecked: true\n  }\n})  Array data can also be bound to checkboxes via the  name  directive.  Ractive({\n  template: `\n     input type= checkbox  name= {{ selectedItems }}  value= 1 \n     input type= checkbox  name= {{ selectedItems }}  value= 2 \n     input type= checkbox  name= {{ selectedItems }}  value= 3 \n  `,\n  data: {\n    selectedItems: ['1', '2']\n  }\n})  When both  checked  and  name  bindings are present, the binding to  checked  will be honored and the binding to  name  will be treated as a regular interpolation.", 
            "title": "Checkboxes"
        }, 
        {
            "location": "/api/#radio-buttons", 
            "text": "Boolean data can be bound to radio buttons via the  checked  directive.  Ractive({\n  template: `\n     input type= radio  name= options  checked= {{ option1 }} \n     input type= radio  name= options  checked= {{ option2 }} \n     input type= radio  name= options  checked= {{ option3 }} \n  `,\n  data: {\n    option1: false,\n    option2: true,\n    option3: false\n  }\n})  Data can also be bound to radio buttons via the  name  directive.  Ractive({\n  template: `\n     input type= radio  name= {{ selectedOption }}  value= 1 \n     input type= radio  name= {{ selectedOption }}  value= 2 \n     input type= radio  name= {{ selectedOption }}  value= 3 \n  `,\n  data: {\n    selectedOption: '1'\n  }\n})", 
            "title": "Radio buttons"
        }, 
        {
            "location": "/api/#text-areas", 
            "text": "Data can be bound to text areas via the  value  directive.  Ractive({\n  template: `\n     textarea value= {{ msg }} /textarea \n  `,\n  data: {\n    msg: 'Hello, World!'\n  }\n})  Data can also be bound to text areas via its contents.  Ractive({\n  template: `\n     textarea {{ msg }} /textarea \n  `,\n  data: {\n    msg: 'Hello, World!'\n  }\n})", 
            "title": "Text areas"
        }, 
        {
            "location": "/api/#select-lists", 
            "text": "Data can be bound to select lists via the  value  directive.  Ractive({\n  template: `\n     select value= {{ selectedOption }} \n       option value= 1 Red /option \n       option value= 2 Green /option \n       option value= 3 Blue /option \n     /select \n  `,\n  data: {\n    selectedOption: '2'\n  }\n})  Array data can also be bound to select lists with the  multiple  attribute via the  value  directive.  Ractive({\n  template: `\n     select multiple value= {{ selectedItems }} \n       option value= 1 Red /option \n       option value= 2 Green /option \n       option value= 3 Blue /option \n     /select \n  `,\n  data: {\n    selectedItems: [ '2', '3' ]\n  }\n})", 
            "title": "Select lists"
        }, 
        {
            "location": "/api/#contenteditable", 
            "text": "Data can be bound to elements that have the  contenteditable  attribute via the  value  directive.  Ractive({\n  template: `\n     div contenteditable= true  value= {{ msg }} /div \n  `,\n  data: {\n    msg: 'Hello, World!'\n  }\n})\n\n// Rendered as:\n//  div contenteditable= true Hello, World! /div   There are a few caveats when binding to an element with  contenteditable :   The returned string may or may not always be HTML.  The returned string may be different from browser to browser.  Any value set on the bound data will always be rendered as HTML.", 
            "title": "contenteditable"
        }, 
        {
            "location": "/api/#directives", 
            "text": "There are two contexts in which directives are parsed: string and expression. In a string context, mustaches must be used to reference data. In an expression context, mustaches should not be used, as the expression context effectively the same as inside of mustaches. This means that  class- ,  on- ,  as- ,  -in ,  -out ,  -in-out , and  bind-  directive values, being parsed in an expression context, should never contain mustaches. Other attributes and directives are parsed in a string context.  One of the nice things about expression context is that, combined with Ractive's unquoted attribute value support, you can avoid quote plileup for string expressions using backticks. Some text editors don't really like backticks on attributes, though.  div as-tracked=`id-${.id}` \n  The tracked decorator will be passed the string  id-  + .id as an argument. /div", 
            "title": "Directives"
        }, 
        {
            "location": "/api/#twoway", 
            "text": "The element-specific directive form of the  twoway  initialization option.  !-- By default, two-way is enabled. Editing the input updates foo. -- \nTwo-way:  input type= text  value= {{ foo }}  {{ foo }} !-- With twoway= false , editing the input will not update bar. -- \nOne-way:  input type= text  value= {{ bar }}  twoway= false  {{ bar }} !-- Updating bar via the data will update the UI --  button type= button  on-click= @this.set('bar', 'baz') Set value to bar /button", 
            "title": "twoway"
        }, 
        {
            "location": "/api/#lazy", 
            "text": "The element-specific directive form of the  lazy  initialization option.  !-- Editing the input updates foo on keypress. -- \nEager:  input type= text  value= {{ foo }}  {{ foo }} !-- Editing the input updates bar only when focus moves away from the input. -- \nLazy:  input type= text  value= {{ bar }}  lazy= true  {{ bar }} !-- Editing the input updates bar only five seconds after the change. -- \nLazy:  input type= text  value= {{ bar }}  lazy= 5000  {{ bar }}", 
            "title": "lazy"
        }, 
        {
            "location": "/api/#as-42", 
            "text": "as-*  directives augment the element with decorators. It accepts optional, comma-separated expressions as arguments to the decorator function.  div as-modal Div appearing as modal /div  div as-modal= true, true, true, false Div appearing as modal /div", 
            "title": "as-*"
        }, 
        {
            "location": "/api/#class-42", 
            "text": "class-*  directives toggle individual class names based on the truthiness of its value. The part of the directive name following  class-  will be used as the class name.  class-*  directive values are processed as expressions. If there is no expression, the implicit value is  true , which is useful for applying multiple classes to an element using component  extra-attributes .  div class-foo= isFoo Adds  foo  if isFoo is truthy /div  div class-foo-bar= isFooBar Adds  foo-bar  if isFooBar is truthy /div  div class-fooBar= isFooBar Adds  fooBar  if isFooBar is truthy /div  div class-baz Always has  baz /div", 
            "title": "class-*"
        }, 
        {
            "location": "/api/#on-42", 
            "text": "on-*  directives attach event handlers to DOM elements and components.  on-*  can be used in two ways: proxy syntax or the expression syntax.  Ractive({\n  template: `\n     button type= button  on-click= clickedproxy Push me! /button \n     button type= button  on-click= ['clickedArray', 'Hello, World!'] Push me! /button \n     button type= button  on-click= @this.clickedMethod('Hello, World!') Push me! /button \n  `,\n  on: {\n    clickedproxy (context) {\n      console.log('Hello, World!')\n    },\n    clickedArray (context, msg) {\n      console.log(msg)\n    }\n  },\n  clickedMethod(msg) {\n    console.log(msg)\n  }\n})  Multiple events can also be tied to the same handler by appending event names to the directive, separating them by hyphens:  Ractive({\n  template: `\n     button type= button  on-hover-click= @this.someMethod() Push me! /button \n  `,\n  someMethod () {\n    console.log('Fires on hover and on click!')\n  }\n})", 
            "title": "on-*"
        }, 
        {
            "location": "/api/#42-in-42-out-42-in-out", 
            "text": "*-in ,  *-out , and  *-in-out  directives apply transitions to the element.  *-in  specifies intro-only,  *-out  specifies outro-only, and  *-in-out  for both intro and outro. All three directives accept optional, comma-separated expressions as arguments to the transition function.  div fade-in Fades on render /div  div fade-out Fades before removal /div  div fade-in-out Fades on render and before removal /div  div fade-in-out= { duration: 500 }, someOtherArg Fades with 500ms duration /div", 
            "title": "*-in, *-out, *-in-out"
        }, 
        {
            "location": "/api/#style-42", 
            "text": "style-*  directives update individual  style  properties of the element. The part of the directive following  style-  will be used as the style property name. Style names can either be in kebab case or camel case, and will be normalized on application.  div style-vertical-align= middle Applies style.verticalAlign /div  div style-textAlign= center Applies style.textAlign /div   style-*  directive values are processed as strings. Mustaches can also be used to supply the values. When the values are updated, the appropriate style property on the element will update to the new value.  div style-vertical-align= {{ vAlign }}  style-textAlign= {{ tAlign }} ... /div", 
            "title": "style-*"
        }, 
        {
            "location": "/api/#bind-42", 
            "text": "bind-*  directives are the same as regular attributes, except they are parsed in an expression context rather than a string context.  input value= {{foo}}  / \nis the same as input bind-value= foo  /", 
            "title": "bind-*"
        }, 
        {
            "location": "/api/#keypath-prefixes", 
            "text": "Normally, keypaths are resolved following a defined routine. But there are times where you want to skip the normal resolution routine and resolve a keypath relative to a specific data context. Keypath prefixes allow you to specify which data context a keypath resolves to, regardless if it resolves to something or not.", 
            "title": "Keypath prefixes"
        }, 
        {
            "location": "/api/#current-context", 
            "text": "Resolves the keypath relative to the current data context.   Ractive({\n  target: 'body',\n  data: {\n    spoon: 'SPOON',\n    matrix: {\n      agent: 'Smith'\n      // There is no spoon\n    }\n  },\n  template: `\n     div Outside the matrix, you have {{ spoon }} /div \n    {{# matrix }}\n       div Inside the matrix, you think you have {{ spoon }}. /div \n       div In reality, there is no {{ ./spoon }} /div \n    {{/}}\n  `\n})\n\n// Outside the matrix, you have SPOON\n// Inside the matrix, you think you have SPOON.\n// In reality, there is no", 
            "title": "Current context"
        }, 
        {
            "location": "/api/#parent-keypath", 
            "text": "Resolves the keypath relative to the parent data. This prefix can be used more than once to reference ancestors.   Ractive({\n  target: 'body',\n  data: {\n    id: 'reality',\n    dream: {\n      id: 'dream1',\n      dream: {\n        id: 'dream2',\n        dream: {\n          id: 'dream3',\n        }\n      }\n    }\n  },\n  template: `\n     div You are in {{ id }} /div \n    {{# dream }}\n       div You are in {{ id }} /div \n      {{# dream }}\n         div You are in {{ id }} /div \n        {{# dream }}\n           div You are in {{ id }} /div \n\n           div Escaping... /div \n           div You are in {{ ../id }} /div \n           div You are in {{ ../../id }} /div \n           div You are in {{ ../../../id }} /div \n        {{/}}\n      {{/}}\n    {{/}}\n  `\n})\n\n// You are in reality\n// You are in dream1\n// You are in dream2\n// You are in dream3\n// Escaping...\n// You are in dream2\n// You are in dream1\n// You are in reality", 
            "title": "Parent keypath"
        }, 
        {
            "location": "/api/#parent-context", 
            "text": "While parent keypaths and parent contexts are often the same thing, there are some scenarios in which they are very, very different. For instance, in this horribly contrived example:   Ractive({\n  target: 'body',\n  data: {\n    homebase: {\n      building1: { name: 'Operations' }\n    },\n    bases: [\n      {\n        building1: { name: 'Mess Hall' }\n      },\n      {\n        building1: { name: 'Medical Tent' }\n      }\n    ]\n  },\n  template: `\n    {{#each bases}}\n      {{#with ~/homebase}}\n         div the home base bulding1 is {{.building1.name}} /div \n         div the current iteration base building1 is {{^^/building1.name}} /div \n      {{/with}}\n    {{/each}}\n  `\n})\n\n// the home base bulding1 is Operations\n// the current iteration base building1 is Mess Hall\n// the home base bulding1 is Operations\n// the current iteration base building1 is Medical Tent", 
            "title": "Parent context"
        }, 
        {
            "location": "/api/#instance-root-context", 
            "text": "Resolves the keypath relative to the instance's root data context.   Ractive({\n  target: 'body',\n  data: {\n    room: '1',\n    portal: {\n      room: '2',\n      portal: {\n        room: '3',\n        portal: {\n          room: '4',\n        }\n      }\n    }\n  },\n  template: `\n    {{# portal }}\n      {{# portal }}\n        {{# portal }}\n           div Entering... /div \n           div You are in room {{ ~/room }} /div \n           div You are in room {{ ~/portal.room }} /div \n           div You are in room {{ ~/portal.portal.room }} /div \n           div You are in room {{ ~/portal.portal.portal.room }} /div \n        {{/}}\n      {{/}}\n    {{/}}\n  `\n})\n\n// Entering...\n// You are in room 1\n// You are in room 2\n// You are in room 3\n// You are in room 4", 
            "title": "Instance root context"
        }, 
        {
            "location": "/api/#special-references", 
            "text": "Special references are template keywords that act like data references but do not actually exist in your data. These references provide metadata regarding the current instance, context, environment, operation and more.", 
            "title": "Special references"
        }, 
        {
            "location": "/api/#this", 
            "text": "The current data context.   Ractive({\n  el: 'body',\n  data: {\n    info: {\n      message: 'Hello World!',\n      info: {\n        message: 'The quick brown fox',\n        info: {\n          message: 'jumps over the lazy dog',\n          info: {\n            message: 'Thats all folks'\n          }\n        }\n      }\n    }\n  },\n  template: `\n     div root: {{ JSON.stringify(this) }} /div \n    {{# info }}\n       div info 1: {{ JSON.stringify(this) }} /div \n      {{# info }}\n         div info 2: {{ JSON.stringify(this) }} /div \n        {{# info }}\n           div info 3: {{ JSON.stringify(this) }} /div \n          {{# info }}\n             div info 4: {{ JSON.stringify(this) }} /div \n          {{/}}\n        {{/}}\n      {{/}}\n    {{/}}\n  `,\n})\n\n// info 1: { info :{ message : Hello World! , info :{ message : The quick brown fox , info :{ message : jumps over the lazy dog , info :{ message : Thats all folks }}}}}\n// info 2: { message : Hello World! , info :{ message : The quick brown fox , info :{ message : jumps over the lazy dog , info :{ message : Thats all folks }}}}\n// info 3: { message : The quick brown fox , info :{ message : jumps over the lazy dog , info :{ message : Thats all folks }}}\n// info 4: { message : jumps over the lazy dog , info :{ message : Thats all folks }}\n// info 5: { message : Thats all folks }", 
            "title": "this"
        }, 
        {
            "location": "/api/#this_1", 
            "text": "The current Ractive instance.   Ractive({\n  el: 'body',\n  data: {\n    count: 1\n  },\n  template: `\n     div Count: {{ count }} /div \n     button type= button  on-click= @this.add('count') Increment /button \n     button type= button  on-click= @this.myMethod() Log count /button \n  `,\n  myMethod () {\n    console.log(`current count is ${this.get('count')}`)\n  }\n})  @this  can also be referenced by using its shorthand  @ .   Ractive({\n  el: 'body',\n  data: {\n    count: 1\n  },\n  template: `\n     div Count: {{ count }} /div \n     button type= button  on-click= @.add('count') Increment /button \n     button type= button  on-click= @.myMethod() Log count /button \n  `,\n  myMethod () {\n    console.log(`current count is ${this.get('count')}`)\n  }\n})", 
            "title": "@this"
        }, 
        {
            "location": "/api/#index", 
            "text": "The current iteration index of the containing repeated section.   Ractive({\n  el: 'body',\n  data: {\n    users: [\n      { name: 'bob' },\n      { name: 'alice' },\n      { name: 'eve' },\n    ]\n  },\n  template: `\n    {{#each users}}\n       div User #{{ @index }} says: Hi! I'm {{ name }}! /div \n    {{/each}}\n  `\n})\n\n// User #0 says: Hi! I'm bob!\n// User #1 says: Hi! I'm alice!\n// User #2 says: Hi! I'm eve!  For objects,  @index  is still the iteration index.   Ractive({\n  el: 'body',\n  data: {\n    users: {\n      bob: 'Hi! I am bob!',\n      alice: 'Hi! I am alice!',\n      eve: 'Hi! I am eve!'\n    }\n  },\n  template: `\n    {{#each users}}\n       div User #{{ @index }} says: {{ this }} /div \n    {{/each}}\n  `\n})\n\n// User #0 says: Hi! I am bob!\n// User #1 says: Hi! I am alice!\n// User #2 says: Hi! I am eve!", 
            "title": "@index"
        }, 
        {
            "location": "/api/#key", 
            "text": "The current key name of the containing object iteration section.   Ractive({\n  el: 'body',\n  data: {\n    users: {\n      bob: 'Hi! I am bob!',\n      alice: 'Hi! I am alice!',\n      eve: 'Hi! I am eve!'\n    }\n  },\n  template: `\n    {{#each users}}\n       div User {{ @key }} says: {{ this }} /div \n    {{/each}}\n  `\n})\n\n// User bob says: Hi! I am bob!\n// User alice says: Hi! I am alice!\n// User eve says: Hi! I am eve!  For arrays,  @key 's value will be the iteration index.   Ractive({\n  el: 'body',\n  data: {\n    users: [\n      { name: 'bob' },\n      { name: 'alice' },\n      { name: 'eve' },\n    ]\n  },\n  template: `\n    {{#each users}}\n       div User #{{ @key }} says: Hi! I'm {{ name }}! /div \n    {{/each}}\n  `\n})\n\n// User #0 says: Hi! I'm bob!\n// User #1 says: Hi! I'm alice!\n// User #2 says: Hi! I'm eve!", 
            "title": "@key"
        }, 
        {
            "location": "/api/#last", 
            "text": "The index of the last iteration of the nearest iterative block. This is helpful for detecting the end of an object iteration.  Ractive({\n  el: 'body',\n  data: {\n    users: {\n      bob: 'Hi! I am bob!',\n      alice: 'Hi! I am alice!',\n      eve: 'Hi! I am eve!'\n    }\n  },\n  template: `\n    {{#each users}}\n       div {{@key}}{{#if @last === @index}} is the last user{{/if}} /div \n    {{/each}}\n  `\n})\n\n// bob\n// alice\n// eve is the last user", 
            "title": "@last"
        }, 
        {
            "location": "/api/#keypath", 
            "text": "The keypath to the current data context relative to the instance's root data context.   Ractive({\n  el: 'body',\n  data: {\n    foo: {\n      bar: {\n        baz: {\n          message: 'hello world'\n        }\n      }\n    }\n  },\n  template: `\n     div Keypath: {{ @keypath }} /div \n    {{# foo }}\n       div Keypath: {{ @keypath }} /div \n      {{# bar }}\n         div Keypath: {{ @keypath }} /div \n        {{# baz }}\n           div Keypath: {{ @keypath }} /div \n        {{/}}\n      {{/}}\n    {{/}}\n  `\n})\n\n// Keypath:\n// Keypath: foo\n// Keypath: foo.bar\n// Keypath: foo.bar.baz  If the keypath is a mapping, the keypath will remain relative to the instance.   Ractive.components.Message = Ractive.extend({\n  data: () =  ({\n    info : {},\n  }),\n  template: `\n    {{# info }}\n       div Sender: {{ name }} /div \n       div Message: {{ message }} /div \n       div Keypath: {{ @keypath }} /div \n    {{/}}\n  `\n})\n\nRactive({\n  el: 'body',\n  data: {\n    mail: {\n      inbox: {\n        messages: [{\n          name: 'bob',\n          message: 'Hi alice!'\n        },{\n          name: 'bob',\n          message: 'Hi eve!'\n        }]\n      }\n    }\n  },\n  template: `\n    {{# mail.inbox.messages }}\n       Message info= {{ this }}  / \n    {{/}}\n  `\n})\n\n// Sender: bob\n// Message: Hi alice!\n// Keypath: info\n// Sender: bob\n// Message: Hi eve!\n// Keypath: info", 
            "title": "@keypath"
        }, 
        {
            "location": "/api/#rootpath", 
            "text": "The keypath to the current data context relative to the originating instance's root data context.   Ractive({\n  el: 'body',\n  data: {\n    foo: {\n      bar: {\n        baz: {\n          message: 'hello world'\n        }\n      }\n    }\n  },\n  template: `\n     div Keypath: {{ @rootpath }} /div \n    {{# foo }}\n       div Keypath: {{ @rootpath }} /div \n      {{# bar }}\n         div Keypath: {{ @rootpath }} /div \n        {{# baz }}\n           div Keypath: {{ @rootpath }} /div \n        {{/}}\n      {{/}}\n    {{/}}\n  `\n})\n\n// Keypath:\n// Keypath: foo\n// Keypath: foo.bar\n// Keypath: foo.bar.baz  If the keypath is a mapping, it will be adjusted relative to the originating instance's root data context. This is what primarily sets  @rootpath  apart from  @keypath .   Ractive.components.Message = Ractive.extend({\n  data: () =  ({\n    info : {},\n  }),\n  template: `\n    {{# info }}\n       div Sender: {{ name }} /div \n       div Message: {{ message }} /div \n       div Keypath: {{ @rootpath }} /div \n    {{/}}\n  `\n})\n\nRactive({\n  el: 'body',\n  data: {\n    mail: {\n      inbox: {\n        messages: [{\n          name: 'bob',\n          message: 'Hi alice!'\n        },{\n          name: 'bob',\n          message: 'Hi eve!'\n        }]\n      }\n    }\n  },\n  template: `\n    {{# mail.inbox.messages }}\n       Message info= {{ this }}  / \n    {{/}}\n  `\n})\n\n// Sender: bob\n// Message: Hi alice!\n// Keypath: mail.inbox.messages.0\n// Sender: bob\n// Message: Hi eve!\n// Keypath: mail.inbox.messages.1", 
            "title": "@rootpath"
        }, 
        {
            "location": "/api/#global", 
            "text": "The global object of the current environment. For browsers, it references the  window  object. For Node.js, it references the  global  object.   window.message = 'Hello World!'\n\nRactive({\n  el: 'body',\n  template: `\n    {{ @global.message }}\n  `\n})\n\n// Hello World!  Ractive can automatically update properties on  @global  via two-way binding. However, for changes caused externally,  ractive.update()  must be called to re-render the UI.   window.message = 'Hello World!'\n\nRactive({\n  el: 'body',\n  template: `\n    {{ @global.message }}\n     input type= text  value= {{ @global.message }} \n     button type= button  on-click= @this.logReference() Log reference value /button \n     button type= button  on-click= @this.logGlobal() Log global value /button \n     button type= button  on-click= @this.setFooBarBaz() Change to  foo bar baz  directly /button \n     button type= button  on-click= @this.update('@global.message') Click to update /button \n\n     ol \n       li Click  Log reference value  and look at the console /li \n       li Click  Log global value  and look at the console /li \n       li Change the input value and repeat steps 1 and 2 /li \n       li Click  Change to 'foo bar baz' directly /li \n       li Repeat steps 1 and 2 and notice that step 1 was not aware of the direct change /li \n       li Click  Click to update /li \n       li Repeat steps 1 and 2 and notice that both steps are now aware /li \n     /ol \n  `,\n  logReference () {\n    console.log(this.get('@global.message'))\n  },\n  logGlobal () {\n    console.log(window.message)\n  },\n  setFooBarBaz () {\n    window.message =  foo bar baz \n  }\n})", 
            "title": "@global"
        }, 
        {
            "location": "/api/#shared", 
            "text": "@shared  is a Ractive-global model similar to  @global  but not subject to interference from outside of Ractive.", 
            "title": "@shared"
        }, 
        {
            "location": "/api/#context", 
            "text": "The context object associated with the current context.", 
            "title": "@context"
        }, 
        {
            "location": "/api/#event", 
            "text": "The DOM event that is triggering an event directive. This reference is only available to event directive expressions.", 
            "title": "@event"
        }, 
        {
            "location": "/api/#node", 
            "text": "The DOM node associated with an event directive. This reference is only available to event directive expressions.", 
            "title": "@node"
        }, 
        {
            "location": "/api/#local", 
            "text": "Special context-local storage associated with the current context. This is intended more for library use with decorators and parser transforms.", 
            "title": "@local"
        }, 
        {
            "location": "/api/#style", 
            "text": "From 0.9.4  The cssData associated with the current instance based on its constructor.", 
            "title": "@style"
        }, 
        {
            "location": "/api/#n", 
            "text": "$n  is a reference available when handing events using the expression syntax that points to a specific argument passed by the event. Argument positions are denoted by the  n  which is a one-indexed integer.  const CustomButton = Ractive.extend({\n  template: `\n     button on-click= @this.fire('buttonevent', 'foo', 'bar') Click Me /button \n  `\n})\n\nRactive({\n  components: { CustomButton },\n  template: `\n     !-- Use with proxy expression syntax -- \n     CustomButton on-buttonevent= ['proxy', $1, $2]  / \n\n     !-- Use with method call -- \n     CustomButton on-buttonevent= @this.method($1, $2)  / \n  `,\n  on: {\n    proxy (context, foo, bar) {\n      console.log(foo, bar)\n    }\n  },\n  method (foo,bar) {\n    console.log(foo, bar)\n  }\n})", 
            "title": "$n"
        }, 
        {
            "location": "/api/#arguments", 
            "text": "arguments  is a reference available when handling events using the expression syntax that points to an array of arguments passed by the event.  const CustomButton = Ractive.extend({\n  template: `\n     button on-click= @this.fire('buttonevent', 'foo', 'bar') Click Me /button \n  `\n})\n\nRactive({\n  components: { CustomButton },\n  template: `\n     !-- Use with proxy expression syntax -- \n     CustomButton on-buttonevent= ['proxy', arguments]  / \n\n     !-- Use with method call -- \n     CustomButton on-buttonevent= @this.method(arguments)  / \n  `,\n  on: {\n    proxy (context, args) {\n      console.log(args)\n    }\n  },\n  method (foo,bar) {\n    console.log(args)\n  }\n})  arguments  is a normal array instance and not the special  arguments  JavaScript variable.", 
            "title": "arguments"
        }, 
        {
            "location": "/api/#initialization-options", 
            "text": "The following is an exhaustive list of initialisation options that you can pass to  Ractive()  and  Ractive.extend() . Extra properties passed as options that are not initialization options are added as properties or methods of the instance.  var ractive = Ractive({\n  myMethod () {\n    alert( 'my method was called' )\n  }\n})\n\nractive.myMethod(); // triggers the alert", 
            "title": "Initialization Options"
        }, 
        {
            "location": "/api/#adapt", 
            "text": "(Array string|Object )  An array of adaptors to use. Values can either be names of registered adaptors or an adaptor definition.  adapt: [ 'MyAdaptor', AdaptorDefinition ]  adapt  is not required if you registered adaptors via the  adaptors  initialization property. The adaptors registered via  adaptors  initialization property are automatically used as if they were set with  adapt .  const instance = Ractive({\n  adaptors: { MyAdaptor: AdaptorDefinition }\n  // No need to use adapt\n})\n\nconst Component = Ractive.extend({\n  adaptors: { MyAdaptor: AdaptorDefinition }\n  // No need to use adapt\n})\n\nnew Component({\n  // No need to use adapt\n})", 
            "title": "adapt"
        }, 
        {
            "location": "/api/#adaptors", 
            "text": "(Object string, Object )  A map of adaptors where the key is the adaptor name and the value is an adaptor definition.  adaptors: {\n  MyAdaptor: AdaptorDefinition\n}  Registering an adaptor via  adaptors  is not required if you directly specified the adaptor definition via  adapt .  const Adaptor = { ... }\n\nconst instance = Ractive({\n  adapt: [ AdaptorDefinition ]\n  // No need to use adaptors\n})", 
            "title": "adaptors"
        }, 
        {
            "location": "/api/#allowexpressions", 
            "text": "From 0.10.0  (boolean)  Indicates whether or not Ractive should process expressions. Defaults to  true .  Setting this to  false  effectively avoids the use of the  Function  constructor at the cost of not being able to use expressions such as those found in templates and computed properties.", 
            "title": "allowExpressions"
        }, 
        {
            "location": "/api/#append", 
            "text": "(boolean|string|HTMLElement|array-like)  Controls how the instance is attached to  el . Defaults to  false .  false  replaces the contents of  el .  !-- before --  div id='container' \n   p existing content /p  /div   el: '#container',\nappend: false,\ntemplate: ' p new content /p '  !-- after --  div id='container' \n   p new content /p  /div   true  appends the instance to  el .  !-- before --  div id='container' \n   p existing content /p  /div   el: '#container',\nappend: true,\ntemplate: ' p new content /p '  !-- after --  div id='container' \n   p existing content /p \n   p new content /p  /div   An  id  of the element, a CSS selector to an element, an HTML element, or an array-like object whose first item is an HTML element, which is a child of  el  will render the instance before that element.  !-- before --  div id='container' \n   p red /p \n   p orange /p \n   p yellow /p  /div   el: '#container',\nappend: document.querySelector('p:nth-child(2)'),\ntemplate: ' p grey /p '  !-- after --  div id='container' \n   p red /p \n   p grey /p \n   p orange /p \n   p yellow /p  /div", 
            "title": "append"
        }, 
        {
            "location": "/api/#attributes", 
            "text": "(Object string, [string]|Object string, [string] )  An array of optional attributes or a map of optional and required attributes. Defaults to  undefined .  You can supply a list of optional attributes using an array. You can also supply an object with an  optional  array of attribute names and a  required  array of attribute names. At runtime, if a component is created missing a required attribute, Ractive will issue a warning about missing required attributes. Any attributes that are passed to the component that are  not  included in either of the  optional  or  required  lists of attributes will be collected into a partial named  extra-attributes  so that they can be included on a top-level element in the component template or split apart to be used in a component  init  event.  const Component = Ractive.extend({\n  template: ` div class-component-wrapper {{yield extra-attributes}} Fancy component doing something with list and type /div `,\n  attributes: {\n    required: [ 'list' ],\n    optional: [ 'type' ]\n  }\n})\n\n//  Component type= foo  /  will issue a warning about missing list\n//  Component list= {{things}}  style-color= green  /  will not warn, but will include the style-color= green  on the wrapper div  The extra attributes passed to a component are not limited to simple attributes - they can also include directives, but any mustache sections will not have their contents checked. By default, the  extra-attributes  will  not  be mapped, meaning that the values won't be available with  get  from the component, so the partial should be yielded. If you need the extra attributes to be mapped, include an additional setting in the attributes map  mapAll: true .", 
            "title": "attributes"
        }, 
        {
            "location": "/api/#components", 
            "text": "(Object string, Function|Promise)  A map of components available to the instance or component being configured. The key is the registered name of the component, which is used in the template.  A component can be registered statically by assinging a component definition.  const MyStaticComponent = Ractive.extend({ ... })\n\nconst MyComponent = Ractive.extend({\n  components: { MyStaticComponent },\n  template: `\n     MyStaticComponent / \n  `\n})  A component can be registered dynamically by assinging a function that returns either a component definition, or a name of a registered component. The function receives  data  as first argument.  Ractive.components.GlobalComponent = Ractive.extend({ ... })\n\nconst NonGlobalComponent = Ractive.extend({ ... })\n\nconst MyComponent = Ractive.extend({\n  data: { isGlobal: false },\n  components: {\n    MyDynamicComponent: (data) =  data.isGlobal ? 'GlobalComponent' : NonGlobalComponent\n  },\n  template: `\n     MyDynamicComponent / \n  `\n})  A component can be loaded asynchronously by assingning a promise that resolves with a component definition.   // Assuming MyAsyncComponent.js does `export default Ractive.extend({ ... })`\n\nconst MyComponent = Ractive.extend({\n  components: {\n    MyAsyncComponent: import('./path/to/MyAsyncComponent.js')\n  },\n  template: `\n     MyAsyncComponent / \n  `\n})  A component can be loaded lazily by assinging a function that returns a promise that resolves with a component definition. Ractive only loads the component when it's being rendered.   // Assuming MyAsyncComponent.js does `export default Ractive.extend({ ... })`\n\nconst MyComponent = Ractive.extend({\n  components: {\n    MyAsyncComponent: () =  import('./path/to/MyAsyncComponent.js')\n  },\n  template: `\n     MyAsyncComponent / \n  `\n})  In both asynchronous cases, instances will be rendered immediately while the asynchronous components load. Once the asynchronous components are available, their placeholders will be re-rendered. Two reserved partial names,  async-loading  and  async-loaded , can be used to define markup when the asynchronous component is loading and loaded, respectively. A special partial named  component  is also available to render the component's contents inside  async-loaded .   // Assuming MyAsyncComponent.js does `export default Ractive.extend({ ... })`\n\nconst MyComponent = Ractive.extend({\n  components: {\n    MyAsyncComponent: import('./path/to/MyAsyncComponent.js')\n  },\n  template: `\n     span I'm rendered immediately. I don't wait for MyAsyncComponent /span \n     MyAsyncComponent \n      {{#partial async-loading}}I'm rendered when MyAsyncComponent is loading{{/partial}}\n      {{#partial async-loaded}}I'm rendered when MyAsyncComponent is loaded{{/partial}}\n      {{#partial async-loaded}}MyAsyncComponent contents: {{ component}}{{/partial}}\n     /MyAsyncComponent \n  `\n})  During a  ractive.reset() , components registered using a function are re-evaluated. If the return value changes, the Ractive instance will be re-rendered.", 
            "title": "components"
        }, 
        {
            "location": "/api/#computed", 
            "text": "(Object string, function|Object )  A map of computed properties where the key is the name of the computed property and the value is either a computed property expression, a function that returns a value, or an object that has  get  and  set  functions.  // Imagine a square...\ncomputed: {\n  // Computed property expression\n  diagonal: '${side} * Math.sqrt(2)',\n\n  // A function\n  perimeter () {\n    return 4 * this.get('side')\n  },\n\n  // An object with get and set functions\n  area: {\n    get () {\n      return Math.pow(this.get('side'), 2)\n    },\n    set (value) {\n      this.set('side', Math.sqrt(value))\n    }\n  },\n}", 
            "title": "computed"
        }, 
        {
            "location": "/api/#csp", 
            "text": "(boolean)  Whether or not to add inline functions for expressions after parsing. Defaults to  false .  This can effectively eliminate  eval  caused by expressions in templates. It also makes the resulting template no longer JSON compatible, so the template will have to be served via  script  tag.", 
            "title": "csp"
        }, 
        {
            "location": "/api/#css", 
            "text": "(string|function)  Scoped CSS for a component and its descendants.  css: `\n  .bold { font-weight: bold }\n`  At the moment, only applies to components.  // This works\nconst Component = Ractive.extend({\n  css: '...'\n})\n\n// This will not work\nRactive({\n  css: '...'\n})  From 0.9.4 , if  css  is a function, the function will be called with a handle to the component's style data and is expected to return a string of CSS.  const Component = Ractive.extend({\n  css(data) {\n    // you can use Ractive.styleSet('colors.special', 'pink') or Component.styleSet('colors.special', 'pink')\n    // at any time to override the default here, which is green\n    return `\n      .super-special { color: ${data('colors.special') || 'green'}; }\n    `\n  }\n})", 
            "title": "css"
        }, 
        {
            "location": "/api/#cssdata", 
            "text": "From 0.9.4  (object)  Like  css , this also only applies to components. This is the default data for a component's style computation, if it has one. It is inherited from parent components all the way back to Ractive, and any changes that are made at any point in the hierarchy are automatically propagated down from that point. This means that if a component uses  foo  in its style computation but does not define a value for it in its  cssData , then calling  Ractive.styleSet('foo', ...)  will cause the component style to recompute.", 
            "title": "cssData"
        }, 
        {
            "location": "/api/#cssid", 
            "text": "(string)  This value is used to scope CSS defined on a component's  css  initialization option only to the instances of the component. By default, the value is a randomly generated UUID.", 
            "title": "cssId"
        }, 
        {
            "location": "/api/#data", 
            "text": "(Object string, any |Function)  The data for an instance, or default data for a component. Can either be an object or a function that returns an object.  // Object form\ndata: {\n  foo: 'bar'\n}\n\n// Function form\ndata () {\n  return { foo: 'bar' }\n}\n\n// Function form using arrow function for less verbosity\ndata: () =  ({\n  foo: 'bar'\n})  When using the object form, the data is attached to the component's prototype. Standard prototype rules apply.  const Component = Ractive.extend({\n  data: {\n    foo: { bar: 42 }\n  }\n})\n\nvar component1 = Component()\nvar component2 = Component()\ncomponent1.set( 'foo.bar', 12 )\ncomponent2.get( 'foo.bar' ); // returns 12  When using the function form, the function is executed to give each instance a copy of the data. Standard prototype rules apply.  const Component = Ractive.extend({\n  data () {\n    return {\n      foo: { bar: 42 }\n    }\n  }\n})\n\nvar component1 = Component()\nvar component2 = Component()\ncomponent1.set( 'foo.bar', 12 )\ncomponent2.get( 'foo.bar' ); // returns 42  When extending from a constructor, data from the parent constructor will be shallow-copied over to the child data. Child data takes precedence in the event of collisions.  const Parent = Ractive.extend({\n  data: {\n    foo: 'Hello',\n    bar: 'World'\n  }\n})\n\nconst Child = Parent.extend({\n  data: {\n    foo: 'Goodbye'\n  }\n})\n\nParent().get(); // { foo: 'Hello', bar: 'World' }\nChild().get();  // { foo: 'Goodbye', bar: 'World' }", 
            "title": "data"
        }, 
        {
            "location": "/api/#decorators", 
            "text": "(Object string, Function )  A map of decorators where the key is the decorator name and the value is a decorator definition.  decorators: {\n  MyDecorator: DecoratorDefinition\n}", 
            "title": "decorators"
        }, 
        {
            "location": "/api/#delegate", 
            "text": "(boolean)  Whether or not to enable automatic event delegation for iterative sections within an element. Defaults to  true .  When enabled, DOM events subscribed within iterative sections will not add a DOM event listener to each element. Instead, a single listener will be installed on the element containing the iterative section, and that listener will find appropriate event directives starting from the target element and working back to the containing element with the listener.", 
            "title": "delegate"
        }, 
        {
            "location": "/api/#delimiters", 
            "text": "(Array[string])  Sets the template delimiters. Defaults to  [ '{{', '}}' ] .  delimiters: [ ' %=', '% ' ],\ntemplate: 'hello  %= world % ',\ndata: { world: 'earth' }\n\n// result:\n// hello earth", 
            "title": "delimiters"
        }, 
        {
            "location": "/api/#easing", 
            "text": "(Object string, Function )  A map of easing functions where the key is the easing function name and the value is the easing function.  easing: {\n  MyEasing: EasingDefinition\n}", 
            "title": "easing"
        }, 
        {
            "location": "/api/#el", 
            "text": "(string|HTMLElement|array-like)  The element to render an instance to. Can either be an  id  of the element, a CSS selector to an element, an HTML element, or an array-like object whose first item is an HTML element.  el: 'container'\nel: '#container'\nel: document.getElementById('container')\nel: jQuery('#container')", 
            "title": "el"
        }, 
        {
            "location": "/api/#enhance", 
            "text": "(boolean)  Whether or not to apply progressive enhancement by inspecting the contents of  el  and try to reuse as much of the existing tree as possible. Defaults to  false .  There are a few limitations to this feature:    This option cannot be used with  append .    Unescaped HTML mustaches (triples) don't play nicely with enhance because there's no easy way to match up the string content to the target DOM nodes.    All matching elements will be reused, except for a few cases regarding text nodes.  div left text {{#if foo}} middle text {{/if}} right text /div  HTML does not have markup representation for adjacent text nodes. Rendering the snippet above from the server, regardless of  foo 's value, the browser creates one contiguous text node. However, Ractive will need  three  adjacent text nodes to represent it: One for  outer text , another for  right text  and another for  middle text  when  foo  becomes truthy.  It has been suggested that Ractive could deal with merged text nodes, but that would lead to extra complexity as there are certain scenarios where the text node would have to split and rejoin. When  foo  is falsey,  left text  and  right text  could be merged. But when  foo  becomes truthy, that text node would have to split in order to accomodate  middle text .", 
            "title": "enhance"
        }, 
        {
            "location": "/api/#events", 
            "text": "(Object string, Function )  A map of events where the key is the event name and value is an event definition.  events: {\n  MyEvent: EventDefinition\n}", 
            "title": "events"
        }, 
        {
            "location": "/api/#interpolate", 
            "text": "(Object string, boolean )  A map of elements that controls whether or not interpolation is allowed within the element. If an element is present in the map, then nested tags are treated as text rather than elements, as in a  script  tag. If the value associated with the element is  false , mustaches within the element are also treated as text rather than blocks or interpolators.  interpolate: {\n  textarea: true,\n  script: true,\n  style: true,\n  template: true\n}", 
            "title": "interpolate"
        }, 
        {
            "location": "/api/#interpolators", 
            "text": "(Object string, Function )  A map of interpolators where the key is the interpolator name and the value is an interpolator definition.  interpolators: {\n  MyInterpolator: InterpolatorDefinition\n}", 
            "title": "interpolators"
        }, 
        {
            "location": "/api/#isolated", 
            "text": "(boolean)  Controls whether the component will try to resolve data and plugins on its ancestors. Defaults to  true .  Relevant only to Components.", 
            "title": "isolated"
        }, 
        {
            "location": "/api/#lazy_1", 
            "text": "(boolean|number)  Whether or not to update data using late-firing DOM events (i.e.  change ,  blur ) instead of events that fire immediately on interaction (i.e.  keyup ,  keydown ). Defaults to  false .  var ractive = Ractive({\n  lazy: true,\n  data: { foo: 'bar' },\n  template: `\n     input value= {{foo}} \n\n     !-- Updates when the input loses focus -- \n    {{ foo }}\n  `\n})  lazy  also accepts a number value, a millisecond value, that indicates the delay between the last UI interaction and Ractive updating the data. Losing element focus is not required for the update to kick in.  var ractive = Ractive({\n  lazy: 1000,\n  data: { foo: 'bar' },\n  template: `\n     input value= {{foo}} \n\n     !-- Updates 1000ms after the last interaction on input -- \n    {{ foo }}\n  `\n})  lazy  is only applicable if  twoway  is  true .", 
            "title": "lazy"
        }, 
        {
            "location": "/api/#nestedtransitions", 
            "text": "(boolean)  Whether or not to allow transitions to fire if they are already downstream from a transitioning element. Defaults to  true .  {{#if outer}}\n   div fade-in='slow' \n    Outer text.\n    {{#if inner}}\n       div fly-in= fast Inner text. /div \n    {{/if}}\n   /div \n{{/if}}  In this example, if  inner  is  true  when  outer  becomes  true , then all of the  div s will render at the same time. If  nestedTransitions  is disabled, then the  fly  transition on inner  div  will not be run, since the  fade  will already be running on the outer  div .  This can also be controlled per transition using the  nested  boolean parameter for transitions:  div fade-in= { duration: 'slow', nested: false } ... /div", 
            "title": "nestedTransitions"
        }, 
        {
            "location": "/api/#nocsstransform", 
            "text": "(boolean)  Prevents component CSS from being transformed with scoping guids. Defaults to  false .", 
            "title": "noCssTransform"
        }, 
        {
            "location": "/api/#nointro", 
            "text": "(boolean)  Whether or not to skip intro transitions on initial render. Defaults to  false .  var ractive = Ractive({\n  template: ' ul {{#items}} li fade-in {{.}} /li {{/items}} /ul ',\n  data: { items: [ 'red', 'blue' ] },\n  transitions: {\n    fade ( t, params ) {...}\n  },\n  noIntro: true\n})\n// 'red' and 'blue' list items do not fade in\n\nractive.push( 'items', 'green' )\n// 'green' list item will fade in", 
            "title": "noIntro"
        }, 
        {
            "location": "/api/#nooutro", 
            "text": "(boolean)  Whether or not to skip outro transitions during an instance unrender. Defaults to  false .  var ractive = Ractive({\n  template: ' ul {{#items}} li fade-out {{.}} /li {{/items}} /ul ',\n  data: { items: [ 'red', 'blue' ] },\n  transitions: {\n    fade ( t, params ) {...}\n  },\n  noOutro: true\n})\n\nractive.pop( 'items' )\n// 'blue' list item will fade out\n\nractive.unrender()\n// 'red' list item will not fade out", 
            "title": "noOutro"
        }, 
        {
            "location": "/api/#observe", 
            "text": "(Object string, Function|Object )  A hash of observers to subscribe during initialization and unsubscribe during teardown. Defaults to  undefined .  The keys of the hash may be any string that is accepted by  ractive.observe() , and the values may be either callback functions, as would be passed to  ractive.observe() , or objects with a  handler  property that is a callback function. The object form also takes other options that control the behavior of the observer.  Ractive({\n  // ..\n  observe: {\n    show ( value ) {\n      console.log( `show changed to '${value}'` )\n    },\n    'users.*.name people.*.name': {\n      handler ( value, old, path, idx ) {\n        console.log( `${path} changed to '${value}'` )\n      },\n      init: false,\n      strict: true\n    }\n  }\n})  The options that may be specified in the object form are (see the  ractive.observe()  docs for more detailed option descriptions):   handler (Function) : The callback function for the observer.  once (boolean) : Use  ractive.observeOnce()  rather than  ractive.observe()  to install the observer, meaning the observer is implicitly  init: false , will only fire for the first change to the observed path, and will by removed after the first change.  strict (boolean) : Use strict equality when determining whether or not a value has changed.  array (boolean) : Use an array observer rather than a plain observer.  defer (boolean) : Defer the observer until after the DOM is settled.  init (boolean) : Whether or not to fire an initial change event.  links (boolean) : Whether or not to follow links.  context (any) : Context for the callback function.  old (Function) : Modifier function for the  old  value passed to the callback function.   When a sublcass created with  Ractive.extend()  is passed an  observe  hash, then any further subclasses or instances created with an  observe  hash will be combined. Any superclass observers are installed first following the inheritance hierarchy, and finally, any instance observers are installed.", 
            "title": "observe"
        }, 
        {
            "location": "/api/#on", 
            "text": "(Object string, Function|Object )  A hash of event listeners to subscribe during initialization and unsubscribe during teardown. Defaults to  undefined .  The keys of the hash may be any string that is accepted by  ractive.on() , and the values may be either callback functions, as would be passed to  ractive.on() , or objects with a  handler  property that is a callback function. The object form also takes other options that control the behavior of the event handler.  Ractive({\n  // ...\n  on: {\n    init () {\n      console.log('I will print during init')\n    },\n    '*.somethingHappened': {\n      handler ( ctx ) {\n        console.log('I will fire when this instance or any child component fires an instance event named  somethingHappened ')\n      },\n      once: true\n    }\n  },\n  // ...\n})  The options that may be specified in the object form are:   handler (Function) : The callback function for the event.  once (boolean) : Use  ractive.once()  rather than  ractive.on()  to subscribe the listener, meaning that the handler will only be called the first time the event is fired and then it will be unsubscribed.   on  event listeners may subscribe to any instance event, including lifecycle events. When a sublcass created with  Ractive.extend()  is passed an  on  hash, then any further subclasses or instances created with an  on  hash will be combined. Any superclass event handlers are installed first following the inheritance hierarchy, and finally, any instance event handlers are installed.", 
            "title": "on"
        }, 
        {
            "location": "/api/#oncomplete", 
            "text": "(Function)  A lifecycle event that is called when the instance is rendered and all the transitions have completed.", 
            "title": "oncomplete"
        }, 
        {
            "location": "/api/#onconfig", 
            "text": "(Function)  A lifecycle event that is called when an instance is constructed and all initialization options have been processed.", 
            "title": "onconfig"
        }, 
        {
            "location": "/api/#onconstruct", 
            "text": "(Function)  A lifecycle event that is called when an instance is constructed but before any initialization option has been processed.  Accepts the instance's initialization options as argument.", 
            "title": "onconstruct"
        }, 
        {
            "location": "/api/#ondestruct", 
            "text": "(Function)  A lifecycle event that is called when an instance is torn down and any associated transitions are complete.", 
            "title": "ondestruct"
        }, 
        {
            "location": "/api/#ondetach", 
            "text": "(Function)  A lifecycle event that is called whenever  ractive.detach()  is called.  Note that  ractive.insert()  implicitly calls  ractive.detach()  if needed.", 
            "title": "ondetach"
        }, 
        {
            "location": "/api/#oninit", 
            "text": "(Function)  A lifecycle event that is called when an instance is constructed and is ready to be rendered.", 
            "title": "oninit"
        }, 
        {
            "location": "/api/#oninsert", 
            "text": "(Function)  A lifecycle event that is called when  ractive.insert()  is called.", 
            "title": "oninsert"
        }, 
        {
            "location": "/api/#onrender", 
            "text": "(Function)  A lifecycle event that is called when the instance is rendered but  before  transitions start.", 
            "title": "onrender"
        }, 
        {
            "location": "/api/#onteardown", 
            "text": "(Function)  A lifecycle event that is called when the instance is being torn down.", 
            "title": "onteardown"
        }, 
        {
            "location": "/api/#onunrender", 
            "text": "(Function)  A lifecycle event that is called when the instance is being undrendered.", 
            "title": "onunrender"
        }, 
        {
            "location": "/api/#onupdate", 
            "text": "(Function)  A lifecycle event that is called when  ractive.update()  is called.", 
            "title": "onupdate"
        }, 
        {
            "location": "/api/#partials", 
            "text": "(Object string, string|Object|Function )  A map of partials where the key is the partial name and the value is either a template string, a parsed template object or a function that returns any of the previous options. The function form accepts processed  data  and  Parse Object as arguments.  partials: {\n  stringPartial: ' p {{greeting}} world! /p ',\n  parsedPartial: { v :3, t :[{ t :7, e : p , f :[{ t :2, r : greeting },  world! ]}]},\n  functionPartial (data, p) {\n    return data.condition ? ' p hello world /p ' : ' div yes, we have no foo /div '\n  }\n}  During a  ractive.reset() , function partials are re-evaluated. If the return value changes, the Ractive instance will be re-rendered.", 
            "title": "partials"
        }, 
        {
            "location": "/api/#preservewhitespace", 
            "text": "(boolean|Object string, boolean )  Whether or not to preserve whitespace in templates when parsing. Defaults to  false .  Whitespace in  pre  elements is always preserved. The browser will still deal with whitespace in the normal fashion.  If the value is a map, whitespace is not preserved by default, and the elements named in the map will have whitespace preserved based on the value of the boolean associated with their name.  var ractive = Ractive({\n  template: ' p hello\\n\\n  \\tworld    /p ',\n  preserveWhitespace: false //default\n})\n\nconsole.log( ractive.toHTML() )\n//  p hello world /p \n\nvar ractive = Ractive({\n  template: ' p hello\\n\\n  \\tworld    /p ',\n  preserveWhitespace: true\n})\n\nconsole.log( ractive.toHTML() )\n// p hello\n//\n//  world    /p", 
            "title": "preserveWhitespace"
        }, 
        {
            "location": "/api/#resolveinstancemembers", 
            "text": "(boolean)  Whether or not to include members of the Ractive instance at the end of the reference resolution process. Defaults to  false .  Prior to  0.10.0  defaults to  true .  button on-click= toggle('show') Toggle /button   If there is no data member  toggle  in the context of the template, with  resolveInstanceMembers  enabled, the reference will resolve to the  ractive.toggle()  method of the instance.", 
            "title": "resolveInstanceMembers"
        }, 
        {
            "location": "/api/#sanitize", 
            "text": "(boolean|Object)  Whether or not certain elements will be stripped from the template during parsing.  Defaults to  false .  true  strips out blacklisted elements and event attributes. See  Ractive.parse()  for the default list of blacklisted elements.  template: `\n   p some content /p \n   frame Am I a bad element or just misunderstood? /frame \n`,\nsanitize: true\n\n// result:\n//  p some content /p   The object form should have  elements  which is an array of blacklisted elements and  eventAttributes  boolean which, when  true , also strips out event attributes.  template: `\n   p some content /p \n   div onclick= doEvil() the good stuff /div \n`,\nsanitize: {\n  elements: [ 'p' ],\n  eventAttributes: true\n}\n\n// result:\n//  div the good stuff /div", 
            "title": "sanitize"
        }, 
        {
            "location": "/api/#staticdelimiters", 
            "text": "(Array[string])  Sets the static (one-time binding) delimiters. Defaults to  [ '[[', ']]' ] .  var ractive = Ractive({\n  template: 'hello [[foo]]',\n  staticDelimiters: [ '[[', ']]' ], //default\n  data: { foo: 'world' }\n})\n// result:  hello world \n\nractive.set( 'foo', 'mars' )\n// still is:  hello world", 
            "title": "staticDelimiters"
        }, 
        {
            "location": "/api/#statictripledelimiters", 
            "text": "(Array string )  Sets the static (one-time binding) triple delimiters. Defaults to  [ '[[[', ']]]' ] .  var ractive = Ractive({\n  template: 'hello [[[html]]]',\n  staticTripleDelimiters: [ '[[[', ']]]' ], //default\n  data: { html: ' span world /span ' }\n})\n// result:  hello  span world /span \n\nractive.set( 'html', ' span mars /span ' )\n// still is:  hello world", 
            "title": "staticTripleDelimiters"
        }, 
        {
            "location": "/api/#stripcomments", 
            "text": "(boolean)  Whether or not to remove comments in templates when parsing. Defaults to  true .  template: ' !-- html comment -- hello world',\nstripComments: false\n\n// result:\n//  !-- html comment -- hello world", 
            "title": "stripComments"
        }, 
        {
            "location": "/api/#synccomputedchildren", 
            "text": "(boolean)  Whether or not to invalidate the dependencies of an expression when child keypaths of the expression are updated. Defaults to  false .  Note : setting this to  true  may cause performance issues for complex expressions involving large arrays.  input value= {{pattern}}  / \n{{#each filter(users, pattern)}}\n   input value= {{.name}}  / \n{{/each}}  In this example, the  input  inside the iteration is bound to a computation e.g.  filter(users, pattern).0.name  that isn't actually an addressable model. With  syncComputedChildren  enabled, when that virtual keypath is updated by a user changing the  input , the expression will invalidate its dependencies ( filter ,  users , and  pattern ), which will cause any other references to the  user  that happens to coincide with result of the expression to also update.", 
            "title": "syncComputedChildren"
        }, 
        {
            "location": "/api/#target", 
            "text": "(string|HTMLElement|array-like)  Alias for  el .", 
            "title": "target"
        }, 
        {
            "location": "/api/#template", 
            "text": "(string|array|object|function)  The template to use. Must either be a CSS selector string pointing to an element on the page containing the template, an HTML string, an object resulting from  Ractive.parse()  or a function that returns any of the previous options. The function form accepts processed  data  and a Parse Object.  // Selector\ntemplate: '#my-template',\n\n// HTML\ntemplate: ' p {{greeting}} world! /p ',\n\n// Template AST\ntemplate: { v :3, t :[{ t :7, e : p , f :[{ t :2, r : greeting },  world! ]}]},\n\n// Function\ntemplate (data, p) {\n  return ' p {{greeting}} world! /p '\n},  During a  ractive.reset() , templates provided using a function are re-evaluated. If the return value changes, the Ractive instance will be re-rendered.", 
            "title": "template"
        }, 
        {
            "location": "/api/#transitions", 
            "text": "(Object string, Function )  A map of transitions where the key is the name of the transition and the value is a transition definition.", 
            "title": "transitions"
        }, 
        {
            "location": "/api/#transitionsenabled", 
            "text": "(boolean)  Whether or not transitions are enabled. Defaults to  true .", 
            "title": "transitionsEnabled"
        }, 
        {
            "location": "/api/#tripledelimiters", 
            "text": "(Array[string])  Sets the triple delimiters. Defaults to  [ '{{{', '}}}' ] .  template: 'hello @html@',\ntripleDelimiters: [ '@', '@' ],\ndata: { html: ' span world /span ' }\n\n// result:\n// hello  span world /span", 
            "title": "tripleDelimiters"
        }, 
        {
            "location": "/api/#twoway_1", 
            "text": "(boolean)  Whether or not two-way binding is enabled. Defaults to  true .  var ractive = Ractive({\n  template: ' input value= {{foo}} ',\n  data: { foo: 'bar' },\n  twoway: false\n})\n\n// user types  fizz  into  input , but data value is not changed:\n\nconsole.log( ractive.get( 'foo' ) ); //logs  bar \n\n// updates from the model are still pushed to the view\n\nractive.set( 'foo', 'fizz' )\n\n// input now displays  fizz", 
            "title": "twoway"
        }, 
        {
            "location": "/api/#use", 
            "text": "([plugin])  An array of plugins to install on the instance or component. This is more or less a shorthand for calling the  use  method on a component or instance.  import neato from 'some/neato/plugin';\nimport thingy from 'thingy/plugin';\n\n// install a plugin in a component\nconst Component = Ractive.extend({\n  use: [neato]\n});\n\n// install a plugin in an instance\nconst app = window.app = new Component({\n  use: [thingy]\n});", 
            "title": "use"
        }, 
        {
            "location": "/api/#warnaboutambiguity", 
            "text": "(boolean)  Whether or not to warn about references that don't resolve to their immediate context. Defaults to  false .  Ambiguous references can be the cause of some strange behavior when your data changes structure slightly. With  warnAboutAmbiguity  enabled, Ractive will warn you any time a reference isn't scoped and resolves in a context above the immediate context of the reference.", 
            "title": "warnAboutAmbiguity"
        }, 
        {
            "location": "/api/#static-properties", 
            "text": "", 
            "title": "Static Properties"
        }, 
        {
            "location": "/api/#ractiveadaptors", 
            "text": "(Object string, Object )  The registry of globally available adaptors.", 
            "title": "Ractive.adaptors"
        }, 
        {
            "location": "/api/#ractivecomponents", 
            "text": "(Object string, Function )  The registry of globally available component definitions.", 
            "title": "Ractive.components"
        }, 
        {
            "location": "/api/#ractivecontext", 
            "text": "From 0.9.4  (Object)  The prototype for  Context  objects. This is provided so that you can extend context objects provided by Ractive with your own methods and properties.", 
            "title": "Ractive.Context"
        }, 
        {
            "location": "/api/#componentcss", 
            "text": "From 0.10.0  (string|(CSSData) =  string)  The CSS string or function that is set on the constructor. Setting this will cause the CSS for the component in the Rative-managed  style  element to be updated.", 
            "title": "[Component].css"
        }, 
        {
            "location": "/api/#ractivedebug", 
            "text": "(boolean)  Tells Ractive if it's in debug mode or not. When set to  true , non-fatal errors are logged. When set to  false , non-fatal errors are suppressed. By default, this is set to  true .", 
            "title": "Ractive.DEBUG"
        }, 
        {
            "location": "/api/#ractivedebug_promises", 
            "text": "(boolean)  Tells Ractive to log errors thrown inside promises. When set to  true , errors thrown in promises are logged. When set to  false , errors inside promises are suppressed. By default, this is set to  true .", 
            "title": "Ractive.DEBUG_PROMISES"
        }, 
        {
            "location": "/api/#ractivedecorators", 
            "text": "(Object string, Function )  The registry of globally available decorators.", 
            "title": "Ractive.decorators"
        }, 
        {
            "location": "/api/#ractivedefaults", 
            "text": "(Object string, any )  Global defaults for initialisation options with the exception of plugin registries.  // Change the default mustache delimiters to [[ ]] globally\nRactive.defaults.delimiters = [ '[[', ']]' ]\n\n// Future instances now use [[ ]]\nractive1 = Ractive({\n    template: 'hello [[world]]'\n})  Defaults can be specified for a subclass of Ractive, overriding global defaults.  var MyRactive = Ractive.extend()\n\nMyRactive.defaults.el = document.body  Configuration on the instance overrides subclass and global defaults.  Ractive.defaults.delimiters = [ '[[', ']]' ]\n\n// Uses the delimiters specified above\nRactive({\n  template: 'hello [[world]]'\n})\n\n// Uses the delimiters specified in the init options\nRactive({\n  template: 'hello //world\\\\',\n  delimiters: [ '//', '\\\\' ]\n})  Global data attributes may be specified:  Ractive.defaults.data.people = [{id:4, name:'Fred'},{id:5, name:'Wilma'},...]\n\n//or alternatively:\nObject.assign(Ractive.defaults.data,{people : [{id:4, name:'Fred'},{id:5, name:'Wilma'},...],\n                                     title : 'Flintstones',\n                                     producer : 'Hanna-Barbera'})\n\n// (Object.assign is provided as a polyfill by Ractive if it's not supported by the browser)  The data attributes and values are then accessible in all components. Data attributes specified in this way, however, do  not  trigger an automatic component update if the attribute value is changed after the component is instantiated.", 
            "title": "Ractive.defaults"
        }, 
        {
            "location": "/api/#ractiveeasing", 
            "text": "(Object string, Function )  The global registry of easing functions.  The easing functions are used by the  ractive.animate  method and by transitions. Four are included by default:  linear ,  easeIn ,  easeOut  and  easeInOut .", 
            "title": "Ractive.easing"
        }, 
        {
            "location": "/api/#ractiveevents", 
            "text": "(Object string, Function )  The global registry of custom event plugins.", 
            "title": "Ractive.events"
        }, 
        {
            "location": "/api/#ractiveinterpolators", 
            "text": "(Object string, Function )  A key-value hash of interpolators use by  ractive.animate()  or non-CSS transitions.", 
            "title": "Ractive.interpolators"
        }, 
        {
            "location": "/api/#componentparent", 
            "text": "From 0.9.1  (Ractive|Component constructor)  The parent constructor of a component.  const MyComponent = Ractive.extend()\nconst MySpecialComponent = MyComponent.extend()\n\nMyComponent.Parent === Ractive; // true\nMySpecialCompoennt.Parent === MyComponent; // true", 
            "title": "[Component].Parent"
        }, 
        {
            "location": "/api/#ractivepartials", 
            "text": "(Object string, string|Object|Function )  The global registry of partial templates.  Like templates, partials are parsed at the point of use. The parsed output is cached and utilized for future use.", 
            "title": "Ractive.partials"
        }, 
        {
            "location": "/api/#componentractive", 
            "text": "From 0.9.1  (Ractive)  The root Ractive constructor that is the first ancestor of this component.  const MyComponent = Ractive.extend()\nconst MySpecialComponent = MyComponent.extend()\n\nMyComponent.Ractive === Ractive; // true\nMySpecialCompoennt.Ractive === Ractive; // true", 
            "title": "[Component].Ractive"
        }, 
        {
            "location": "/api/#ractivesvg", 
            "text": "(boolean)  Indicates whether or not the browser supports SVG.", 
            "title": "Ractive.svg"
        }, 
        {
            "location": "/api/#ractivetransitions", 
            "text": "(Object string, Function )  The global registry of transition functions.", 
            "title": "Ractive.transitions"
        }, 
        {
            "location": "/api/#ractiveversion", 
            "text": "(string)  The version of the currently loaded Ractive.", 
            "title": "Ractive.VERSION"
        }, 
        {
            "location": "/api/#static-methods", 
            "text": "", 
            "title": "Static Methods"
        }, 
        {
            "location": "/api/#ractiveaddcss", 
            "text": "From 0.10.0  Add CSS to the Ractive-managed  style  tag. This is particularly useful for plugins that aren't based on a component or macro. If you try to add the same  id  more than once, an error will be thrown.  Syntax   Ractive.addCSS(id, css)   Arguments   id (string) : An identifier for the styles.  css (string|(CSSData) =  string) : A string of CSS or a function that receives CSS data (see  Ractive.styleSet ) and returns a string of CSS.   Example  Ractive.addCSS(\n  'fancy-buttons',\n  `button {\n    border-radius: 0.2em;\n    outline: 3px red;\n    color: blue;\n    background-color: yellow;\n    animation: buttonblink 1s linear infinite;\n    box-shadow: 2px 2px 5px rgba(0, 255, 255, 0.5);\n  }\n  @keyframes buttonblink {\n    50% {\n      color: transparent;\n    }\n  }`\n);", 
            "title": "Ractive.addCSS()"
        }, 
        {
            "location": "/api/#ractiveescapekey", 
            "text": "Escapes the given key so that it can be concatenated with a keypath string.  Syntax   Ractive.escapeKey(key)   Arguments   key (string) : The key to escape.   Returns   (string) : The escaped key.   Examples  Example 1  Ractive.escapeKey('foo.bar'); // 'foo\\\\.bar'  Example 2   Ractive({\n    ...\n  on:{\n    changeUrl () {\n      this.set('img.a\\\\.jpg.url',  /my/new/path.jpg )\n    },\n    changeUrl2 () {\n      mykey = 'a.jpg'\n      this.set('img.' + Ractive.escapeKey(mykey) + '.url',  /the/other/path.jpg )\n    }\n  },\n  data: {\n    img: {\n      'a.jpg': {\n        url:  /path/to/a.jpg \n      }\n    }\n  }\n})", 
            "title": "Ractive.escapeKey()"
        }, 
        {
            "location": "/api/#ractiveextend", 
            "text": "Creates a \"subclass\" of the Ractive constructor or a subclass constructor. See  Components  for an in-depth discussion on the use of  Ractive.extend .  Syntax   Ractive.extend([options[, ...optionsN]])   Arguments   options] (Object) : One or more objects that represent the defaults for instances of the subclass, with the latter objects' properties taking precedence over the former. See [Initialization Options for a list of possible options.   Returns   (Function) : The subclass constructor function.   Examples  const SubClass = Ractive.extend({\n    template: ' div {{message}} /div ',\n    data: {\n        message: 'Hello World!'\n    }\n})\n\n//  div Hello World! /div \nconst instance1 = SubClass({\n    el: '.div1'\n})\n\n//  div Lorem Ipsum /div \nconst instance2 = SubClass({\n    el: '.div2',\n    data: {\n        message: 'Lorem Ipsum'\n    }\n})", 
            "title": "Ractive.extend()"
        }, 
        {
            "location": "/api/#ractiveextendwith", 
            "text": "Creates a \"subclass\" of the Ractive constructor or a subclass constructor using an existing constructor. The constructor will be augmented with static methods like  extend , and it will also process the given initialization options.  Syntax   Ractive.extendWith(constructor[, options])   Arguments   constructor (Function) : A class constructor - like an ES6  class , a plain JavaScript function with a prototpye, or another similarly constructed function (TypeScript, CoffeeScript, etc).  options (Object) : An object with initialization options as properties. See initialization options for a list of possible options.   Returns   (Function) : The augmented constructor function.   Examples  class Widget extends Ractive {\n  notify ( message ) {\n    this.push( 'messages', message )\n  }\n\n  show () {\n    this.set( 'visible', true )\n  }\n\n  hide () {\n    this.set( 'visible', false )\n  }\n}\n\nRactive.extendWith( Widget, {\n  template: '{{#if visible}} ul {{#each messages}} li {{.}} /li {{/each}} /ul {{/if}}'\n})", 
            "title": "Ractive.extendWith()"
        }, 
        {
            "location": "/api/#ractivegetcss", 
            "text": "Returns the scoped CSS from Ractive subclasses defined at the time of the call.  If used without arguments, it will return the scoped CSS of all subclasses. If provided an array of scoping IDs, it will return the scoped CSS of all subclasses whose scoping ID is included in the array.  Syntax   Ractive.getCSS([key])   Arguments   [key] (Array string ) : Subclass CSS scoping ID.   Returns   (string) : The scoped CSS.   Examples  // Assuming the generated ID for this subclass is 'xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx'.\nconst Subclass1 = Ractive.extend({\n    ...\n    css: 'div{ color: red }'\n    ...\n})\n\n// Assuming the generated ID for this subclass is 'yyyyyyyy-yyyy-yyyy-yyyy-yyyyyyyyyyyy'.\nconst Subclass2 = Ractive.extend({\n    ...\n    css: 'div{ color: green }'\n    ...\n})\n\n// CSS contains the scoped versions of div{ color: red } and div{ color: green }.\nconst css = Ractive.getCSS()\n\n// css contains the scoped version of div{ color: red } only.\nconst css = Ractive.getCSS([ 'xxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx' ])", 
            "title": "Ractive.getCSS()"
        }, 
        {
            "location": "/api/#ractivegetcontext", 
            "text": "Accepts a node and returns a Context object containing details of the Ractive instance the node is associated to.  Syntax   Ractive.getContext(node)   Arguments   node (string|Node) : The DOM node or a CSS selector of the DOM node for which you wish to retrieve the Ractive instance or view details.   Returns   (Context) : A context object.   Examples  const info = Ractive.getContext(document.getElementById('some-node'))\n\nconst info = Ractive.getContext('#some-node')", 
            "title": "Ractive.getContext()"
        }, 
        {
            "location": "/api/#ractivehascss", 
            "text": "From 0.10.0  Determines whether or not CSS has been added with the given  id .  Syntax   Ractive.hasCSS(id)   Arguments   id (string) : The id to check.   Returns   (boolean) :  true  if there is already CSS installed with the given  id .", 
            "title": "Ractive.hasCSS()"
        }, 
        {
            "location": "/api/#ractiveisinstance", 
            "text": "From 0.9.1  Determines whether or not the given object is an instance of the Ractive constructor. This is also extended to component constructors, where it will make sure that the given object is an instance of the particular constructor on which it is called.  Syntax   Ractive.isInstance(obj)   Arguments   obj (any) : The thing to check.   Returns   boolean   Examples  const MyComponent = Ractive.extend()\nconst MySpecialComponent = MyComponent.extend()\nconst OtherComponent = Ractive.extend()\n\nconst r = new MySpecialCompoennt()\n\nMySpecialComponent.isInstance(r); // true\nMyComponent.isInstance(r); // true\nOtherComponent.isIstance(r); // false\n\nRactive.isInstance(r); //true", 
            "title": "Ractive.isInstance()"
        }, 
        {
            "location": "/api/#ractivejoinkeys", 
            "text": "Joins the given keys into a properly escaped keypath.  Syntax   Ractive.joinKeys(key1 [, ...keyN])   Arguments   key (string) : One or more strings to join.   Returns   (string) : A properly joined and escaped keypath.   Examples  Ractive.joinKeys( 'foo', 'bar.baz' ); // foo.bar\\.baz", 
            "title": "Ractive.joinKeys()"
        }, 
        {
            "location": "/api/#ractivemacro", 
            "text": "Creates a macro partial with the given handler and options. Macro partials sit somewhere between regular partials and components in power and heft. Many things that can't be achieved with regular parials, like adding styles to the managed CSS, easily managing template-local data, and mangling templates before render, can be with macros. Some of the things that can be achieved with components, like having namespaced events and a fully isolated data context, can't be with macros.  Macros also have the ability to swap templates at any point in time, like a dynamic partial. Instead of responding to a change in a model though, there is a helper function,  setTemplate , on the context handle passed to the macro init function.  Syntax   Ractive.macro(handler [, options])   Arguments    handler ((context, ...attributes) =  handle) : The defining function for the macro.  The context that is passed into the handler is augmented with a few extra properties and methods.  Properties   attributes (Object string, any ) : The map of current attribute values, if any.  name : The name with which this macro was created in the template.  partials : A shallow copy of any partials associated with the macro, including  content .  proxy : The VDOM node that is managing the macro.  template : A shallow copy of the template used to create the macro.   Methods   aliasLocal(name [, keypath]) : Creates an alias to the  @local  data associated with the proxy.  name (string) : The name to use when creating the alias.  keypath (string) : If supplied the child keypath of the  @local  data to use when creating the alias.    setTemplate(template) : Sets the template to be rendered in the DOM. This can be called at any time to cause the template to be re-rendered.  template : This can be any of the values that can be used with a partial. If the template is not parsed and the parser is not available, an error will be thrown.     Return  The handler function can optionally return an object with local lifecycle hooks, much like a decorator:   render : A function to be called when the macro is rendered.  update : A function to be called when the attributes of the macro are updated.  invalidate : A function to be called when an part of the template that is controlled by the macro will be updated.  teardown : A function to be called when the macro is unrendered.     options : An optional map of options to use when creating the macro.   attributes (string[]) : A list of reserved attributes that will be passed to the handler function and optional  update  hook.  css (string|(data) =  string) : A CSS string or CSS function to set the managed CSS for the macro.  cssData (object) : Initial CSS data to be passed to a CSS function.  cssId (string) : An optional id to use when scoping CSS for the macro.  noCssTransform (boolean) : If  true , macro CSS will not be scoped.     Returns   (macro) : A macro that can be installed in a  partials  registry.", 
            "title": "Ractive.macro()"
        }, 
        {
            "location": "/api/#ractiveparse", 
            "text": "Parses the template into an abstract syntax tree that Ractive can work on.  Syntax   Ractive.parse(template[, options])   Arguments   template (string) : A Ractive-compliant HTML template.  [options] (Object) : Parser options.  [delimiters] ([string]) : Start and end delimiters for normal mustaches. Defaults to  ['{{', '}}'] .  [tripleDelimiters] ([string]) : Start and end delimiters for triple mustaches. Defaults to  ['{{{', '}}}'] .  [staticDelimiters] ([string]) : Start and end delimiters for static mustaches. Defaults to  ['[[', ']]'] .  [staticTripleDelimiters] ([string]) : Start and end delimiters for static triple mustaches. Defaults to  ['[[[', ']]]'] .  [contextLines] (integer) : Additional lines above and below a line with a parse error to include in the error output. Defaults to  0 .  [interpolate] (Object string, boolean ) : Map of elements that indicates whether or not to read mustaches within the element. Defaults to  { script: false, textarea: true, template: false, style: false } . Elements present within the map treat nested tags as text rather than elements.  [csp] (boolean) : When  true  includes pre-compiled expression functions in the template output so that  eval  is not needed at runtime. Defaults to  true .  [preserveWhitespace] (boolean|Object string, boolean ) : When  true , preserves whitespace in templates. Whitespace inside the  pre  element is preserved regardless of the value of this option. Defaults to  false . If the value is a map, whitespace is not preserved by default, and the elements named in the map will have whitespace preserved based on the value of the boolean associated with their name.  [stripComments] (boolean) : When  false  will leave comments in the parsed template. Defaults to  true .  [sanitize] (boolean|Object) : When  true , strips inline event attributes and certain elements from the markup. Defaults to  false .  [elements] (Array string ) : An array of element names to blacklist.  [eventAttributes] (boolean) : When  true , strips off inline event attributes.    [includeLinePositions] (boolean) : When  true  will include line positions on each node of the parser output. Defaults to  false .  [textOnlyMode] (boolean) : When  true  parses elements as text rather than elements. This is useful for generating raw HTML from a template, more like a plain text templating processor. Defaults to  false .  [transforms|parserTransforms] ([Function])`: An array of post-parsing transforms to apply to the output parser AST.     When  sanitize  is  true , the following elements are stripped:   applet  base  basefont  body  frame  frameset  head  html  isindex  link  meta  noframes  noscript  object  param  script  style  title   Returns   (Object)  - The object representation of the provided markup.   Examples  Assume the following markup.  div class='gallery' \n  {{#each items}}\n     !-- comments get stripped out of the template -- \n     figure on-tap='select' staggered-in \n       img class='thumbnail' src='assets/images/{{id}}.jpg' \n       figcaption {{( @index+1 )}}: {{description}} /figcaption \n     /figure \n  {{/each}} /div   Ractive.parse( template );  will yield the following output:  { v :4, t :[{ t :7, e : div , m :[{ n : class , f : gallery , t :13}], f :[{ t :4, f :[   ,{ t :7, e : figure , m :[{ n :[ tap ], t :70, f : select },{ n : staggered , t :72, v : t1 }], f :[{ t :7, e : img , m :[{ n : class , f : thumbnail , t :13},{ n : src , f :[ assets/images/ ,{ t :2, r : id }, .jpg ], t :13}]},   ,{ t :7, e : figcaption , f :[{ t :2, x :{ r :[ @index ], s : _0+1 }}, :  ,{ t :2, r : description }]}]}], n :52, r : items }]}], e :{'_0+1': function(_0) { return _0+1; }}}", 
            "title": "Ractive.parse()"
        }, 
        {
            "location": "/api/#ractivesplitkeypath", 
            "text": "Splits the given keypath into an array of unescaped keys.  Syntax   Ractive.splitKeypath(keypath)   Arguments   keypath (string) : The keypath to split into keys.   Returns   (Array) : Returns an array of unescaped keys.   Examples  Ractive.splitKeypath( 'foo.bar\\\\.baz' ); // [ 'foo', 'bar.baz' ]", 
            "title": "Ractive.splitKeypath()"
        }, 
        {
            "location": "/api/#ractivesharedset", 
            "text": "From 0.9.4  Sets data in the  @shared  object without requiring access to a Ractive instance.  Syntax   Ractive.sharedSet(keypath, value, options)  Ractive.sharedSet(hash, options)   Arguments  Arguments are the same as would be supplied to  ractive.set .  Returns   (Promise) : Returns a promise that resolves when any transitions associated with the change have completed.   Examples  Ractive.sharedSet( '_', lodash )", 
            "title": "Ractive.sharedSet()"
        }, 
        {
            "location": "/api/#ractivestyleset", 
            "text": "From 0.9.4  Sets data in the  @style  object of Ractive or the component constructor on which it is called. When an applied style that is affected by a change from  styleSet  updates, Ractive will update its manaaged style tag so that the changes show up in the browser immediately.  This function is also available to components created with  Ractive.extend . When called on a component constructor,  styleSet  will set the value in the component's  cssData , and any extensions of the component will also be notified that the parent data changed.  Syntax   Ractive.styleSet(keypath, value, options)  Ractive.styleSet(hash, options)   Arguments  Arguments are the same as would be supplied to  ractive.set  with an addition to the  options  hash:   apply (boolean) : Whether or not to apply any affected styles now. Defaults to  true .   Returns   (Promise) : Returns a promise that resolves when any transitions associated with the change have completed.   Examples  Ractive.styleSet( 'colors.fg', '#000' )", 
            "title": "Ractive.styleSet()"
        }, 
        {
            "location": "/api/#ractiveunescapekey", 
            "text": "Unescapes the given key e.g.  foo\\\\.bar  =   foo.bar .  Syntax   Ractive.unescapeKey(key)   Arguments   key (string) : The key to unescape.   Returns   (string) : The unescaped key.   Examples  Ractive.unescapeKey('foo\\\\.bar'); // foo.bar", 
            "title": "Ractive.unescapeKey()"
        }, 
        {
            "location": "/api/#ractiveuse", 
            "text": "From 0.10.0  Install one or more plugins globally or in a component constructor. If called on a component constructor (the result of  extend ), the plugin will be called with the construtor as the  instance  argument and the constructor prototype as the  proto  argument, so anything added to the  instance  or  proto  will be available to all instances and sub-components of the component.  Syntax   Ractive.use(plugin[, ...plugin])   Arguments   plugin (plugin) : A plugin function that receives  { Ractive, instance: Ractive, proto: Ractive.defaults }  as an argument.   Returns   (this) : The component on which the method was called.", 
            "title": "Ractive.use()"
        }, 
        {
            "location": "/api/#instance-properties", 
            "text": "", 
            "title": "Instance Properties"
        }, 
        {
            "location": "/api/#ractiveadaptors_1", 
            "text": "(Object string, Object )  The instance-only registry of adaptors.", 
            "title": "ractive.adaptors"
        }, 
        {
            "location": "/api/#ractivecomponents_1", 
            "text": "(Object string, Function )  The instance-only registry of components.", 
            "title": "ractive.components"
        }, 
        {
            "location": "/api/#ractivecontainer", 
            "text": "(Ractive)  Each component instance that is in a yielded fragment has a container instance that is accessible using  this.container .  foo \n   bar \n     baz / \n   /bar  /foo   If  bar   {{yield}} s, then  baz 's container will be the  foo  instance.", 
            "title": "ractive.container"
        }, 
        {
            "location": "/api/#ractivedecorators_1", 
            "text": "(Object string, Function )  The instance-only registry of decorators.", 
            "title": "ractive.decorators"
        }, 
        {
            "location": "/api/#ractiveeasing_1", 
            "text": "(Object string, Function )  The instance-only registry of easing functions.", 
            "title": "ractive.easing"
        }, 
        {
            "location": "/api/#ractiveevents_1", 
            "text": "(Object string, Function )  The instance-only registry of custom event plugins.", 
            "title": "ractive.events"
        }, 
        {
            "location": "/api/#ractiveinterpolators_1", 
            "text": "(Object string, Function )  A key-value hash of interpolators use by  ractive.animate()  or non-CSS transitions.", 
            "title": "ractive.interpolators"
        }, 
        {
            "location": "/api/#ractiveparent", 
            "text": "(Ractive)  Each component instance can access its parent using  this.parent .  foo \n   bar \n     baz / \n   /bar  /foo   baz 's parent is the  bar  instance, and  bar 's parent is the  foo  instance.", 
            "title": "ractive.parent"
        }, 
        {
            "location": "/api/#ractivepartials_1", 
            "text": "(Object string, string|Object|Function )  The instance-only registry of partials.", 
            "title": "ractive.partials"
        }, 
        {
            "location": "/api/#ractiveroot", 
            "text": "(Ractive)  Each component instance can access its root Ractive instance using  this.root .  foo \n   bar \n     baz / \n   /bar  /foo   foo ,  bar , and  baz  will all have the Ractive instance with this template as their  root .", 
            "title": "ractive.root"
        }, 
        {
            "location": "/api/#ractivetransitions_1", 
            "text": "(Object string, Function )  The instance-only registry of transitions.", 
            "title": "ractive.transitions"
        }, 
        {
            "location": "/api/#instance-methods", 
            "text": "", 
            "title": "Instance Methods"
        }, 
        {
            "location": "/api/#ractive95super", 
            "text": "Calls the parent method from a child method of the same name.  ractive._super()  is not always available. Only when Ractive detects its use does it make this reference to the parent method.  Syntax   ractive._super([arg[, ...argN]])   Arguments   [arg] (any) : One or more arguments to pass to the function.   Returns   (any) : Depends on the method called.   Examples   var Component = Ractive.extend({\n  oninit () {\n    console.log('super init')\n  }\n})\n\nvar SubComponent = Component.extend({\n  oninit () {\n    this._super()\n    console.log('sub init')\n  }\n})\n\nnew SubComponent()", 
            "title": "ractive._super()"
        }, 
        {
            "location": "/api/#ractiveadd", 
            "text": "Increments the selected keypath.  Syntax   ractive.add(keypath[, number])   Arguments   keypath (string) : The keypath of the number we're incrementing.  [number] (number) : The number to increment by. Defaults to  1 .   Returns   (Promise) : A promise that resolves when any transitions associated with the operation complete.   Examples   var r = Ractive({\n  el: '#main',\n  template: '#tpl',\n  data: {\n    counter: 0\n  }\n})\n\nsetTimeout(() =  {\n  r.add('counter')\n  console.log(r.get('counter'))\n}, 1000)\n\nsetTimeout(() =  {\n  r.add('counter', 10)\n  console.log(r.get('counter'))\n}, 2000)", 
            "title": "ractive.add()"
        }, 
        {
            "location": "/api/#ractiveanimate", 
            "text": "Similar to  ractive.set() , this will update the data and re-render any affected mustaches and notify observers.  All animations are handled by a global timer that is shared between Ractive instances (and which only runs if there are one or more animations still in progress), so you can trigger as many separate animations as you like without worrying about timer congestion. Where possible,  requestAnimationFrame  is used rather than  setTimeout .  Numeric values and strings that can be parsed as numeric values can be interpolated. Objects and arrays containing numeric values (or other objects and arrays which themselves contain numeric values, and so on recursively) are also interpolated.  Note that there is currently no mechanism for detecting cyclical structures! Animating to a value that indirectly references itself will cause an infinite loop.  Future versions of Ractive may include string interpolators - e.g. for SVG paths, colours, transformations and so on, a la D3 - and the ability to pass in your own interpolator.  If an animation is started on a keypath which is  already  being animated, the first animation is cancelled. (Currently, there is no mechanism in place to prevent collisions between e.g.  ractive.animate('foo', { bar: 1 })  and  ractive.animate('foo.bar', 0) .)  Syntax   ractive.animate(keypath, value[, options])   Arguments   keypath (string) : The keypath to animate.  value (number|string|Object|Array) : The value to animate to.  [options] (Object) :  [duration] (number) : How many milliseconds the animation should run for. Defaults to  400 .  [easing] (string|Function) : The name of an easing function or the easing function itself. Defaults to  linear .  [interpolator] (string) : The name of an interpolator function. Defaults to the built-in number interpolator if the value is numeric, or  null  if none is applicable.  [step] (Function) : A function called on each step of the animation.  t (number) : The animation progress between  0  and  1  with easing function already applied.  value (number) : The value at  t  with interpolator function already applied.    [complete] (Function) : A function to be called when the animation completes, with the  value  passed to  animate .     Returns   (Promise) : Returns a Promise which resolves with the target  value  and has an additional  stop  method, which cancels the animation.   Examples   var r = Ractive({\n  el: '#main',\n  template: '#tpl',\n  data: {\n    counter: 0\n  }\n})\n\nsetTimeout(() =  {\n  r.animate('counter', 20, { duration: 2000 })\n}, 1000)", 
            "title": "ractive.animate()"
        }, 
        {
            "location": "/api/#ractiveattachchild", 
            "text": "Creates a parent-child relationship between two Ractive instances. The child may be an instance of a component defined by  Ractive.extend() , but that is not a requirement, as children may be a plain Ractive instance created with  Ractive() .  Syntax  ractive.attachChild( child )\nractive.attachChild( child, options )  Arguments   child (Ractive instance) : The child instance to attach.  [options] (Object) :  target] (string) : An anchor name at which to render the instance. See [ Components . If the instance is already rendered, it will be unrendered and re-rendered at an appropriate anchor.  [append] (boolean) : Default  true  - add the instance to the end of the list for the targeted anchor.  [prepend] (boolean) : Add the instance to the beginning of the list for the targeted anchor.  [insertAt] (number) : Index at which to add the instance in the list for the targeted anchor.     When a child is attached to a parent, the child's  parent  property is updated in an observable way, so any references to  @this.parent  in the child will be notified of the change.  A child may be targeted to a  Components  when it is attached. If a child has no specified target, then it is responsible for managing its own render cycle. If a child does have a specified target, then the parent will manage rendering and unrendering the child as appropriate in the same way that a regular component has a managed render cycle.  When a child is attached targeting an anchor, only anchors that belong directly to the parent are considered as hosts. However, any element or component queries on the parent instance, including live queries, will consider the child when trying to match both elements and components. There is also an option on the query methods that allows querying remote, unmanaged instances, so that non-anchored children can also be queried for elements and components.  Returns   (Promise) : A  Promise  that resolves with the child instance when any transitions are complete.   Children can be detached using  ractive.detachChild() .  Examples  Example 1 : See the example for  Anchors", 
            "title": "ractive.attachChild()"
        }, 
        {
            "location": "/api/#ractivecompute", 
            "text": "Creates a new computation. This is the API equivalent of the  computed  init or extend option.  Syntax   ractive.compute( keypath, computation )   Arguments   keypath ( string ) : The keypath at which the computation should be available. This may be more than one level deep and may include wildcards.  computation ( string | function | object) : The computation to be installed at the given keypath.  string : The string that will be parsed and turned into a getter function.  function : A getter function to be used for the computation.  object : An object with a  get  and optionally a  set  to be used for the computation.     Returns   (Promise) : A  Promise  that resolves with the child instance when any transitions are complete.   If there are already bits of template or observers that depend on the target keypath, they will be transitioned to the new computed model.", 
            "title": "ractive.compute()"
        }, 
        {
            "location": "/api/#ractivedetach", 
            "text": "Detaches the instance from the DOM, returning a document fragment. You can reinsert it, possibly in a different place, with  ractive.insert()  (note that if you are reinserting it immediately you don't need to detach it first - it will happen automatically).  Syntax   ractive.detach()   Arguments   None   Returns   (DocumentFragment) : A document fragment.   Examples   var r = Ractive({\n  el: '#main',\n  template: '#tpl',\n  data: {\n    counter: 0\n  }\n})\n\nsetTimeout(() =  {\n  var div = document.createElement('div')\n  div.appendChild(r.detach())\n  console.log(div.innerHTML)\n}, 1000)", 
            "title": "ractive.detach()"
        }, 
        {
            "location": "/api/#ractivedetachchild", 
            "text": "Detaches a child from an instance when it was previously attached with  ractive.attachChild() .  When a child instance that was attached targeting an anchor is detached, its instance is spliced out of the  @this.children.byName.anchorName  array so that subsequent children move forward to fill the void.  Syntax   ractive.detachChild( child )   Returns   (Promise) : A  Promise  that resolves with the child instance when any transitions are complete.   Examples  Example 1 : See the example for  Anchors", 
            "title": "ractive.detachChild()"
        }, 
        {
            "location": "/api/#ractivefind", 
            "text": "Returns the first element inside a given Ractive instance matching a CSS selector. This is similar to doing  this.el.querySelector(selector)  (though it doesn't actually use  querySelector() ).  Syntax   ractive.find(selector[, options])   Arguments   selector (string) : A CSS selector representing the element to find.  [options] (Object) :  remote (boolean} : Include attached children that are not rendered in anchors when looking for matching elements. Defaults to  false .     Returns   (Node) : A Node.   Examples   var r = Ractive({\n  el: '#main',\n  template: '#tpl'\n})\n\nsetTimeout(() =  {\n  var p = r.find('p.target')\n  console.log(p.outerHTML)\n}, 1000)", 
            "title": "ractive.find()"
        }, 
        {
            "location": "/api/#ractivefindall", 
            "text": "This method is similar to [ ractive.find() ]ractivefind), with an important difference - it returns a list of elements matching the selector, rather than a single node.  Syntax   ractive.findAll(selector[, options])   Arguments   selector (string) : A CSS selector representing the elements to find.  [options] (Object) :  remote (boolean) : Include attached children that are not rendered in anchors when searching for elements. Defaults to  false .     Returns   (Array Node ) : An array of nodes.   Examples   var r = Ractive({\n  el: '#main',\n  template: '#tpl'\n})\n\nsetTimeout(() =  {\n  var ps = r.findAll('p')\n  ps.forEach(function(p) {\n    console.log(p.outerHTML)\n  })\n}, 1000)", 
            "title": "ractive.findAll()"
        }, 
        {
            "location": "/api/#ractivefindallcomponents", 
            "text": "Returns all components inside a given Ractive instance with the given  name  (or all components of any kind if no name is given).  Syntax   ractive.findAllComponents([name[, options]])   Arguments   [name] (string) : The name of the component to find.  [options] (Object) :  remote (boolean) : Include attached children that are not rendered in anchors when searching components. Defaults to  false .     Returns   (Array ractive ) : An array of ractive instances.   Examples   var Component = Ractive.extend({\n  template: 'Component {{number}}'\n})\n\nvar r = Ractive({\n  el: '#main',\n  template: '#tpl',\n  components: {\n    Component: Component\n  }\n})\n\nsetTimeout(() =  {\n  var cs = r.findAllComponents('Component')\n  cs.forEach(function(c) {\n    console.log(c.toHTML())\n  })\n}, 1000)", 
            "title": "ractive.findAllComponents()"
        }, 
        {
            "location": "/api/#ractivefindcomponent", 
            "text": "Returns the first component inside a given Ractive instance with the given  name  (or the first component of any kind if no name is given).  Syntax   ractive.findComponent([name[, options]])   Arguments   [name] (string) : The name of the component to find.  [options] (Object) :  remote (boolean) : Include attached children that are not rendered in anchors when searching components. Defaults to  false .     Returns   (Ractive) : A ractive instance.   Examples   var Component = Ractive.extend({\n  template: 'Component {{number}}'\n})\n\nvar r = Ractive({\n  el: '#main',\n  template: '#tpl',\n  components: {\n    Component: Component\n  }\n})\n\nsetTimeout(() =  {\n  var c = r.findComponent('Component')\n  console.log(c.toHTML())\n}, 1000)", 
            "title": "ractive.findComponent()"
        }, 
        {
            "location": "/api/#ractivefindcontainer", 
            "text": "Returns the first container of this component instance with the given  name .  Syntax   ractive.findContainer(name)   Arguments   name (string) : The name of the container to find.   Returns   (Ractive) : Returns the first container of this component with the given  name .   Examples  // TODO", 
            "title": "ractive.findContainer()"
        }, 
        {
            "location": "/api/#ractivefindparent", 
            "text": "Returns the first parent of this component instance with the given  name .  Syntax   ractive.findParent(name)   Arguments   name (string) : The name of the parent to find.   Returns   (Ractive) : Returns the first parent of this component with the given  name .   Examples  // TODO", 
            "title": "ractive.findParent()"
        }, 
        {
            "location": "/api/#ractivefire", 
            "text": "Fires an event, which will be received by handlers that were bound using  ractive.on . In practical terms, you would mostly likely use this with  Ractive.extend() , to allow applications to hook into your subclass.  Syntax   ractive.fire(eventName[, context [, arg1[, ...argN]]])   Arguments   name (string) : The name of the event.  [context] (context|object) : A context object to use for the event or an object with properties to assign to a new context object. If you need to pass arguments but don't need to provide context, pass an empty object ( {} ) before the additional arguments.  From 0.9.4 , if you want to reuse a context exactly as it exists, it should have a  refire  property that is  === true .  [arg] (any) : The arguments that event handlers will be called with.   Returns   (boolean)   Examples   var r = Ractive()\n\nr.on('foo', () =  {\n  console.log('foo fired')\n})\n\nr.fire('foo')", 
            "title": "ractive.fire()"
        }, 
        {
            "location": "/api/#ractiveget", 
            "text": "Returns the value at  keypath .  Syntax   ractive.get([keypath][, options])   Arguments   [keypath] (string) : The keypath of the data to retrieve. If omitted, returns a shallow copy of the instance's data.  [options] (Object) : An options hash that may contain:  virtual (boolean) : When set to  false , excludes virtual keypaths (computations, links, mappings, etc.). Defaults to  true  for the root keypath and  false  for keypaths other than the root.  unwrap (boolean) : When set to  false , returns the adapted value of the data if an adaptor was applied. Defaults to  true .     Returns   (any) : Returns the data that exists at the given keypath, or the root data if no keypath is given.   Examples   var r = Ractive({\n  data: {\n    foo: {\n      bar: [ 'baz' ]\n    }\n  }\n})\n\nconsole.log(r.get('foo.bar.0'))   var r = new Ractive({\n  data : {\n    name :  Herbert \n  },\n  computed : {\n    foo  () {\n      return 55\n    }\n  }\n})\n\nconsole.log(r.get()) // =  {name :  Herbert , foo : 55}\n\nconsole.log(r.get({virtual : false})) // =  {name :  Herbert }", 
            "title": "ractive.get()"
        }, 
        {
            "location": "/api/#ractivegetcontext_1", 
            "text": "This is an instance specific version of  Ractive.getContext()  that will only search the local instance DOM for a matching node when a selector is given. If the given value is not a string, then it is passed directly through to the static version of this method.  Syntax   ractive.getContext(node)   Arguments   node (string|Node) : The DOM node or a CSS selector of a target node for which you wish to retrieve the Ractive instance or view details.   Returns   (Context) : Returns an Context object with helper methods to interact with the Ractive instance and context associated with the given node.   Examples  // TODO", 
            "title": "ractive.getContext()"
        }, 
        {
            "location": "/api/#ractiveinsert", 
            "text": "Inserts the instance to a different location. If the instance is currently in the DOM, it will be detached first. See also  ractive.detach() .  Syntax   ractive.insert(target[, anchor])   Arguments   target (string|Node|array-like) : The new parent element.  [anchor] (string|Node|array-like) : The sibling element to insert the instance before. If omitted, the instance will be inserted as the last child of the parent.   Returns   (undefined)   Examples   Ractive.components.aaa = Ractive.extend({\n    template:  button {{yield}} /button \n})\n\nRactive({\n    ...\n    template: `\n         button on-click= move teleport /button \n         button on-click= restore restore /button \n\n         div id= container1  style= border: 2px solid yellow; min-height: 50px \n             aaa hello /aaa \n         /div \n\n         div id= container2  style= border: 1px solid red; min-height: 50px \n\n         /div \n    `,\n    on: {\n        move () {\n          const aaa = this.findComponent('aaa')\n          const target = this.find('#container2')\n          aaa.insert(target)\n        },\n        restore () {\n          const aaa = this.findComponent('aaa')\n          const target = this.find('#container1')\n          aaa.insert(target)\n        }\n    }\n})", 
            "title": "ractive.insert()"
        }, 
        {
            "location": "/api/#ractivelink", 
            "text": "Creates a link between two keypaths that keeps them in sync. Since Ractive can't always watch the contents of objects, copying an object to two different keypaths in your data usually leads to one or both of them getting out of sync.  link  creates a sort of symlink between the two paths so that Ractive knows they are actually the same object. This is particularly useful for master/detail scenarios where you have a complex list of data and you want to be able to select an item to edit in a detail form.  Syntax   ractive.link(source, destination, options)   Arguments   source (string) : The keypath of the source item.  destination (string) : The keypath to use as the destination - or where you'd like the data 'copied'.  options (hash) :  instance  or  ractive : The Ractive instance in which to find the source keyapth. This allows cross-instance linking much like mapped paths between components.  keypath :  From 0.9.4  - The keypath to register as the source of the link. This is an advanced option that allows you to specify how the link should shuffle. For instance  items.0.name  will never shuffle, but if the keypath is specified as  .name , then it will shuffle when  items.0  shuffles.   Returns   (Promise) : Returns a promise.   Examples  ractive.link( 'some.nested.0.list.25.item', 'current' )\nractive.set( 'current.name', 'Rich' ); // some.nested.0.list.25.item.name is also updated to be 'Rich'  This can be used to great effect with method events and the  @keypath  special ref:  {{#each some.nested}}\n  {{#each list}}\n    {{#with item}}\n      {{.name}}\n       button on-click= event.link('.', 'current') Select /button \n    {{/with}}\n  {{/each}}\n{{/each}}\n\nName:  input value= {{~/current.name}}  /   Links can be removed using  ractive.unlink() .", 
            "title": "ractive.link()"
        }, 
        {
            "location": "/api/#ractiveobserve", 
            "text": "Observes the data at a particular keypath. Unless specified otherwise, the callback will be fired immediately, with  undefined  as  oldValue . Thereafter it will be called whenever the  observed keypath  changes.  Syntax   ractive.observe(keypath, callback[, options])  ractive.observe(map[, options])   Arguments    keypath (String) : The keypath to observe, or a group of space-separated keypaths. Any of the keys can be a  *  character, which is treated as a wildcard. A  **  means recursive.  The difference between  *  and  **  is that  *  provides your callback function  value  and  keypath  arguments containing the path of the what actually changed, at any level of the keypath. So instead of getting the same parent value on every change, you get the changed value from whatever arbitrarily deep keypath changed.    callback (Function) : The function that will be called, with  newValue ,  oldValue  and  keypath  as arguments (see Observers for more nuance regarding these arguments), whenever the observed keypath changes value. By default the function will be called with  ractive  as  this . Any wildcards in the keypath will have their matches passed to the callback at the end of the arguments list as well.   map (Object) : A map of keypath-observer pairs.  [options] (Object) :  [init] (boolean) : Defaults to  true . Whether or not to initialise the observer, i.e. call the function with the current value of  keypath  as the first argument and  undefined  as the second.  [defer] (boolean) : Defaults to  false , in which case observers will fire before any DOM changes take place. If  true , the observer will fire once the DOM has been updated.  links] (boolean) : Defaults to  false .  Whether or not the observer should \"follow through\" any links created with [ ractive.link() .  [strict] (boolean) : Defaults to  false .  strict  uses object identity to determine if there was a change, meaning that unless the primary object changed, it won't trigger the observer. For example with  { data: { foo: { bar: 'baz' } } } ,  ractive.observe('foo', ..., { strict: true })  will not fire on  ractive.set('foo.bar', 'bat')  but will on  ractive.set('foo', { bar: 'bip' }) .  [context] (any) : Defaults to  ractive . The context the observer is called in (i.e. the value of  this )  [array] (boolean) : Defaults to  false . Whether or not to observe the keypath as an array, meaning that change events will fire with a object containing two lists,  inserted  containing added elements, and  deleted  containing removed elements. There is also a  start  integer property indicating the index at which the replacements begin.  [old] (function) : Defaults to  undefined . A function that can be used to modify the  old  value passed to the observer callback. This can be used to freeze the old value, create a deep clone of it for future firings, etc.     Returns   (Object) : A handle object for controlling any observers created by the call to  observe  cancel : Permanently stops observers controlled by the handle.  isSilenced : Returns  true  if this handle is currently silenced.  silence : Stop calling callbacks associated with this handle. The observers are still processed by Ractive, so the old value will still be updated. This means that setting a new value on an observer while it is silenced, resuming the observer, and then setting the same value again will  not  result in the callback being fired if it would not be fired by the same sequence without silencing.  resume : Resume calling callbacks associated with this handle.     Examples  // TODO  Note that you can observe keypath  patterns ...  ractive.observe( 'items.*.status', function ( newValue, oldValue, keypath) {\n  var index = /items.(\\d+).status/.exec( keypath )[1]\n  alert( 'item ' + index + ' status changed from ' + oldValue + ' to ' + newValue )\n})  ...or multiple space-separated keypaths simultaneously:  ractive.observe( 'foo bar baz', function ( newValue, oldValue, keypath ) {\n  alert( keypath ) + ' changed from ' + oldValue + ' to ' + newValue )\n})  See Observers for more detail.", 
            "title": "ractive.observe()"
        }, 
        {
            "location": "/api/#ractiveobserveonce", 
            "text": "Observes the data at a particular keypath until the first change. After the handler has been called, it will be unsubscribed from any future changes.  Syntax   ractive.observeOnce(keypath, callback[, options])   Arguments   keypath (string) : The keypath to observe, or a group of space-separated keypaths. Any of the keys can be a `` character, which is treated as a wildcard.  callback (Function) : The function that will be called, with  newValue ,  oldValue  and  keypath  as arguments (see Observers for more nuance regarding these arguments), whenever the observed keypath changes value. By default the function will be called with  ractive  as  this . Any wildcards in the keypath will have their matches passed to the callback at the end of the arguments list as well.  [options] (Object) :  [defer] (boolean) : Defaults to  false , in which case observers will fire before any DOM changes take place. If  true , the observer will fire once the DOM has been updated.  [context] (any) : Defaults to  ractive . The context the observer is called in (i.e. the value of  this )     Returns   (Object) : An object with a  cancel  method, for cancelling the observer.   Examples  // TODO  Note that you can observe keypath  patterns ...  ractive.observeOnce( 'items.*.status', function ( newValue, oldValue, keypath ) {\n  var index = /items.(\\d+).status/.exec( keypath )[1]\n  alert( 'item ' + index + ' status changed from ' + oldValue + ' to ' + newValue )\n})  ...or multiple space-separated keypaths simultaneously:  ractive.observeOnce( 'foo bar baz', function ( newValue, oldValue, keypath ) {\n  alert( keypath + ' changed from ' + oldValue + ' to ' + newValue )\n})  See Observers for more detail.", 
            "title": "ractive.observeOnce()"
        }, 
        {
            "location": "/api/#ractiveoff", 
            "text": "Removes an event handler, several event handlers, or all event handlers.  To remove a single handler, you must specify both the event name and the handler. If you only specify the event name, all handlers bound to that event name will be removed. If you specify neither event name nor handler,  all  event handlers will be removed.  An alternative way to remove event handlers is to use the  cancel  method of the return value of a call to  ractive.on() .  Syntax   ractive.off([eventName[, handler]])   Arguments   eventName (string) : The event name to which this handler is currently bound.  handler (Function) : The handler to remove.   Returns   (Ractive) : Returns the  ractive  instance to allow this call to be chainable.   Examples  // TODO", 
            "title": "ractive.off()"
        }, 
        {
            "location": "/api/#ractiveon", 
            "text": "Subscribe to events.  Syntax   ractive.on(eventName, handler)  ractive.on(obj)   Arguments   eventName (String) : The name of the event to subscribe to  handler (Function) : The function that will be called, with  ractive  as  this . The arguments depend on the event, but the first argument is always a context object. Returning  false  from the handler will stop propagation and prevent default of DOM events and cancel event bubbling.  obj (Object) : An object with keys named for each event to subscribe to. The value at each key is the handler function for that event.   Returns   (Object) : A handle object for controlling any listners created by the call to  on  cancel : Permanently stops listeners controlled by the handle.  isSilenced : Returns  true  if this handle is currently silenced.  silence : Stop calling callbacks associated with this handle.  resume : Resume calling callbacks associated with this handle.     Examples  // single handler to function\nractive.on( 'activate', function () {...})\n\n// wildcard pattern matching\nractive.on( 'foo.*', function () {...} )\n\n// multiple handlers to one function\nractive.on( 'activate select', function () {...} )\n\n// map of handler/function pairs\nractive.on({\n  activate () {...},\n  select () {...}\n})\n\n// knock yourself out:\nractive.on({\n  activate () {...},\n  'bip bop boop' () {...},\n  'select foo.* bar' () {...}\n})", 
            "title": "ractive.on()"
        }, 
        {
            "location": "/api/#ractiveonce", 
            "text": "Subscribe to an event for a single firing. This is a convenience function on top of  ractive.on() .  Syntax   ractive.once(eventName, handler)   Arguments   eventName (string) : The name of the event to subscribe to.  handler (Function) : The function that will be called, with  ractive  as  this . The arguments depend on the event, but the first argument is always a context object. Returning  false  from the handler will stop propagation and prevent default of DOM events and cancel event bubbling.   Returns   (Object) : Returns an  Object  with a  cancel  method, which removes the handler.   Examples  // TODO", 
            "title": "ractive.once()"
        }, 
        {
            "location": "/api/#ractivepop", 
            "text": "The Ractive equivalent to  Array.pop  that removes an element from the end of the array at the given keypath and triggers an update event.  If the given keypath does not exist (is  undefined ), an empty array will be supplied instead. Otherwise, if the given keypath does not resolve to an array, an error will be thrown.  Syntax   ractive.pop(keypath)   Arguments   keypath (string) : The keypath of the array to change, e.g.  list  or  order.items .   Returns   (Promise) : Returns a promise that will resolve with the removed element after the update is complete.   Examples  // TODO", 
            "title": "ractive.pop()"
        }, 
        {
            "location": "/api/#ractivepush", 
            "text": "The Ractive equivalent to  Array.push  that appends one or more elements to the array at the given keypath and triggers an update event.  If the given keypath does not exist (is  undefined ), an empty array will be supplied instead. Otherwise, if the given keypath does not resolve to an array, an error will be thrown.  Syntax   ractive.push(keypath, value[, ...valueN])   Arguments   keypath (string) : The keypath of the array to change, e.g.  list  or  order.items .  value (any) : The value to append to the end of the array. One or more values may be supplied.   Returns   (Promise)  - Returns a Promise that will resolve after the update is complete.   Examples  // TODO", 
            "title": "ractive.push()"
        }, 
        {
            "location": "/api/#ractivereadlink", 
            "text": "Gets the source keypath and instance for a link.  Syntax   ractive.readLink(link[, options])   Arguments   link (string) : The keypath for the link that you would like to read.  options (Object) :  [canonical] (boolean) : Whether or not to read through any intermediate links too. Pass  canonical: true  to read through links to links all the way to the canonical data keypath. Defaults to  false .     Returns   (Object) :  keypath (string) : The source keypath to which the link points.  ractive (Ractive) : The source Ractive instance that contains the keypath to which the link points.     Examples  const r = Ractive({\n  data: {\n    items: [\n      { name: 'Apple' },\n      { name: 'Banana' },\n      { name: 'Orange' }\n    ]\n  }\n})\n\nr.link( 'items.0', 'currentItem' )\n\nr.readLink( 'currentItem' )\n// returns { ractive: r, keypath: 'items.0' }", 
            "title": "ractive.readLink()"
        }, 
        {
            "location": "/api/#ractiverender", 
            "text": "Renders the component into a DOM element.  Syntax   ractive.render(target)   Arguments   target (Node|String|array-like) : The DOM element to render to.   Returns   (Promise) : A promise that resolves when rendering completes or when the instance is already rendered.   Examples  // TODO", 
            "title": "ractive.render()"
        }, 
        {
            "location": "/api/#ractivereset", 
            "text": "Resets the entire  ractive.data  object and updates the DOM.  Syntax   ractive.reset(data)   Arguments   data (Object) : The data to reset with. Defaults to  {} .   Returns   (Promise) : A promise.   Examples  This differs from  ractive.set()  in the following way:  ractive = Ractive({\n  // ...,\n  data: { foo: 1 }\n})\n\nractive.set({ bar: 2 })\nconsole.log( ractive.get() ); // { foo: 1, bar: 2 }\n\nractive.reset({ bar: 2 })\nconsole.log( ractive.get() ); // { bar: 2 }", 
            "title": "ractive.reset()"
        }, 
        {
            "location": "/api/#ractiveresetpartial", 
            "text": "Resets a partial and re-renders all of its use-sites, including in any components that have inherited it. If a component has a partial with a same name that is its own, that partial will not be affected.  Inline partials that don't belong directly to a Ractive instance aren't affected by  resetPartial .  Syntax   ractive.resetPartial(name, partial)   Arguments   name (string) : The partial to reset.  partial (string|Object|Function) : A template string, pre-parsed template or a function that returns either.   Returns   (Promise) : A promise.   Examples  ractive = Ractive({\n  // ...,\n  partials: { foo: 'foo' }\n})\n\n// {{ foo}} will be replaced with 'foo'\n\nractive.resetPartial('foo', 'bar')\n\n// {{ foo}} will be replaced with 'bar'", 
            "title": "ractive.resetPartial()"
        }, 
        {
            "location": "/api/#ractiveresettemplate", 
            "text": "Resets the template and re-renders the entire instance using the new template.  Syntax   ractive.resetTemplate(template)   Arguments   template (string|Object) : The new template to use. If an object, the template should be the result of  Ractive.parse  with both version and template array properties.   Returns   (Promise) : A promise that resolves once any transitions that are triggered during the re-render are completed.   Examples  const ractive = new Ractive({\n  // ...,\n  template: 'replace me'\n});\n\nractive.resetTemplate('you have been replaced');\nractive.set('foo', 'world');\nractive.resetTemplate(Ractive.parse('Hello, {{foo}}'));", 
            "title": "ractive.resetTemplate()"
        }, 
        {
            "location": "/api/#ractivereverse", 
            "text": "The Ractive equivalent to  Array.reverse  reverses the array at the given keypath and triggers an update event.  If the given keypath does not resolve to an array, an error will be thrown.  Syntax   ractive.reverse(keypath)   Arguments   keypath (String) : The keypath of the array to reverse, e.g.  list  or  order.items   Returns   (Promise)  - A promise that will resolve after the update is complete.   Examples  // TODO", 
            "title": "ractive.reverse()"
        }, 
        {
            "location": "/api/#ractiveset", 
            "text": "Updates data and triggers a re-render of any mustaches that are affected (directly or indirectly) by the change. Any observers of affected keypaths will be notified.  When setting an array value, ractive will reuse the existing DOM nodes for the new array, adding or removing nodes as necessary. This can impact nodes with transitions. Use the  shuffle  option for setting a new array value while retaining existing nodes corresponding to individual array item values.  Syntax   ractive.set(keypath, value[, options])  ractive.set(map[, options])   Arguments   keypath (string) : The keypath of the data we're changing, e.g.  user  user.name  user.friends[1]  or  user.friends.1  users.*.status  images.aaa\\\\.jpg.url .    value (any) : The value we're changing it to. Can be a primitive or an object (or array), in which case dependants of  downstream keypaths  will also be re-rendered (if they have changed).  map (Object) : A map of  keypath: value  pairs, as above.  [options] Object :  deep (boolean) : Whether or not to perform a deep set on with the data at the given keypath. A deep set recursively merges the given data into the data structure at the given keypath. Defaults to  false .  shuffle (boolean|string|Function) : Whether or not to add/move/remove DOM associated with elements rather than just re-using the existing DOM. Defaults to  false .  true : Add/move/remove existing items to their new index using a strict equality comparison.  string : Add/move/remove existing items to their new index using a property comparison where the property compared is named by the given string.  Function : Add/move/remove existing items to their new index using the value returned by the given function for comparison.    keep (boolean) : Whether or not to keep the virtual DOM that would be disposed by the  set  operation. This is useful for hiding components without completely tearing them down and recreating them. It's also a little bit faster, as the virtual DOM doesn't have to be recreated when it would reappear. When the virtual DOM is re-rendered, it will also us the progressive enhancement process to reuse the existing DOM nodes that were detached originalls. Defaults to  false .     Returns   (Promise) : Returns a promise that will resolved after any transitions associated with the operation are complete.   Examples  // TODO  The  keypath  can also contain wildcards pattern-observers. All matching keypaths will be set with the supplied values:  ractive.on('selectAll', function () {\n  ractive.set('items.*.selected', true)\n})  See Also   Ractive.escapeKey()", 
            "title": "ractive.set()"
        }, 
        {
            "location": "/api/#ractiveshift", 
            "text": "The Ractive equivalent to  Array.shift  that removes an element from the beginning of the array at the given keypath and triggers an update event.  If the given keypath does not exist (is  undefined ), an empty array will be supplied instead. Otherwise, if the given keypath does not resolve to an array, an error will be thrown.  Syntax   ractive.shift(keypath)   Arguments   keypath (string) : The keypath of the array to change, e.g.  list  or  order.items .   Returns   (Promise) : A promise that will resolve with the removed element after the update is complete.   Examples  // TODO", 
            "title": "ractive.shift()"
        }, 
        {
            "location": "/api/#ractivesort", 
            "text": "The Ractive equivalent to  Array.sort  sorts the array at the given keypath and triggers an update event.  If the given keypath does not resolve to an array, an error will be thrown.  Syntax   ractive.sort(keypath[, compareFunction])   Arguments   keypath (string) : The keypath of the array to sort, e.g.  list  or  order.items .  compareFunction (Function) : A function that defines the sort order.   Returns   (Promise) : Returns a promise that will resolve after the update is complete.   Examples  // TODO", 
            "title": "ractive.sort()"
        }, 
        {
            "location": "/api/#ractivesplice", 
            "text": "The Ractive equivalent to  Array.splice  that can add new elements to the array while removing existing elements.  If the given keypath does not exist (is  undefined ), an empty array will be supplied instead. Otherwise, if the given keypath does not resolve to an array, an error will be thrown.  Syntax   ractive.splice(keypath, index, [removeCount[, add]])   Arguments   keypath (string) : The keypath of the array to change, e.g.  list  or  order.items .  index (number) : The index at which to start the operation.  [removeCount] (number) : The number of elements to remove starting with the element at * index . This may be 0 if you don't want to remove any elements.  [add] (any) : Any elements to insert into the array starting at * index . There can be 0 or more elements passed to add to the array.   Returns   (Promise) : Returns a promise that will resolve with the removed elements after the update is complete.   Examples  // TODO", 
            "title": "ractive.splice()"
        }, 
        {
            "location": "/api/#ractivesubtract", 
            "text": "Decrements the selected keypath.  Syntax   ractive.subtract(keypath[, number])   Arguments   keypath (string) : The keypath of the number we're decrementing.  [number] (number) : Defaults to  1 . The number to decrement by.   Returns   (Promise) : Returns a promise.   Examples  // TODO", 
            "title": "ractive.subtract()"
        }, 
        {
            "location": "/api/#ractiveteardown", 
            "text": "Unrenders this Ractive instance, removing any event handlers that were bound automatically by Ractive.  Calling  ractive.teardown()  causes a  teardown  event to be fired - this is most useful with  Ractive.extend()  as it allows you to clean up anything else (event listeners and other bindings) that are part of the subclass.  Syntax   ractive.teardown()   Arguments   None   Returns   (Promise) : A promise.   Examples  // TODO", 
            "title": "ractive.teardown()"
        }, 
        {
            "location": "/api/#ractivetocss", 
            "text": "Returns the scoped CSS of the current instance and its descendants.  At the moment, this will not work on a direct instance of Ractive and will log a warning. You can only use this method on an instance of a subclass.  Syntax   ractive.toCSS()   Arguments   None   Returns   (string) : The scoped CSS of the instance.   Examples  const Subclass = Ractive.extend({\n    ...\n    css: 'div{ color: red }'\n    ...\n})\n\nconst subclassInstance = Subclass({...})\n\n// Contains the scoped version of div{ color: red }\nsubclassInstance.toCSS()", 
            "title": "ractive.toCSS()"
        }, 
        {
            "location": "/api/#ractivetohtml", 
            "text": "Returns a chunk of HTML representing the current state of the instance. This is most useful when you're using Ractive in node.js, as it allows you to serve fully-rendered pages (good for SEO and initial pageload performance) to the client.  Syntax   ractive.toHTML()   Arguments   None   Returns   (string) : The instance HTML.   Examples  // TODO", 
            "title": "ractive.toHTML()"
        }, 
        {
            "location": "/api/#ractivetoggle", 
            "text": "Toggles the selected keypath. In other words, if  foo  is truthy, then  ractive.toggle('foo')  will make it  false , and vice-versa.  Syntax   ractive.toggle(keypath)   Arguments   keypath (string) : The keypath to toggle the value of. If  keypath  is a pattern, then all matching keypaths will be toggled.   Returns   (Promise) : A promise.   Examples  // TODO", 
            "title": "ractive.toggle()"
        }, 
        {
            "location": "/api/#ractivetransition", 
            "text": "Triggers a transition on a node managed by this Ractive instance.  Syntax   ractive.transition(transition, node, options)   Arguments   transition (string|Function) : A transition function or a name of a transition function.  node (HTMLElement) : The node on which to start the transition - optional if called from within a Ractive event handler, as it will be retrieved from the event if not supplied.  options (Object) : Options supplied to the transition.   Returns   (Promise) : A promise that resolves when the transition completes.   Examples  // TODO", 
            "title": "ractive.transition()"
        }, 
        {
            "location": "/api/#ractiveunlink", 
            "text": "Removes a link set up by  ractive.link() .  Syntax   ractive.unlink(destination)   Arguments   destination (string) : The destination supplied to [ ractive.link() ].   Returns   (Promise) : A promise.   Examples  // TODO", 
            "title": "ractive.unlink()"
        }, 
        {
            "location": "/api/#ractiveunrender", 
            "text": "Unrenders this Ractive instance, throwing away any DOM nodes associated with this instance. This is the counterpart to  ractive.render() . The rest of the ractive instance is left intact, unlike  ractive.teardown() .  Note that if the instance happens to be a component that is managed by another instance, the owning instance may veto the call to  unrender . If you need more precise control over component rendering, you should probably use an anchor and  ractive.attachChild()  instead.  Syntax   ractive.unrender()   Arguments   None   Returns   (Promise) : A promise.   Examples  // TODO", 
            "title": "ractive.unrender()"
        }, 
        {
            "location": "/api/#ractiveunshift", 
            "text": "The Ractive equivalent to  Array.unshift  that prepends one or more elements to the array at the given keypath and triggers an update event.  If the given keypath does not exist (is  undefined ), an empty array will be supplied instead. Otherwise, if the given keypath does not resolve to an array, an error will be thrown.  Syntax   ractive.unshift(keypath, value)   Arguments   keypath (string) : The keypath of the array to change, e.g.  list  or  order.items .  value (any) : The value to prepend to the beginning of the array. One or more values may be supplied.   Returns   (Promise) : Returns a promise that will resolve after the update is complete.   Examples  // TODO", 
            "title": "ractive.unshift()"
        }, 
        {
            "location": "/api/#ractiveupdate", 
            "text": "\"Dirty checks\" everything that depends directly or indirectly on the specified keypath. If no  keypath  is specified, all keypaths will be checked. Keypaths that involve special references (i.e.  @global ) require the keypath to be supplied.  This is useful when manipulating the instance's data without using the built in setter methods (i.e.  ractive.set() ,  ractive.animate() ).  Syntax   ractive.update([keypath][, options])   Arguments   [keypath] (string) : The keypath to treat as 'dirty'.  [options] (Object string, any ) :  force (boolean) : Force an update regardless of whether or not the internal change check determines that the keypath has  actually  changed. This is useful for forcing all expressions referencing a particular function to recompute.     Returns   (Promise) : A promise that resolves when any transitions associated with the operation complete.   Examples  ractive.observe( 'foo', function ( foo ) {\n  alert( foo )\n})\n\nmodel.foo = 'changed';   // Does not cause the instance to update.\nractive.update( 'foo' ); // Informs the instance that foo was changed externally.", 
            "title": "ractive.update()"
        }, 
        {
            "location": "/api/#ractiveupdatemodel", 
            "text": "If you programmatically manipulate inputs and other elements that have two\u2010way binding set up, your model can get out of sync. In these cases, we need to force a resync with  ractive.updateModel() :  Syntax   ractive.updateModel([keypath[, cascade]])   Arguments   keypath (string) : The keypath to treat as 'dirty'. Any two-way bindings linked to this keypath will be checked to see if the model is out of date  cascade (boolean) : If true, bindings that are  downstream  of  keypath  will also be checked - e.g.  ractive.updateModel( 'items', true )  would check  items.0.foo  and  items.1.foo  and so on. Defaults to  false .   Returns   (Promise) : A promise. If a  keypath  is not specified, all two-way bindings will be checked.   Examples  ractive = Ractive({\n  el: 'container',\n  template: ' input value= {{name}} '\n  data: { name: 'Bob' }\n})\n\nractive.find( 'input' ).value = 'Jim'\nalert( ractive.get( 'name' ) ); // alerts 'Bob', not 'Jim'\n\nractive.updateModel()\nalert( ractive.get( 'name' ) ); // alerts 'Jim'", 
            "title": "ractive.updateModel()"
        }, 
        {
            "location": "/api/#ractiveuse_1", 
            "text": "From 0.10.0  Install one or more plugins in a Ractive instance.  Syntax   ractive.use(plugin[, ...plugin])   Arguments   plugin (plugin) : A plugin function that receives  { Ractive, instance: ractive, proto: ractive }  as an argument.   Returns   (this) : The instance on which the method was called.", 
            "title": "ractive.use()"
        }, 
        {
            "location": "/api/#context-object", 
            "text": "The context object is the type of object you receive when calling getContext(). This object contains various properties and methods that allow you to interact with and obtain information about the Ractive instance, the node associated with it and the context surrounding it.  The special  @context  reference is also a context object that is associated with the nearest VDOM item and element. It's frequently used with event directives to interact with the data associated with the immediate context.  Helper methods that take a keypath will resolve relative to that node's context. Special references, template aliases, and key and index aliases are supported. If the method doesn't require a keypath, like  get , then the keypath will implicitly be  .  rather than  ~/ , as with regular instance methods.", 
            "title": "Context Object"
        }, 
        {
            "location": "/api/#contextadd", 
            "text": "See ractive.add().", 
            "title": "context.add()"
        }, 
        {
            "location": "/api/#contextanimate", 
            "text": "See ractive.animate().", 
            "title": "context.animate()"
        }, 
        {
            "location": "/api/#contextdecorators", 
            "text": "(Object)  A map of decorator name to decorator return object for all of the decorators on the node associated with the context.", 
            "title": "context.decorators"
        }, 
        {
            "location": "/api/#contextevent", 
            "text": "(Event|undefined)  The original event for contexts supplied to event directives. This is  undefined  for contexts not associated with an event.", 
            "title": "context.event"
        }, 
        {
            "location": "/api/#contextget", 
            "text": "See ractive.get().", 
            "title": "context.get()"
        }, 
        {
            "location": "/api/#contextgetbinding", 
            "text": "Returns the value of the binding if the node represented by this info object has a two-way binding.  Syntax   context.getBinding()   Arguments   None   Returns   (any) : The value of the binding.   Examples  {{#with foo.bar}} input id= findMe  value= {{.baz}}  / {{/with}}  Ractive.getContext('#findMe').getBinding(); // returns value of foo.bar.baz", 
            "title": "context.getBinding()"
        }, 
        {
            "location": "/api/#contextgetbindingpath", 
            "text": "Returns the keypath of the binding if the node represented by this info object has a two-way binding.  Syntax   context.getBindingPath([ractive])   Arguments   [ractive] (Ractive) : The instance to resolve the keypath against.   Returns   (string) : The keypath of the node binding.   Examples  {{#with foo.bar}} input id= findMe  value= {{.baz}}  / {{/with}}  Ractive.getContext('#findMe').getBindingPath(); // Returns  foo.bar.baz", 
            "title": "context.getBindingPath()"
        }, 
        {
            "location": "/api/#contextgetparent", 
            "text": "From 0.9.4  Gets the parent context of this context. This is finer grained than element access provided by  Ractive.getContext , as it can target sections that exist nested between elements.  Syntax   context.getParent(crossComponentBoundary)   Arguments   crossComponentBoundary (boolean) : Whether or not to cross into the context containing a component. Defaults to  false .   Returns   (context) : The parent context object.   Examples  div {{#with foo.bar}}{{#with .baz}} span / {{/with}}{{/with}} /div   const ctx = Ractive.getContext('span')\nctx.resolve(); // foo.bar.baz\nconst parent = ctx.getParent()\nparent.resolve(); // foo.bar", 
            "title": "context.getParent()"
        }, 
        {
            "location": "/api/#contexthaslistener", 
            "text": "Returns  true  if the element associated with the context has a Ractive-managed event listener for a given event name. The target event does not have to be an actual DOM event, so this method can be used conveniently in conjunction with  context.raise .  Syntax   context.hasListener(event[, bubble])   Arguments   event (string) : The name of the event for which to check for listeners.  bubble (boolean) : Whether or not to check parent elements for the event name as well, should the target element not have a listener. Defaults to  false .   Returns   (boolean) :  true  if a listener was found or  false  otherwise.   Examples  section on-other= othered \n   article on-thing= thinged Some text... /article  /section   const ctx = ractive.getContext('article');\nctx.hasListener('thing'); // true\nctx.hasListener('other'); // false\nctx.hasListener('other', true); // true", 
            "title": "context.hasListener()"
        }, 
        {
            "location": "/api/#contextisbound", 
            "text": "Returns  true  if the node represented by this info object has a two-way binding.  Syntax   context.isBound()   Arguments   None   Returns   (boolean) :  true  if the node represented has a two-way binding.   Examples  {{#with foo.bar}}\n   input id= foo  value= {{.baz}}  / \n   input id= bar  value=  / \n{{/with}}  Ractive.getContext('#foo').isBound(); // Returns true\nRactive.getContext('#bar').isBound(); // Returns false", 
            "title": "context.isBound()"
        }, 
        {
            "location": "/api/#contextlink", 
            "text": "See ractive.link().", 
            "title": "context.link()"
        }, 
        {
            "location": "/api/#contextlisten", 
            "text": "Subscribes an event listener either directly on the node associated with the context or as a delegate if appropriate. This is not like the  on  method, but is instead basically an  addEventListener  helper that is delegation-aware.  Syntax  context.listen( event, callback )  Arguments   event (string) : The name of the event to subscribe.  callback (function) : The callback function to be called when the event fires.   Returns   (Object) : An object with a  cancel  method to unlisten the event.", 
            "title": "context.listen()"
        }, 
        {
            "location": "/api/#contextnode", 
            "text": "(Node|undefined)  The node associated with the context. Note that it is possible to get a context that is not associated with an element, which will leave the node  undefined .", 
            "title": "context.node"
        }, 
        {
            "location": "/api/#contextobserve", 
            "text": "See ractive.observe().", 
            "title": "context.observe()"
        }, 
        {
            "location": "/api/#contextobserveonce", 
            "text": "See ractive.observeOnce().", 
            "title": "context.observeOnce()"
        }, 
        {
            "location": "/api/#contextoriginal", 
            "text": "(Event|undefined)  The original DOM event object. Normally present when the event is a Ractive DOM event. May be  undefined  on custom events or events from event plugins.", 
            "title": "context.original"
        }, 
        {
            "location": "/api/#contextpop", 
            "text": "See ractive.pop().", 
            "title": "context.pop()"
        }, 
        {
            "location": "/api/#contextpush", 
            "text": "See ractive.push().", 
            "title": "context.push()"
        }, 
        {
            "location": "/api/#contextractive", 
            "text": "(Ractive)  This property holds a reference to the Ractive instance that controls the node represented by this info object.", 
            "title": "context.ractive"
        }, 
        {
            "location": "/api/#contextraise", 
            "text": "Triggers the nearest matching event directive relative to the context. This is useful for decorators and other library constructs that want to be able to raise their own events that aren't necessarily tied to a DOM event. Raised events do not bubble.  Syntax   context.raise(eventName[, event[, ...args]])   Arguments   eventName (string) : The name of the event to raise. For  div on-something=\"...\" , the event name would be  'something' .  [event] (context|object) : The context for the event or an object of properties to assign to the context for the event. Defaults to  {} .  [args] (...any) : Additional arguments to supply to the event handler.   Examples  // TODO", 
            "title": "context.raise()"
        }, 
        {
            "location": "/api/#contextreadlink", 
            "text": "See ractive.readLink().", 
            "title": "context.readLink()"
        }, 
        {
            "location": "/api/#contextresolve", 
            "text": "Resolves the given keypath to a full keypath. If a Ractive instance is supplied, the resolved path will also account for any mappings defined for the instance.  Syntax   context.resolve([keypath[, ractive]])   Arguments   [keypath] (string) : The keypath to resolve.  [ractive] (Ractive) : The instance to resolve the keypath against.   Returns   (string) : The resolved keypath.   Examples  // TODO", 
            "title": "context.resolve()"
        }, 
        {
            "location": "/api/#contextreverse", 
            "text": "See ractive.reverse().", 
            "title": "context.reverse()"
        }, 
        {
            "location": "/api/#contextset", 
            "text": "See ractive.set().", 
            "title": "context.set()"
        }, 
        {
            "location": "/api/#contextsetbinding", 
            "text": "Sets the binding of the node represented by this info object to the specified value.  Syntax   context.setBinding(value)   Arguments   value (any) . The value to set.   Returns   (Promise)   Examples  // TODO", 
            "title": "context.setBinding()"
        }, 
        {
            "location": "/api/#contextshift", 
            "text": "See ractive.shift().", 
            "title": "context.shift()"
        }, 
        {
            "location": "/api/#contextsplice", 
            "text": "See ractive.splice().", 
            "title": "context.splice()"
        }, 
        {
            "location": "/api/#contextsort", 
            "text": "See ractive.sort().", 
            "title": "context.sort()"
        }, 
        {
            "location": "/api/#contextsubtract", 
            "text": "See ractive.subtract().", 
            "title": "context.subtract()"
        }, 
        {
            "location": "/api/#contexttoggle", 
            "text": "See ractive.toggle().", 
            "title": "context.toggle()"
        }, 
        {
            "location": "/api/#contextunlink", 
            "text": "See ractive.unlink().", 
            "title": "context.unlink()"
        }, 
        {
            "location": "/api/#contextunlisten", 
            "text": "Unsubscribe an event listener that was subscribed with  listen . This is basically a  removeEventListener  helper that is delegation-aware.  Syntax  context.unlisten( event, callback )  Arguments   event (string) : The name of the event to unsubscribe.  callback (function) : The callback that was previously subscribed.", 
            "title": "context.unlisten()"
        }, 
        {
            "location": "/api/#contextunshift", 
            "text": "See ractive.unshift().", 
            "title": "context.unshift()"
        }, 
        {
            "location": "/api/#contextupdate", 
            "text": "See ractive.update().", 
            "title": "context.update()"
        }, 
        {
            "location": "/api/#contextupdatemodel", 
            "text": "See ractive.updateModel().", 
            "title": "context.updateModel()"
        }, 
        {
            "location": "/api/#parse-object", 
            "text": "The parse object is an object you receive as the second argument in function templates. This helper object provides you with essential functions to dissect markup before turning over the template for use.", 
            "title": "Parse Object"
        }, 
        {
            "location": "/api/#pfromid", 
            "text": "Retrieves the template from the DOM  script  tag specified by  id . Make sure to set  type='text/ractive'  on the  script  tag to prevent the browser from running the template as a script.  Syntax   p.fromId(id)   Arguments   id (string) : The id of the  script  tag containing the template. The leading  #  is optional.   Returns   (string) : The template inside the specified element.   Examples  // TODO", 
            "title": "p.fromId()"
        }, 
        {
            "location": "/api/#pisparsed", 
            "text": "Test whether the supplied template is already parsed and is in its object form.  Syntax   p.isParsed(template)   Arguments   template (string|Object) : The template, either in its string form or object form.   Returns   (boolean) : Returns  true  if the template is already parsed,  false  if otherwise.   Examples  // TODO", 
            "title": "p.isParsed()"
        }, 
        {
            "location": "/api/#pparse", 
            "text": "Parses the template using Ractive.parse(). Full Ractive runtime must be loaded.  Syntax   p.parse(template[, parseOptions])   Arguments   template (string|Object) : The template in its string form or object form.  parseOptions] (Object) : Template parser options. See [Ractive.parse() for all available options. If  parseOptions  is not specified, it defaults to those of the current instance.   Returns   (Object) : The parsed template.   Examples  // TODO", 
            "title": "p.parse()"
        }, 
        {
            "location": "/api/#transition-object", 
            "text": "The transition object is an object you receive when writing transitions. It has a few properties and methods designed to make creating transitions easier.", 
            "title": "Transition Object"
        }, 
        {
            "location": "/api/#tanimatestyle", 
            "text": "Animates CSS properties to a certain value.  Syntax   t.animateStyle(prop, value, options[, complete])  t.animateStyle(props, options[, complete])   Arguments   props (Object) : A map of animation properties and values.  prop (string) : The style to animate.  value (any) : The value to animate it to.  options (Object) : Animation options.  duration (number) : The duration of the animation.  easing (string) : The easing function of the animation.  delay (number) : The number of milliseconds before the animation starts.  [complete] (Function) : A function that is executed when the animation completes, or immediately if no changes were made.   Returns   (Promise) : A promise that resolves when the animation completes.   Examples  // TODO", 
            "title": "t.animateStyle()"
        }, 
        {
            "location": "/api/#tcomplete", 
            "text": "Signals Ractive that the transition is complete.  Syntax   t.complete[noReset])   Arguments   noReset] (boolean) : If  true , [ t.resetStyle()  is not called. Defaults to  false .   Returns   (undefined)   Examples  // TODO", 
            "title": "t.complete()"
        }, 
        {
            "location": "/api/#tgetstyle", 
            "text": "Retrieve a CSS property value from  t.node .  Syntax   t.getStyle(prop)   Arguments   prop (string) : An unprefixed CSS property either in camelCase or kebab-case.  prop (Array) : An array of CSS properties.   Returns   (string) : The value of the specified style property.  (Object) : A key-value pair of properties and their respective values.   Examples  // TODO", 
            "title": "t.getStyle()"
        }, 
        {
            "location": "/api/#tisintro", 
            "text": "(boolean)  Should be self-explanatory...", 
            "title": "t.isIntro"
        }, 
        {
            "location": "/api/#tname", 
            "text": "(string)  The name of the transition.", 
            "title": "t.name"
        }, 
        {
            "location": "/api/#tnode", 
            "text": "(Node)  The node that's entering or leaving the DOM", 
            "title": "t.node"
        }, 
        {
            "location": "/api/#tprocessparams", 
            "text": "Builds a map of parameters whose values are taken from the provided arguments. When used with a single number or string argument, serves as a shorthand for creating a map with a  duration  property.  Syntax   t.processParams(params[, defaults])   Arguments   params (number) : Numeric shorthand for the  duration  parameter. Expressed in milliseconds.  params (string) : String shorthand for the  duration  parameter. Valid values are:  \"fast\" - 200ms  \"slow\" - 600ms  Any other string - 400ms    params (Object) : A map of parameters and their values.  [defaults] (Object) : A map of parameters and their default values.   Returns   (Object) : A map of parameters and their values.   Examples  // TODO", 
            "title": "t.processParams()"
        }, 
        {
            "location": "/api/#tsetstyle", 
            "text": "Sets a CSS property on  t.node  to a value.  Syntax   t.setStyle(prop, value)  t.setStyle(props)   Arguments   prop (string) : An unprefixed CSS property either in camelCase or kebab-case.  props (Object) : A key-value pair of CSS properties and their respective values.  value (string) : A valid value for the specified CSS property.   Returns   (undefined)   Examples  // TODO", 
            "title": "t.setStyle()"
        }, 
        {
            "location": "/api/#component-files", 
            "text": "Remember the good old days? When all CSS went in  style  elements in  head ? When all JS went in  script  elements just before  /body ? When all HTML was written in Mustache inside inert  script  elements? When it felt good when everything just worked after a page refresh? Ractive remembers, and it's bringing those good times back with component files.  Ractive component files are simply self-contained HTML files that define a component and contains all the markup, data, styles and logic it needs. It's also designed with dependency management in mind, allowing it to declare library and component dependencies. Best of all, component files are written in the same way regardless of the development process involved, build step or none.", 
            "title": "Component files"
        }, 
        {
            "location": "/api/#example-component-file", 
            "text": "!-- Example component file --  !-- Import a component named Foo from the file foo.html. --  link rel='ractive' href='foo.html' name='foo'  !-- Define the markup for this component. --  h1 {{ title }} /h1  !-- Use imported foo component --  p This is an imported 'foo' component:  foo/ /p  !-- Define the styles for this component. --  style \n  p { color: red; } /style  !-- Define the behavior for this component. --  script \nconst $ = require( 'jquery' )\n\ncomponent.exports = {\n  onrender () {\n    $(' p / ').text('component rendered').insertAfter($this.find('p'))\n  },\n  data: {\n    title: 'Hello World!'\n  }\n} /script   The above component file roughly translates to the following in vanilla JS:  import Ractive from 'ractive'\nimport $ from 'jquery'\nimport foo from './foo.html'\n\nexport default Ractive.extend({\n  components: { foo },\n  onrender () {\n    $(' p / ').text('component rendered').insertAfter($this.find('p'))\n  },\n  data: {\n    title: 'Hello World!'\n  },\n  template: `\n     h1 {{ title }} /h1 \n     p This is an imported 'foo' component:  foo/ /p \n  `,\n  css: `\n    p { color: red; }\n  `\n})", 
            "title": "Example component file"
        }, 
        {
            "location": "/api/#writing", 
            "text": "", 
            "title": "Writing"
        }, 
        {
            "location": "/api/#link-relractive", 
            "text": "Top-level  link rel=\"ractive\"  elements define dependencies on other components. It accepts two attributes:    href  - The path to the required component file. Paths that start with  ./  or  ../  are resolved relative to the importing component file. Otherwise, resolution is loader-specific.    name  (optional) - The registered name of the component. This corresponds to the key used in the  components  initialization option. When not defined, the filename of the dependency will be used as the name.    The names and the loaded dependency will be assigned to the component's  components  initialization option.", 
            "title": "&lt;link rel=\"ractive\"&gt;"
        }, 
        {
            "location": "/api/#style_1", 
            "text": "Top-level  style  elements define the styles for the component. If more than one  style  element is found on the component file, their contents are concatenated in the order of appearance of the  style  elements. Contents of these elements will be concatenated and assigned to the component's  css  initialization option.", 
            "title": "&lt;style&gt;"
        }, 
        {
            "location": "/api/#script", 
            "text": "A top-level  script  defines the component's initialization. The script's scope has a  component  object that is similar to Node's  module  object. Initialization options for the component is expected via  component.exports . It also has a special  require  function that fetches script dependencies.  require 's behavior depends on the loader used. Refer to the specific loader's documentation to know more.  There can only ever be one  script  in a component file. Defining more than one will result in the loader throwing an error.", 
            "title": "&lt;script&gt;"
        }, 
        {
            "location": "/api/#template_1", 
            "text": "After yanking out top-level  link rel=\"ractive\" ,  style  or  script  from the component file, anything that's left becomes a part of the template. The remaining markup will be assigned to the component's  template  initialization option.", 
            "title": "Template"
        }, 
        {
            "location": "/api/#using", 
            "text": "In order to use component files, you will have to use  loaders , Head over to  the loaders page  to learn more about loaders and help you choose a loader that suits your needs.", 
            "title": "Using"
        }, 
        {
            "location": "/plugins/", 
            "text": "Adaptors\n\n\nIn some cases you want to write your UI in Ractive but have a custom back-end manage the data. Adaptors allow you to teach Ractive how to talk to those custom data sources without having to change the way you write Ractive or having to write a lot of connector code up front.\n\n\nWriting\n\n\nAdaptors translate custom non-POJO (non-Plain Old JS Object) data sources into POJOs and vice-versa. Generally, an adaptor does the following:\n\n\n\n\nChecks if data needs to be adapted, and if so, \"wraps\" an adaptor to it.\n\n\nProvides a POJO version of your data source for Ractive to use.\n\n\nCaptures data changes on your data source and mirror them to the data in Ractive.\n\n\nCaptures data changes on the data in Ractive and mirror them to the data source.\n\n\n\n\nconst myAdaptor = {\n  filter ( value, keypath, ractive ) {\n    // return `true` if a particular object is of the type we want to adapt.\n  },\n  wrap ( ractive, value, keypath, prefixer ) {\n    // Setup\n    return {\n      get () {\n        // Returns POJO version of your data backend.\n      },\n      set (property, value) {\n        // Data setter for POJO property keypaths.\n      },\n      reset (value) {\n        // Data setter for POJO keypath.\n      },\n      teardown () {\n        // Code executed on teardown.\n      }\n    }\n  }\n}\n\n\n\n\nAn adaptor definition is an object with two methods:\n\n\n\n\nfilter\n: A function which, if it returns \ntrue\n, tells Ractive to use the adaptor on the value.\n\n\nvalue\n: The value to check.\n\n\nkeypath\n: The keypath of \nvalue\n relative to the instance root.\n\n\nractive\n: The instance where \nvalue\n resides.\n\n\n\n\n\n\nwrap\n: A function that sets up an adaptor.\n\n\nractive\n: The instance where \nvalue\n resides.\n\n\nvalue\n: The value to adapt.\n\n\nkeypath\n: The keypath of \nvalue\n relative to the instance root.\n\n\nprefixer\n: A function that accepts an object and returns a shallow clone with its keys prepended with \nkeypath\n.\n\n\n\n\n\n\n\n\nThe \nwrap\n function must return an object with four methods:\n\n\n\n\nget\n: A function that returns the POJO representation of the adapted data.\n\n\nset\n: A function that's called when the keypath being updated is a property of the adapted data.\n\n\nproperty\n: The property name to be updated.\n\n\nvalue\n: The new value.\n\n\n\n\n\n\nreset\n: A function that's called when the keypath being updated is the adapted data itself. If \nreset\n returns \nfalse\n, Ractive will replace the data on the keypath with the POJO version, and tear down the adaptor.\n\n\nvalue\n: The new value\n\n\n\n\n\n\nteardown\n: A function that's called when an adaptor is being removed.\n\n\n\n\nAdaptors only adapt one level\n\n\nAn adaptor only adapts an object's immediate properties. Updating nested data via Ractive or via the data source will not update the other.\n\n\nNo built-in infinite loop detection\n\n\nThere is no built-in mechanism for avoiding infinite loops. If your adaptor calls \nractive.set()\n on adapted data, which in turn will call the adaptor's \nset()\n method, which may directly or indirectly trigger another \nractive.set()\n on the same adapted data, a stack overflow error might occur.\n\n\nThis isn't a problem with primitive values since Ractive doesn't bother calling \nset()\n if a value hasn't changed. But with objects and arrays, there's no easy and performant way to tell if the contents have changed. So \nset()\n gets called \nin case something changed\n rather than \nbecause something changed\n.\n\n\nDifferent for every back-end\n\n\nThe adaptor structure only provides you with the means to talk to and listen from a custom back-end. It does not impose any rules on how to write an adaptor for a certain back-end. For instance, an adaptor for a constructor-based object may be written differently from an adaptor meant to interact with a socket server.\n\n\nRegistering\n\n\nLike other plugins, there's 3 ways you can register adaptors:\n\n\nGlobally, via the \nRactive.adaptors\n static property.\n\n\nRactive.adaptors.myAdaptor = myAdaptor\n\n\n\n\nPer component, via the component's \nadaptors\n initialization property.\n\n\nconst MyComponent = Ractive.extend({\n  adaptors: { myAdaptor }\n})\n\n\n\n\nPer instance, via the instance's \nadaptors\n initialization property.\n\n\nconst ractive = Ractive({\n  adaptors: { myAdaptor }\n})\n\n\n\n\nUsing\n\n\nIn order to use an adaptor, you must tell the component or an instance to use it using the \nadapt\n initialization option.\n\n\nconst ractive = Ractive({\n  adapt: [ 'myAdaptor' ]\n})\n\n\n\n\nExamples\n\n\nIn the following example, we have a \nBox\n constructor that uses accessors to get and set its \nwidth\n and \nheight\n properties. Since an instance of \nBox\n will have no publicly visible properties, Ractive cannot bind to them directly.\n\n\nfunction Box(width, height) {\n  var _width = width\n  var _height = height\n\n  this.getWidth = () =\n { return _width; }\n  this.setWidth = (width) =\n { _width = width; }\n  this.getHeight = () =\n { return _height; }\n  this.setHeight = (height) =\n { _height = height }\n}\n\n\n\n\nIn order for Ractive to properly use a \nBox\n instance, we build an adaptor for \nBox\n.\n\n\nRactive.adaptors.boxAdaptor = {\n  filter ( object ) {\n    // Checks if the piece of data is an instance of Box.\n    return object instanceof Box\n  },\n  wrap ( ractive, box, keypath, prefixer ) {\n\n    // We keep a reference to the original functions before monkey-patching.\n    const setWidth = box.setWidth\n    const setHeight = box.setHeight\n\n    // Use ractive.set on the the adapted data whenever the setters are used.\n    box.setWidth = (width) =\n {\n      ractive.set(prefixer({\n        width: width\n      }))\n    }\n\n    box.setHeight = (height) =\n {\n      ractive.set(prefixer({\n        height: height\n      }))\n    }\n\n    return {\n      // Return a POJO representation of an instance of Box.\n      get () {\n        return {\n          width: box.getWidth(),\n          height: box.getHeight()\n        }\n      },\n      // Update the adapted object's properties\n      set (property, value) {\n        if(property === 'width') setWidth.call(box, value)\n        if(property === 'height') setHeight.call(box, value)\n      },\n      // Update the adapted object.\n      reset (data) {\n        // We don't adapt non-objects. And if the new data is an instance of Box\n        // there's a high chance that its a new instance. In either case, we\n        // need to tear down this adapter and have Ractive set it up again if\n        // necessary.\n        if(typeof data !== 'object' || data instanceof Box) return false\n\n        // Otherwise, we just parse through the data and update the existing box\n        // instance.\n        if(data.width !== undefined) setWidth.call(box, data.width)\n        if(data.height !== undefined) setHeight.call(box, data.height)\n      },\n      // Delete the monkey-patched methods.\n      teardown () {\n        delete box.setWidth\n        delete box.setHeight\n      }\n    }\n  }\n}\n\n\n\n\nThen we use \nboxAdaptor\n on an instance. The data can now be treated like regular Ractive data. Updates done directly on \nbox\n will reflect on Ractive. Any changes via Ractive will reflect on \nbox\n.\n\n\nconst ractive = Ractive({\n  el: 'body',\n  // Tell the instance we'll be using boxAdaptor\n  adapt: [ 'boxAdaptor' ],\n  // We write Ractive like normal.\n  template: `\n    \ndiv\nBox is {{ box.width }}x{{ box.height }}\n/div\n,\n    \ndiv\ninput type=\ntext\n value=\n{{ box.width }}\n/div\n\n    \ndiv\ninput type=\ntext\n value=\n{{ box.height }}\n/div\n\n  `\n})\n\nconst box = new Box(3, 4)\n\n// Set the Box instance as if it were a POJO.\nractive.set('box', box)\n\n// Both box instance and box object will have 7 width and 11 height and will\n// be rendered in the UI accordingly.\nbox.setWidth(7)\nractive.set('box.height', 11)\n\n\n\n\nComponents\n\n\nIn many situations, you want to encapsulate behaviour and markup into a single reusable \ncomponent\n, which can be dropped into Ractive applications. Components are simply custom-configured \"subclasses\" of Ractive (analogous, but technically incorrect).\n\n\nWriting\n\n\nThere are several ways to write Ractive components. Standard initialization options apply for configuration unless where changes are explicitly mentioned.\n\n\nThe most common way to define a component is by using \nRactive.extend()\n.\n\n\n// A subclass of Ractive\nconst MyComponent = Ractive.extend({\n  template: `\n    \ndiv class=\nmy-component\n\n      \nspan class=\nmy-component__message\n{{ message }}\n/span\n\n    \n/div\n\n  `,\n  css: `\n    .my-component__message { color: red }\n  `,\n  data: { message: 'Hello World' }\n})\n\n\n\n\nAnother way to define a component is by using component files and loaders.\n\n\ndiv class=\nmy-component\n\n  \nspan class=\nmy-component__message\n{{ message }}\n/span\n\n\n/div\n\n\n\nstyle\n\n  .my-component__message { color: red }\n\n/style\n\n\n\nscript\n\ncomponent.exports = {\n  data: { message: 'Hello World' }\n}\n\n/script\n\n\n\n\n\nRegistering\n\n\nLike other plugins, there's 3 ways you can register components:\n\n\nGlobally, via the \nRactive.components\n static property:\n\n\n// Available to all instances of Ractive.\nRactive.components.MyComponent = Ractive.extend({ ... })\n\n\n\n\nPer component, via the component's \ncomponents\n initialization property.\n\n\n// Only available for instances of AnotherComponent.\nconst AnotherComponent = Ractive.extend({\n  components: { MyComponent }\n})\n\n\n\n\nPer instance, via the instance's \ncomponents\n initialization property.\n\n\n// Only available to this specific instance.\nconst ractive = Ractive({\n  components: { MyComponent }\n})\n\n\n\n\nUsing\n\n\nComponents are simply subclasses of Ractive, which means they are also instatiable.\n\n\nconst ractive = MyComponent({ ... })\n\n\n\n\nBut where components really shine is when they're used on templates. They are written like \ncustom elements\n. Each custom element notation represents one instance of the component.\n\n\nconst AnotherComponent = Ractive.extend({\n  template: `\n    \ndiv\n\n      \nMyComponent /\n \n!-- One instance of MyComponent --\n\n      \nMyComponent /\n \n!-- Another instance of MyComponent --\n\n      \nMyComponent /\n \n!-- Yet another instance of MyComponent --\n\n    \n/div\n\n  `\n})\n\n\n\n\nThe component's tag name depends on the name used upon registration. The same component can be registered more than once using different names.\n\n\nconst MyComponent = Ractive.extend({...})\nRactive.components.MyComponent = MyComponent\nRactive.components.MyComponentOtherName = MyComponent\n\nconst AnotherComponent = Ractive.extend({\n  template: `\n    \ndiv\n\n      \nMyComponent /\n          \n!-- Using MyComponent --\n\n      \nMyComponentOtherName /\n \n!-- Using MyComponent's other name --\n\n    \n/div\n\n  `\n})\n\n\n\n\nExamples\n\n\n\n\n\nDecorators\n\n\nA decorator is a simple way to add behaviour to a node when it is rendered, or to augment it in some way. Decorators are a good way to integrate DOM manipulation libraries with Ractive, such as \njQuery UI\n or \nBootstrap\n.\n\n\nWriting\n\n\nconst myDecorator = (node[, ...args]) =\n {\n  // Setup code\n  return {\n    teardown () {\n      // Cleanup code\n    },\n    update ([...args]) {\n      // Update code\n    },\n    invalidate () {\n      // Code called on invalidate\n    }\n  }\n}\n\n\n\n\nDecorators are simply functions that are called upon to setup the decorator once Ractive detects its use. It takes a \nnode\n argument and returns an object with a \nteardown\n and \nupdate\n property.\n\n\nnode\n is the element to which the decorator is applied to.\n\n\n[args]\n are optional arguments provided by the decorator directive.\n\n\nteardown\n is a function that gets called when the decorator is torn down.\n\n\nupdate\n is an optional function that gets called when the arguments update.\n\n\ninvalidate\n, starting with 0.9.3, is an optional function that gets called when any bit of template downstream from the node is being updated.\n\n\nAny updates to the arguments will call the decorator's \nteardown\n and run the decorator function again, essentially setting up the decorator again. If an \nupdate\n function is provided on the return object, that will be called instead of the \nteardown\n and setup function.\n\n\nRegistering\n\n\nLike other plugins, there's 3 ways you can register decorators:\n\n\nGlobally, via the \nRactive.decorators\n static property.\n\n\nRactive.decorators.myDecorator = myDecorator\n\n\n\n\nPer component, via the component's \ndecorators\n initialization property.\n\n\nconst MyComponent = Ractive.extend({\n  decorators: { myDecorator }\n})\n\n\n\n\nPer instance, via the instance's \ndecorators\n initialization property.\n\n\nconst ractive = Ractive({\n  decorators: { myDecorator }\n})\n\n\n\n\nUsing\n\n\nOne or more decorators can be added to an element via the \nas-*\n directive. Arguments are passed to the decorator function by supplying comma-separated expressions as values. These expressions will become the second argument and onwards of the transition function.\n\n\n!-- without arguments --\n\n\ndiv as-myDecorator\n...\n/div\n\n\n\n!-- with arguments --\n\n\ndiv as-myDecorator=\narg1, .some.other.arg2, 10 * @index\n as-somethingElseToo\n...\n/div\n\n\n\n\n\nExamples\n\n\nThe following example builds a decorator that updates the time.\n\n\nRactive.decorators.timer = (node, time) =\n {\n  node.innerHTML = 'Hello World!'\n\n  return {\n    teardown () {\n      node.innerHTML = ''\n    },\n    update (time) {\n      node.innerHTML = time\n    }\n  }\n}\n\nconst ractive = Ractive({\n  el: 'body',\n  template: `\n    \nspan as-timer=\ntime\n/span\n\n  `,\n  data: {\n    time: 0\n  }\n})\n\nsetInterval(function () {\n  ractive.set('time', Date.now())\n}, 1000)\n\n\n\n\nEasings\n\n\nEasing functions describe the animation's progression from start to finish. Easings are used by \nractive.animate\n and some transitions. Out of the box, Ractive comes with \nlinear\n, \neaseIn\n, \neaseOut\n and \neaseInOut\n.\n\n\nWriting\n\n\nconst myEasing = ( t ) =\n {\n  // Calculation\n  return v\n}\n\n\n\n\nEasing functions receive \nt\n, a value from \n0\n to \n1\n, which represents the linear progression of the animation from start to finish. The easing function must then return \nv\n, a value also from \n0\n to \n1\n, which represents the progress of the animation for that easing.\n\n\nRegistering\n\n\nLike other plugins, there's 3 ways you can register an easing function:\n\n\nGlobally via the \nRactive.easing\n static property.\n\n\nRactive.easing.myEasing = myEasing\n\n\n\n\nPer component via the component's \neasing\n initialization property.\n\n\nconst MyComponent = Ractive.extend({\n  easing: { myEasing }\n})\n\n\n\n\nPer instance, via the instance's \neasing\n initialization property.\n\n\nconst ractive = Ractive({\n  easing: { myEasing }\n})\n\n\n\n\nUsing\n\n\nEasing functions are utilized by \nractive.animate()\n and transitions to define animations.\n\n\n\nractive.animate('counter', 60, {\n  easing: 'myEasing'\n})\n\n\n\n\nExamples\n\n\nHere's an \nelastic\n easing function taken from \ndanro\n's excellent \neasing.js\n library.\n\n\nRactive.easing.elastic = ( t ) =\n {\n  return -1 * Math.pow(4,-8*t) * Math.sin((t*6-1)*(2*Math.PI)/2) + 1\n}\n\n\n\n\nEvents\n\n\nEvents allow custom-named events on DOM elements. Common use cases for custom DOM events include normalizing cross-browser events, normalizing cross-device events, implementing custom events, and so much more.\n\n\nWriting\n\n\nconst myEvent = (node, fire) =\n {\n  // Setup code\n  return {\n    teardown () {\n      // Cleanup code\n    }\n  }\n}\n\n\n\n\nEvents are simply functions that are called to set up the event on a DOM element. The event function accepts two arguments: \nnode\n and \nfire\n, and returns an object containing a \nteardown\n property.\n\n\nnode\n is the element to which the event is being applied.\n\n\nfire\n is the function that must be called when the event has taken place. \nfire\n takes a single argument, the event object received by handlers. The minimum requirement for the event object is a \nnode\n property that references DOM node the event is attached to, and an \noriginal\n property which references the native DOM \nevent\n object supplied by the native handler, if available.\n\n\nThe event object will be augmented with \ncontext\n, \nkeypath\n and \nindex\n properties, whose values depend on the data context the node is in. \ncontext\n references the data context that surrounds the node, \nkeypath\n is a string that leads to the current data context and \nindex\n is a number that references the index number of the data, should the data context be in an array.\n\n\nteardown\n is a function that gets called once the element is torn down. This allows the event to clean up after itself.\n\n\nRegistering\n\n\nLike other plugins, there's 3 ways you can register events:\n\n\nGlobally, via the \nRactive.events\n static property.\n\n\nRactive.events.myEvent = myEvent\n\n\n\n\nPer component, via the component's \nevents\n initialization property.\n\n\nconst MyComponent = Ractive.extend({\n  events: { myEvent }\n})\n\n\n\n\nPer instance, via the instance's \nevents\n initialization property.\n\n\nconst ractive = Ractive({\n  events: { myEvent }\n})\n\n\n\n\nUsing\n\n\nEvents use the same \non-*\n attribute syntax as component and DOM events. When Ractive encounters an \non-*\n attribute on a DOM element, it looks for a registered event and applies it on the element. If no matching event name was found, Ractive will think the event name is a native DOM event and will attach one accordingly.\n\n\n// This will apply the \nmyEvent\n custom event if one is registered.\n// Otherwise, Ractive will think it's a DOM event. You have been warned!\n\nspan on-myEvent=\nfoo()\nClick me!\n/span\n\n\n\n\n\nExamples\n\n\nHere's an example of a \"long press\" event which fires when the mouse is clicked and held for 1 second.\n\n\n// Definition\nRactive.events.longpress = (node, fire) =\n {\n  let timer = null\n\n  function clearTimer () {\n    if(timer) clearTimeout(timer)\n    timer = null\n  }\n\n  function mouseDownHandler(event) {\n    clearTimer()\n\n    timer = setTimeout(() =\n {\n      fire({\n        node: node,\n        original: event\n      })\n    }, 1000)\n  }\n\n  function mouseUpHandler () {\n    clearTimer()\n  }\n\n  node.addEventListener('mousedown', mouseDownHandler)\n  node.addEventListener('mouseup', mouseUpHandler)\n\n  return {\n    teardown () {\n      node.removeEventListener('mousedown', mouseDownHandler)\n      node.removeEventListener('mouseup', mouseUpHandler)\n    }\n  }\n}\n\n// Usage:\nRactive({\n  el: 'body',\n  template: `\n    \nbutton type=\nbutton\n on-longpress=\n@this.greetz()\nClick Me!\n/button\n\n  `,\n  greetz () {\n    console.log('Hello World!')\n  }\n})\n\n\n\n\nInterpolators\n\n\nInterpolator functions describe a value's progression during an animation from start to finish. Interpolator functions also determine the value on the model as well as what gets rendered during the animation.\n\n\nWriting\n\n\nconst myInterpolator = (from, to) =\n {\n\n  return t =\n {\n    return valueAtTimeT\n  }\n}\n\n\n\n\n\nInterpolator plugins accept \nfrom\n and \nto\n. \nfrom\n is the value on the animated keypath before calling \nractive.animate()\n and \nto\n is the value being set by \nractive.animate()\n. The plugin must return a function that receives \nt\n and returns a value that represents the animated value at \nt\n. \nt\n is a value from \n0\n to \n1\n representing the animation's progress with easing already applied.\n\n\nRegistering\n\n\nLike other plugins, there's 3 ways you can register an interpolator function:\n\n\nGlobally via the \nRactive.interpolators\n static property.\n\n\nRactive.interpolators.myInterpolator = myInterpolator\n\n\n\n\nPer component via the component's \ninterpolators\n initialization property.\n\n\nconst MyComponent = Ractive.extend({\n  interpolators: { myInterpolator }\n})\n\n\n\n\nPer instance, via the instance's \ninterpolators\n initialization property.\n\n\nconst ractive = Ractive({\n  interpolators: { myInterpolator }\n})\n\n\n\n\nUsing\n\n\nInterpolator functions are utilized by \nractive.animate()\n by supplying the interpolator name to the \ninterpolator\n option.\n\n\nractive.animate('counter', 60, {\n  interpolator: 'myInterpolator'\n})\n\n\n\n\nExamples\n\n\nHere's an abridged version of Ractive's built-in \nnumber\n interpolator which interpolates numeric values (numbers and number-like strings) during animation.\n\n\nRactive.interpolators.number = (from, to) =\n {\n  const start = Number(from)\n  const end = Number(to)\n\n  if (Number.isNaN(start) || Number.isNaN(end)) return null\n\n  const delta = end - start\n  const noChangeInterpolator = () =\n start\n  const changeInterpolator = t =\n start + (t * delta)\n  return delta ? changeInterpolator : noChangeInterpolator\n}\n\n\n\n\nPartials\n\n\nA partial is a template snippet which can be reused in templates or in other partials. They help to keep templates uncluttered, non-repetetive and easy to read.\n\n\nWriting\n\n\nconst myPartial = '\n!-- template --\n'\n\n\n\n\nPartials are simply Ractive templates.\n\n\nRegistering\n\n\nUnlike other plugins, partials have more than 3 registration options.\n\n\nGlobally via the \nRactive.partials\n static property.\n\n\nRactive.partials.myPartial = MyPartial\n\n\n\n\nGlobally, via a non-executing script tag on the current page.\n\n\nscript type=\nractive/template\n id=\nmyPartial\n\n  ...\n\n/script\n\n\n\n\n\nPer component, via the component's \npartials\n initialization property.\n\n\nconst MyComponent = Ractive.extend({\n  partials: { myPartial }\n})\n\n\n\n\nPer instance, via the instance's \npartials\n initialization property.\n\n\nconst ractive = Ractive({\n  partials: { myPartial }\n})\n\n\n\n\nIn-template, using the \n{{#partial}}\n mustache.\n\n\n{{#partial myPartial}}\n  ...\n{{/}}\n\n\n\n\nUsing\n\n\nPartials can be used using \n{{\npartialName}}\n. Partials work where any template would work and takes on its surrounding context.\n\n\n{{#partial myPartial}}\n  \ndiv class=\nmessage\n{{message}}\n/div\n\n{{/partial}}\n\n\ndiv class=\napp\n\n  {{\nmyPartial}}\n\n/div\n\n\n\n\n\nValid names\n\n\nPartials may be named with the same rules as any other identifier in Ractive or JavaScript, but since there isn't much danger of trying to do math in a partial name, they enjoy relaxed naming requirements that allow otherwise reserved globals and keywords to be used for partial names.\n\n\nPartial names may also contain \n-\n and \n/\n characters as long as they are surrounded by other valid characters e.g. \ntemplates/some-partial-template\n.\n\n\nContext\n\n\nPartials be given an explicit context. Simply supply a reference to the context following the partial name on usage.\n\n\nRactive({\n  data: {\n    foo:{\n      bar: 'Hello, World!'\n    }\n  },\n  template: `\n    {{#partial myPartial}}{{bar}}{{/partial}}\n\n    {{\nmyPartial foo}}\n  `\n})\n\n\n\n\nAliases\n\n\nReferences can also be aliased in partials. Simply define aliases as comma-separated \nreference as alias\n pairs following the partial name on usage.\n\n\nRactive({\n  data: {\n    status: 'Me, Hungry!',\n    foo:{\n      bar: 'Hello, World!'\n    }\n  },\n  template: `\n    {{#partial myPartial}}{{msg}} {{state}}{{/partial}}\n\n    {{\nmyPartial foo.bar as msg, status as state}}\n  `\n})\n\n\n\n\nRecursive partials\n\n\nPartials can be used recursively. A common use case for this is when reusing partials on a tree-like structure, like a directory listing.\n\n\ndiv class='fileSystem'\n\n  {{#root}}\n    {{\nfolder}}\n  {{/root}}\n\n/div\n\n\n{{#partial folder}}\n\nul class='folder'\n\n  {{#files}}\n    {{\nfile}}\n  {{/files}}\n\n/ul\n\n{{/partial}}\n\n{{#partial file}}\n\nli class='file'\n\n  \nimg class='icon-{{type}}'\n\n  \nspan\n{{filename}}\n/span\n\n\n  \n!-- if this is actually a folder, embed the folder partial --\n\n  {{# type === 'folder' }}\n    {{\nfolder}}\n  {{/ type === 'folder' }}\n\n/li\n\n{{/partial}}\n\n\n\n\nrv = Ractive({\n  el: 'container',\n  template: '#myTemplate',\n  data: {\n    root: {\n      files: [\n        { type: 'jpg', filename: 'hello.jpg' },\n        { type: 'mp3', filename: 'NeverGonna.mp3' },\n        { type: 'folder', filename: 'subfolder', files: [\n          { type: 'txt', filename: 'README.txt' },\n          { type: 'folder', filename: 'rabbithole', files: [\n            { type: 'txt', filename: 'Inception.txt' }\n          ]}\n        ]}\n      ]\n    }\n  }\n})\n\n\n\n\nIn the example above, subfolders use the \n{{\nfolder}}\n partial, which uses the \n{{\nfile}}\n partial for each file, and if any of those files are folders, the \n{{\nfolder}}\n partial will be invoked again, and so on until there are no more files.\n\n\nBeware of cyclical data structures! Ractive makes no attempt to detect cyclicality, and will happily continue rendering partials until the \nBig Crunch\n (or your browser exceeds its maximum call stack size. Whichever is sooner).\n\n\nInjecting partials\n\n\nOne good use of partials is to vary the shape of a template according to some condition, the same way you might use \ndependency injection\n elsewhere in your code.\n\n\nFor example, you might offer a different view to mobile users:\n\n\ndiv class='main'\n\n  \ndiv class='content'\n\n    {{\ncontent}}\n  \n/div\n\n\n  \ndiv class='sidebar'\n\n    {{\nsidebar}}\n  \n/div\n\n\n/div\n\n\n\n\n\nisMobile = /mobile/i.test( navigator.userAgent ); // please don't do this in real life!\n\nractive = Ractive({\n  el: myContainer,\n  template: myTemplate,\n  partials: {\n    content: isMobile ? mobileContentPartial : desktopContentPartial,\n    sidebar: isMobile ? mobileSidebarPartial : desktopSidebarPartial\n  }\n})\n\n\n\n\nOr you might make it possible to extend a subclass without overriding its template:\n\n\ndiv class='modal-background'\n\n  \ndiv class='modal'\n\n    {{\nmodalContent}}\n  \n/div\n\n\n/div\n\n\n\n\n\n// Create a Modal subclass\nModal = Ractive.extend({\n  template: modalTemplate,\n  init () {\n    var self = this, resizeHandler\n\n    resizeHandler = () =\n {\n      self.center()\n    }\n\n    // when the window resizes, keep the modal horizontally and vertically centred\n    window.addEventListener( 'resize', resizeHandler )\n\n    // clean up after ourselves later\n    this.on( 'teardown', function () {\n      window.removeEventListener( 'resize', resizeHandler )\n    })\n\n    // manually call this.center() the first time\n    this.center()\n  },\n  center () {\n    // centering logic goes here\n  }\n})\n\nhelloModal = Modal({\n  el: document.body,\n  partials: {\n    modalContent: '\np\nHello!\n/p\na class=\nmodal-button\n proxy-tap=\nclose\nClose\n/a\n'\n  }\n})\n\nhelloModal.on( 'close', function () {\n  this.teardown()\n})\n\n\n\n\nPartial expressions\n\n\nExpressions can also be used to reference a partial instead of fixed partial names. Ractive will evaluate the expression and use its return value to select a partial. This is useful when you want the data to indicate what type of partial it should render with.\n\n\nIn the following example, \norganisms\n contains a list of organisms whose \ntype\n can either be \nperson\n or \nanimal\n. Partials for each type is defined and the list uses the \ntype\n of each item to determine which partial to use.\n\n\n{{#partial person}}Hi! I am {{.name}} and I have {{.fingerCount}} fingers!{{/}}\n\n{{#partial animal}}Hi! I am a {{.name}} and I have {{.legCount}} legs!{{/}}\n\n\nul\n\n  {{# organisms }}\n    \nli\n{{\n type }}\n/li\n\n  {{/}}\n\n/ul\n\n\n\n\n\nIn the case where there's a collision between the expression and a partial of the same name, Ractive will not evaluate the expression and instead, will immediately resolve to that partial.\n\n\nIn the following example, a partial named \ntype\n is defined. Instead of evaluating \ntype\n's value, it will resolve to the partial named \ntype\n.\n\n\n{{#partial person}}Hi! I am {{.name}} and I have {{.fingerCount}} fingers!{{/}}\n\n{{#partial animal}}Hi! I am a {{.name}} and I have {{.legCount}} legs!{{/}}\n\n{{#partial type}}Hi! I am {{.name}}{{/}}\n\n\nul\n\n  {{# organisms }}\n    \nli\n{{\n type }}\n/li\n\n  {{/}}\n\n/ul\n\n\n\n\n\nPartials can also be registered on-the-fly as well as have functions determine the partial to use.\n\n\nIn the following example, \nmakePartial\n registers a partial on the fly using \ntemplate\n and \nid\n, and returns the partial name for use in the template.\n\n\nRactive({\n  el: 'main',\n  template: `\n    \nspan\nAdd a partial:\n/span\n\n    \ntextarea value=\n{{tpl}}\n /\n/div\n\n    \nbutton on-click=\n@this.add()\nAdd\n/button\nbr/\n\n\n    {{#list}}\n      {{\n @this.makePartial(.id, .template) }}\n    {{/}}\n  `,\n  data: {\n    list: [],\n    tpl: '',\n\n  },\n  add () {\n    this.push('list', {\n      id: Math.random(),\n      template: this.get('tpl')\n    })\n    this.set('tpl', '')\n  },\n  makePartial (id, template) {\n    const name = 'partial-' + id\n    this.partials[name] = this.partials[name] || template\n    return name\n  }\n})\n\n\n\n\nUpdating Partials\n\n\nPartials may be reset after they are rendered using \nractive.resetPartial()\n. A reset partial will update everywhere it is referenced, so if it is used multiple times or inherited by a component, those instances will be updated as well. If a component has a partial with the same name as a parent partial, partial resets will not affect it since it is a different partial.\n\n\nIt should be noted that partials evaluate lazily, so it is possible to cause a single partial to update by wrapping it in a conditional section and causing the section to be hidden and re-shown.\n\n\n{{^toggle}}{{\nrickroll}}{{/}}\n\n\n\n\nractive.partials.rickroll = 'I wouldn\\'t do that to you, chum.'\nractive.set('toggle', true)\nractive.set('toggle', false)\n\n\n\n\nExamples\n\n\nHere's an example of a gallery using a partial for its thumbnail information:\n\n\n!-- The partial called \nthumbnail\n --\n\n\nfigure class='thumbnail'\n\n  \nimg src='assets/thumbnails/{{id}}.jpg'\n\n  \nfigcaption\n{{description}}\n/figcaption\n\n\n/figure\n\n\n\n!-- The template that uses the partial --\n\n\ndiv class='gallery'\n\n  {{#items}}\n    {{\nthumbnail}}\n  {{/items}}\n\n/div\n\n\n\n\n\nTransitions\n\n\nTransitions allow you to control how enter the DOM and how they leave the DOM. This allows you to define intro and outro behavior, particularly animations, when elements go in and out of the page.\n\n\nWriting\n\n\nconst myTransition = ( t[, ...args]] ) =\n {\n  // Manipulate the DOM.\n  // Call t.complete() when completed.\n}\n\n\n\n\nTransitions are simply functions that get called to animate a specified element.\n\n\nt\n is a transition helper object that aids in the implementation of the transition.\n\n\n[args]\n is the arguments passed in via the transition directive.\n\n\nTransitions are expected to be asynchronous. In order to signal Ractive that the transition has completed, the transition must call the \nt.complete()\n.\n\n\nNote that transitions control the element's arrival and departure to the page. That means upon completion, any styling done to the element will be removed automatically.\n\n\nRegistering\n\n\nLike other plugins, there's 3 ways you can register transitions:\n\n\nGlobally, via the \nRactive.transitions\n static property.\n\n\nRactive.transitions.myTransition = myTransition\n\n\n\n\nPer component, via the component's \ntransitions\n initialization property.\n\n\nconst MyComponent = Ractive.extend({\n  transitions: { myTransition }\n})\n\n\n\n\nPer instance, via the instance's \ntransitions\n initialization property.\n\n\nconst ractive = Ractive({\n  transitions: { myTransition }\n})\n\n\n\n\nUsing\n\n\nTransitions are added to an element via the \n*-in\n, \n*-out\n or \n*-in-out\n directives. The transition may be applied on element render (\n-in\n), on element removal (\n-out\n), or both (\n-in-out\n).\n\n\ndiv myTransition-in\nIntro-only\n/div\n\n\ndiv myTransition-out\nOutro-only\n/div\n\n\ndiv myTransition-in-out\nIntro and outro\n/div\n\n\n\n\n\nArguments are passed to the transition function by supplying comma-separated expressions as values to \n*-in\n, \n*-out\n or \n*-in-out\n. These expressions will become the second argument and onwards of the transition function.\n\n\ndiv myTransition-in-out=\n'Hello, World!', 42\nHello, World!\n/div\n\n\n\n\n\nExamples\n\n\nThe following example demonstrates a \"flash\" transition which colors the element green upon attachment, and red prior to removal.\n\n\nRactive.transitions.flash = (t, params) =\n {\n  // Process params and declaring defaults.\n  const options = t.processParams(params, {\n    color: t.isIntro ? '#0f0' : '#f00',\n    duration: 400\n  })\n\n  // The \ntransition\n\n  t.setStyle('color', options.color)\n\n  // Signal Ractive that the transition is complete.\n  setTimeout(t.complete, options.duration)\n}\n\nRactive({\n  el: 'body',\n  template: `\n    \nbutton on-click='@this.insert()'\nInsert item\n/button\n\n    \nbutton on-click='@this.remove()'\nRemove item\n/button\n\n    \nul\n\n      {{#items}}\n      \nli flash-in-out\n{{this}}\n/li\n\n      {{/items}}\n    \n/ul\n\n  `,\n  data: {\n    items: []\n  },\n  insert () {\n    this.push('items', Date.now())\n  },\n  remove () {\n    this.splice('items', 0, 1)\n  }\n})", 
            "title": "Plugins"
        }, 
        {
            "location": "/plugins/#adaptors", 
            "text": "In some cases you want to write your UI in Ractive but have a custom back-end manage the data. Adaptors allow you to teach Ractive how to talk to those custom data sources without having to change the way you write Ractive or having to write a lot of connector code up front.", 
            "title": "Adaptors"
        }, 
        {
            "location": "/plugins/#writing", 
            "text": "Adaptors translate custom non-POJO (non-Plain Old JS Object) data sources into POJOs and vice-versa. Generally, an adaptor does the following:   Checks if data needs to be adapted, and if so, \"wraps\" an adaptor to it.  Provides a POJO version of your data source for Ractive to use.  Captures data changes on your data source and mirror them to the data in Ractive.  Captures data changes on the data in Ractive and mirror them to the data source.   const myAdaptor = {\n  filter ( value, keypath, ractive ) {\n    // return `true` if a particular object is of the type we want to adapt.\n  },\n  wrap ( ractive, value, keypath, prefixer ) {\n    // Setup\n    return {\n      get () {\n        // Returns POJO version of your data backend.\n      },\n      set (property, value) {\n        // Data setter for POJO property keypaths.\n      },\n      reset (value) {\n        // Data setter for POJO keypath.\n      },\n      teardown () {\n        // Code executed on teardown.\n      }\n    }\n  }\n}  An adaptor definition is an object with two methods:   filter : A function which, if it returns  true , tells Ractive to use the adaptor on the value.  value : The value to check.  keypath : The keypath of  value  relative to the instance root.  ractive : The instance where  value  resides.    wrap : A function that sets up an adaptor.  ractive : The instance where  value  resides.  value : The value to adapt.  keypath : The keypath of  value  relative to the instance root.  prefixer : A function that accepts an object and returns a shallow clone with its keys prepended with  keypath .     The  wrap  function must return an object with four methods:   get : A function that returns the POJO representation of the adapted data.  set : A function that's called when the keypath being updated is a property of the adapted data.  property : The property name to be updated.  value : The new value.    reset : A function that's called when the keypath being updated is the adapted data itself. If  reset  returns  false , Ractive will replace the data on the keypath with the POJO version, and tear down the adaptor.  value : The new value    teardown : A function that's called when an adaptor is being removed.", 
            "title": "Writing"
        }, 
        {
            "location": "/plugins/#adaptors-only-adapt-one-level", 
            "text": "An adaptor only adapts an object's immediate properties. Updating nested data via Ractive or via the data source will not update the other.", 
            "title": "Adaptors only adapt one level"
        }, 
        {
            "location": "/plugins/#no-built-in-infinite-loop-detection", 
            "text": "There is no built-in mechanism for avoiding infinite loops. If your adaptor calls  ractive.set()  on adapted data, which in turn will call the adaptor's  set()  method, which may directly or indirectly trigger another  ractive.set()  on the same adapted data, a stack overflow error might occur.  This isn't a problem with primitive values since Ractive doesn't bother calling  set()  if a value hasn't changed. But with objects and arrays, there's no easy and performant way to tell if the contents have changed. So  set()  gets called  in case something changed  rather than  because something changed .", 
            "title": "No built-in infinite loop detection"
        }, 
        {
            "location": "/plugins/#different-for-every-back-end", 
            "text": "The adaptor structure only provides you with the means to talk to and listen from a custom back-end. It does not impose any rules on how to write an adaptor for a certain back-end. For instance, an adaptor for a constructor-based object may be written differently from an adaptor meant to interact with a socket server.", 
            "title": "Different for every back-end"
        }, 
        {
            "location": "/plugins/#registering", 
            "text": "Like other plugins, there's 3 ways you can register adaptors:", 
            "title": "Registering"
        }, 
        {
            "location": "/plugins/#globally-via-the-ractiveadaptors-static-property", 
            "text": "Ractive.adaptors.myAdaptor = myAdaptor", 
            "title": "Globally, via the Ractive.adaptors static property."
        }, 
        {
            "location": "/plugins/#per-component-via-the-components-adaptors-initialization-property", 
            "text": "const MyComponent = Ractive.extend({\n  adaptors: { myAdaptor }\n})", 
            "title": "Per component, via the component's adaptors initialization property."
        }, 
        {
            "location": "/plugins/#per-instance-via-the-instances-adaptors-initialization-property", 
            "text": "const ractive = Ractive({\n  adaptors: { myAdaptor }\n})", 
            "title": "Per instance, via the instance's adaptors initialization property."
        }, 
        {
            "location": "/plugins/#using", 
            "text": "In order to use an adaptor, you must tell the component or an instance to use it using the  adapt  initialization option.  const ractive = Ractive({\n  adapt: [ 'myAdaptor' ]\n})", 
            "title": "Using"
        }, 
        {
            "location": "/plugins/#examples", 
            "text": "In the following example, we have a  Box  constructor that uses accessors to get and set its  width  and  height  properties. Since an instance of  Box  will have no publicly visible properties, Ractive cannot bind to them directly.  function Box(width, height) {\n  var _width = width\n  var _height = height\n\n  this.getWidth = () =  { return _width; }\n  this.setWidth = (width) =  { _width = width; }\n  this.getHeight = () =  { return _height; }\n  this.setHeight = (height) =  { _height = height }\n}  In order for Ractive to properly use a  Box  instance, we build an adaptor for  Box .  Ractive.adaptors.boxAdaptor = {\n  filter ( object ) {\n    // Checks if the piece of data is an instance of Box.\n    return object instanceof Box\n  },\n  wrap ( ractive, box, keypath, prefixer ) {\n\n    // We keep a reference to the original functions before monkey-patching.\n    const setWidth = box.setWidth\n    const setHeight = box.setHeight\n\n    // Use ractive.set on the the adapted data whenever the setters are used.\n    box.setWidth = (width) =  {\n      ractive.set(prefixer({\n        width: width\n      }))\n    }\n\n    box.setHeight = (height) =  {\n      ractive.set(prefixer({\n        height: height\n      }))\n    }\n\n    return {\n      // Return a POJO representation of an instance of Box.\n      get () {\n        return {\n          width: box.getWidth(),\n          height: box.getHeight()\n        }\n      },\n      // Update the adapted object's properties\n      set (property, value) {\n        if(property === 'width') setWidth.call(box, value)\n        if(property === 'height') setHeight.call(box, value)\n      },\n      // Update the adapted object.\n      reset (data) {\n        // We don't adapt non-objects. And if the new data is an instance of Box\n        // there's a high chance that its a new instance. In either case, we\n        // need to tear down this adapter and have Ractive set it up again if\n        // necessary.\n        if(typeof data !== 'object' || data instanceof Box) return false\n\n        // Otherwise, we just parse through the data and update the existing box\n        // instance.\n        if(data.width !== undefined) setWidth.call(box, data.width)\n        if(data.height !== undefined) setHeight.call(box, data.height)\n      },\n      // Delete the monkey-patched methods.\n      teardown () {\n        delete box.setWidth\n        delete box.setHeight\n      }\n    }\n  }\n}  Then we use  boxAdaptor  on an instance. The data can now be treated like regular Ractive data. Updates done directly on  box  will reflect on Ractive. Any changes via Ractive will reflect on  box .  const ractive = Ractive({\n  el: 'body',\n  // Tell the instance we'll be using boxAdaptor\n  adapt: [ 'boxAdaptor' ],\n  // We write Ractive like normal.\n  template: `\n     div Box is {{ box.width }}x{{ box.height }} /div ,\n     div input type= text  value= {{ box.width }} /div \n     div input type= text  value= {{ box.height }} /div \n  `\n})\n\nconst box = new Box(3, 4)\n\n// Set the Box instance as if it were a POJO.\nractive.set('box', box)\n\n// Both box instance and box object will have 7 width and 11 height and will\n// be rendered in the UI accordingly.\nbox.setWidth(7)\nractive.set('box.height', 11)", 
            "title": "Examples"
        }, 
        {
            "location": "/plugins/#components", 
            "text": "In many situations, you want to encapsulate behaviour and markup into a single reusable  component , which can be dropped into Ractive applications. Components are simply custom-configured \"subclasses\" of Ractive (analogous, but technically incorrect).", 
            "title": "Components"
        }, 
        {
            "location": "/plugins/#writing_1", 
            "text": "There are several ways to write Ractive components. Standard initialization options apply for configuration unless where changes are explicitly mentioned.  The most common way to define a component is by using  Ractive.extend() .  // A subclass of Ractive\nconst MyComponent = Ractive.extend({\n  template: `\n     div class= my-component \n       span class= my-component__message {{ message }} /span \n     /div \n  `,\n  css: `\n    .my-component__message { color: red }\n  `,\n  data: { message: 'Hello World' }\n})  Another way to define a component is by using component files and loaders.  div class= my-component \n   span class= my-component__message {{ message }} /span  /div  style \n  .my-component__message { color: red } /style  script \ncomponent.exports = {\n  data: { message: 'Hello World' }\n} /script", 
            "title": "Writing"
        }, 
        {
            "location": "/plugins/#registering_1", 
            "text": "Like other plugins, there's 3 ways you can register components:", 
            "title": "Registering"
        }, 
        {
            "location": "/plugins/#globally-via-the-ractivecomponents-static-property", 
            "text": "// Available to all instances of Ractive.\nRactive.components.MyComponent = Ractive.extend({ ... })", 
            "title": "Globally, via the Ractive.components static property:"
        }, 
        {
            "location": "/plugins/#per-component-via-the-components-components-initialization-property", 
            "text": "// Only available for instances of AnotherComponent.\nconst AnotherComponent = Ractive.extend({\n  components: { MyComponent }\n})", 
            "title": "Per component, via the component's components initialization property."
        }, 
        {
            "location": "/plugins/#per-instance-via-the-instances-components-initialization-property", 
            "text": "// Only available to this specific instance.\nconst ractive = Ractive({\n  components: { MyComponent }\n})", 
            "title": "Per instance, via the instance's components initialization property."
        }, 
        {
            "location": "/plugins/#using_1", 
            "text": "Components are simply subclasses of Ractive, which means they are also instatiable.  const ractive = MyComponent({ ... })  But where components really shine is when they're used on templates. They are written like  custom elements . Each custom element notation represents one instance of the component.  const AnotherComponent = Ractive.extend({\n  template: `\n     div \n       MyComponent /   !-- One instance of MyComponent -- \n       MyComponent /   !-- Another instance of MyComponent -- \n       MyComponent /   !-- Yet another instance of MyComponent -- \n     /div \n  `\n})  The component's tag name depends on the name used upon registration. The same component can be registered more than once using different names.  const MyComponent = Ractive.extend({...})\nRactive.components.MyComponent = MyComponent\nRactive.components.MyComponentOtherName = MyComponent\n\nconst AnotherComponent = Ractive.extend({\n  template: `\n     div \n       MyComponent /            !-- Using MyComponent -- \n       MyComponentOtherName /   !-- Using MyComponent's other name -- \n     /div \n  `\n})", 
            "title": "Using"
        }, 
        {
            "location": "/plugins/#examples_1", 
            "text": "", 
            "title": "Examples"
        }, 
        {
            "location": "/plugins/#decorators", 
            "text": "A decorator is a simple way to add behaviour to a node when it is rendered, or to augment it in some way. Decorators are a good way to integrate DOM manipulation libraries with Ractive, such as  jQuery UI  or  Bootstrap .", 
            "title": "Decorators"
        }, 
        {
            "location": "/plugins/#writing_2", 
            "text": "const myDecorator = (node[, ...args]) =  {\n  // Setup code\n  return {\n    teardown () {\n      // Cleanup code\n    },\n    update ([...args]) {\n      // Update code\n    },\n    invalidate () {\n      // Code called on invalidate\n    }\n  }\n}  Decorators are simply functions that are called upon to setup the decorator once Ractive detects its use. It takes a  node  argument and returns an object with a  teardown  and  update  property.  node  is the element to which the decorator is applied to.  [args]  are optional arguments provided by the decorator directive.  teardown  is a function that gets called when the decorator is torn down.  update  is an optional function that gets called when the arguments update.  invalidate , starting with 0.9.3, is an optional function that gets called when any bit of template downstream from the node is being updated.  Any updates to the arguments will call the decorator's  teardown  and run the decorator function again, essentially setting up the decorator again. If an  update  function is provided on the return object, that will be called instead of the  teardown  and setup function.", 
            "title": "Writing"
        }, 
        {
            "location": "/plugins/#registering_2", 
            "text": "Like other plugins, there's 3 ways you can register decorators:", 
            "title": "Registering"
        }, 
        {
            "location": "/plugins/#globally-via-the-ractivedecorators-static-property", 
            "text": "Ractive.decorators.myDecorator = myDecorator", 
            "title": "Globally, via the Ractive.decorators static property."
        }, 
        {
            "location": "/plugins/#per-component-via-the-components-decorators-initialization-property", 
            "text": "const MyComponent = Ractive.extend({\n  decorators: { myDecorator }\n})", 
            "title": "Per component, via the component's decorators initialization property."
        }, 
        {
            "location": "/plugins/#per-instance-via-the-instances-decorators-initialization-property", 
            "text": "const ractive = Ractive({\n  decorators: { myDecorator }\n})", 
            "title": "Per instance, via the instance's decorators initialization property."
        }, 
        {
            "location": "/plugins/#using_2", 
            "text": "One or more decorators can be added to an element via the  as-*  directive. Arguments are passed to the decorator function by supplying comma-separated expressions as values. These expressions will become the second argument and onwards of the transition function.  !-- without arguments --  div as-myDecorator ... /div  !-- with arguments --  div as-myDecorator= arg1, .some.other.arg2, 10 * @index  as-somethingElseToo ... /div", 
            "title": "Using"
        }, 
        {
            "location": "/plugins/#examples_2", 
            "text": "The following example builds a decorator that updates the time.  Ractive.decorators.timer = (node, time) =  {\n  node.innerHTML = 'Hello World!'\n\n  return {\n    teardown () {\n      node.innerHTML = ''\n    },\n    update (time) {\n      node.innerHTML = time\n    }\n  }\n}\n\nconst ractive = Ractive({\n  el: 'body',\n  template: `\n     span as-timer= time /span \n  `,\n  data: {\n    time: 0\n  }\n})\n\nsetInterval(function () {\n  ractive.set('time', Date.now())\n}, 1000)", 
            "title": "Examples"
        }, 
        {
            "location": "/plugins/#easings", 
            "text": "Easing functions describe the animation's progression from start to finish. Easings are used by  ractive.animate  and some transitions. Out of the box, Ractive comes with  linear ,  easeIn ,  easeOut  and  easeInOut .", 
            "title": "Easings"
        }, 
        {
            "location": "/plugins/#writing_3", 
            "text": "const myEasing = ( t ) =  {\n  // Calculation\n  return v\n}  Easing functions receive  t , a value from  0  to  1 , which represents the linear progression of the animation from start to finish. The easing function must then return  v , a value also from  0  to  1 , which represents the progress of the animation for that easing.", 
            "title": "Writing"
        }, 
        {
            "location": "/plugins/#registering_3", 
            "text": "Like other plugins, there's 3 ways you can register an easing function:", 
            "title": "Registering"
        }, 
        {
            "location": "/plugins/#globally-via-the-ractiveeasing-static-property", 
            "text": "Ractive.easing.myEasing = myEasing", 
            "title": "Globally via the Ractive.easing static property."
        }, 
        {
            "location": "/plugins/#per-component-via-the-components-easing-initialization-property", 
            "text": "const MyComponent = Ractive.extend({\n  easing: { myEasing }\n})", 
            "title": "Per component via the component's easing initialization property."
        }, 
        {
            "location": "/plugins/#per-instance-via-the-instances-easing-initialization-property", 
            "text": "const ractive = Ractive({\n  easing: { myEasing }\n})", 
            "title": "Per instance, via the instance's easing initialization property."
        }, 
        {
            "location": "/plugins/#using_3", 
            "text": "Easing functions are utilized by  ractive.animate()  and transitions to define animations.  \nractive.animate('counter', 60, {\n  easing: 'myEasing'\n})", 
            "title": "Using"
        }, 
        {
            "location": "/plugins/#examples_3", 
            "text": "Here's an  elastic  easing function taken from  danro 's excellent  easing.js  library.  Ractive.easing.elastic = ( t ) =  {\n  return -1 * Math.pow(4,-8*t) * Math.sin((t*6-1)*(2*Math.PI)/2) + 1\n}", 
            "title": "Examples"
        }, 
        {
            "location": "/plugins/#events", 
            "text": "Events allow custom-named events on DOM elements. Common use cases for custom DOM events include normalizing cross-browser events, normalizing cross-device events, implementing custom events, and so much more.", 
            "title": "Events"
        }, 
        {
            "location": "/plugins/#writing_4", 
            "text": "const myEvent = (node, fire) =  {\n  // Setup code\n  return {\n    teardown () {\n      // Cleanup code\n    }\n  }\n}  Events are simply functions that are called to set up the event on a DOM element. The event function accepts two arguments:  node  and  fire , and returns an object containing a  teardown  property.  node  is the element to which the event is being applied.  fire  is the function that must be called when the event has taken place.  fire  takes a single argument, the event object received by handlers. The minimum requirement for the event object is a  node  property that references DOM node the event is attached to, and an  original  property which references the native DOM  event  object supplied by the native handler, if available.  The event object will be augmented with  context ,  keypath  and  index  properties, whose values depend on the data context the node is in.  context  references the data context that surrounds the node,  keypath  is a string that leads to the current data context and  index  is a number that references the index number of the data, should the data context be in an array.  teardown  is a function that gets called once the element is torn down. This allows the event to clean up after itself.", 
            "title": "Writing"
        }, 
        {
            "location": "/plugins/#registering_4", 
            "text": "Like other plugins, there's 3 ways you can register events:", 
            "title": "Registering"
        }, 
        {
            "location": "/plugins/#globally-via-the-ractiveevents-static-property", 
            "text": "Ractive.events.myEvent = myEvent", 
            "title": "Globally, via the Ractive.events static property."
        }, 
        {
            "location": "/plugins/#per-component-via-the-components-events-initialization-property", 
            "text": "const MyComponent = Ractive.extend({\n  events: { myEvent }\n})", 
            "title": "Per component, via the component's events initialization property."
        }, 
        {
            "location": "/plugins/#per-instance-via-the-instances-events-initialization-property", 
            "text": "const ractive = Ractive({\n  events: { myEvent }\n})", 
            "title": "Per instance, via the instance's events initialization property."
        }, 
        {
            "location": "/plugins/#using_4", 
            "text": "Events use the same  on-*  attribute syntax as component and DOM events. When Ractive encounters an  on-*  attribute on a DOM element, it looks for a registered event and applies it on the element. If no matching event name was found, Ractive will think the event name is a native DOM event and will attach one accordingly.  // This will apply the  myEvent  custom event if one is registered.\n// Otherwise, Ractive will think it's a DOM event. You have been warned! span on-myEvent= foo() Click me! /span", 
            "title": "Using"
        }, 
        {
            "location": "/plugins/#examples_4", 
            "text": "Here's an example of a \"long press\" event which fires when the mouse is clicked and held for 1 second.  // Definition\nRactive.events.longpress = (node, fire) =  {\n  let timer = null\n\n  function clearTimer () {\n    if(timer) clearTimeout(timer)\n    timer = null\n  }\n\n  function mouseDownHandler(event) {\n    clearTimer()\n\n    timer = setTimeout(() =  {\n      fire({\n        node: node,\n        original: event\n      })\n    }, 1000)\n  }\n\n  function mouseUpHandler () {\n    clearTimer()\n  }\n\n  node.addEventListener('mousedown', mouseDownHandler)\n  node.addEventListener('mouseup', mouseUpHandler)\n\n  return {\n    teardown () {\n      node.removeEventListener('mousedown', mouseDownHandler)\n      node.removeEventListener('mouseup', mouseUpHandler)\n    }\n  }\n}\n\n// Usage:\nRactive({\n  el: 'body',\n  template: `\n     button type= button  on-longpress= @this.greetz() Click Me! /button \n  `,\n  greetz () {\n    console.log('Hello World!')\n  }\n})", 
            "title": "Examples"
        }, 
        {
            "location": "/plugins/#interpolators", 
            "text": "Interpolator functions describe a value's progression during an animation from start to finish. Interpolator functions also determine the value on the model as well as what gets rendered during the animation.", 
            "title": "Interpolators"
        }, 
        {
            "location": "/plugins/#writing_5", 
            "text": "const myInterpolator = (from, to) =  {\n\n  return t =  {\n    return valueAtTimeT\n  }\n}  Interpolator plugins accept  from  and  to .  from  is the value on the animated keypath before calling  ractive.animate()  and  to  is the value being set by  ractive.animate() . The plugin must return a function that receives  t  and returns a value that represents the animated value at  t .  t  is a value from  0  to  1  representing the animation's progress with easing already applied.", 
            "title": "Writing"
        }, 
        {
            "location": "/plugins/#registering_5", 
            "text": "Like other plugins, there's 3 ways you can register an interpolator function:", 
            "title": "Registering"
        }, 
        {
            "location": "/plugins/#globally-via-the-ractiveinterpolators-static-property", 
            "text": "Ractive.interpolators.myInterpolator = myInterpolator", 
            "title": "Globally via the Ractive.interpolators static property."
        }, 
        {
            "location": "/plugins/#per-component-via-the-components-interpolators-initialization-property", 
            "text": "const MyComponent = Ractive.extend({\n  interpolators: { myInterpolator }\n})", 
            "title": "Per component via the component's interpolators initialization property."
        }, 
        {
            "location": "/plugins/#per-instance-via-the-instances-interpolators-initialization-property", 
            "text": "const ractive = Ractive({\n  interpolators: { myInterpolator }\n})", 
            "title": "Per instance, via the instance's interpolators initialization property."
        }, 
        {
            "location": "/plugins/#using_5", 
            "text": "Interpolator functions are utilized by  ractive.animate()  by supplying the interpolator name to the  interpolator  option.  ractive.animate('counter', 60, {\n  interpolator: 'myInterpolator'\n})", 
            "title": "Using"
        }, 
        {
            "location": "/plugins/#examples_5", 
            "text": "Here's an abridged version of Ractive's built-in  number  interpolator which interpolates numeric values (numbers and number-like strings) during animation.  Ractive.interpolators.number = (from, to) =  {\n  const start = Number(from)\n  const end = Number(to)\n\n  if (Number.isNaN(start) || Number.isNaN(end)) return null\n\n  const delta = end - start\n  const noChangeInterpolator = () =  start\n  const changeInterpolator = t =  start + (t * delta)\n  return delta ? changeInterpolator : noChangeInterpolator\n}", 
            "title": "Examples"
        }, 
        {
            "location": "/plugins/#partials", 
            "text": "A partial is a template snippet which can be reused in templates or in other partials. They help to keep templates uncluttered, non-repetetive and easy to read.", 
            "title": "Partials"
        }, 
        {
            "location": "/plugins/#writing_6", 
            "text": "const myPartial = ' !-- template -- '  Partials are simply Ractive templates.", 
            "title": "Writing"
        }, 
        {
            "location": "/plugins/#registering_6", 
            "text": "Unlike other plugins, partials have more than 3 registration options.", 
            "title": "Registering"
        }, 
        {
            "location": "/plugins/#globally-via-the-ractivepartials-static-property", 
            "text": "Ractive.partials.myPartial = MyPartial", 
            "title": "Globally via the Ractive.partials static property."
        }, 
        {
            "location": "/plugins/#globally-via-a-non-executing-script-tag-on-the-current-page", 
            "text": "script type= ractive/template  id= myPartial \n  ... /script", 
            "title": "Globally, via a non-executing script tag on the current page."
        }, 
        {
            "location": "/plugins/#per-component-via-the-components-partials-initialization-property", 
            "text": "const MyComponent = Ractive.extend({\n  partials: { myPartial }\n})", 
            "title": "Per component, via the component's partials initialization property."
        }, 
        {
            "location": "/plugins/#per-instance-via-the-instances-partials-initialization-property", 
            "text": "const ractive = Ractive({\n  partials: { myPartial }\n})", 
            "title": "Per instance, via the instance's partials initialization property."
        }, 
        {
            "location": "/plugins/#in-template-using-the-partial-mustache", 
            "text": "{{#partial myPartial}}\n  ...\n{{/}}", 
            "title": "In-template, using the {{#partial}} mustache."
        }, 
        {
            "location": "/plugins/#using_6", 
            "text": "Partials can be used using  {{ partialName}} . Partials work where any template would work and takes on its surrounding context.  {{#partial myPartial}}\n   div class= message {{message}} /div \n{{/partial}} div class= app \n  {{ myPartial}} /div", 
            "title": "Using"
        }, 
        {
            "location": "/plugins/#valid-names", 
            "text": "Partials may be named with the same rules as any other identifier in Ractive or JavaScript, but since there isn't much danger of trying to do math in a partial name, they enjoy relaxed naming requirements that allow otherwise reserved globals and keywords to be used for partial names.  Partial names may also contain  -  and  /  characters as long as they are surrounded by other valid characters e.g.  templates/some-partial-template .", 
            "title": "Valid names"
        }, 
        {
            "location": "/plugins/#context", 
            "text": "Partials be given an explicit context. Simply supply a reference to the context following the partial name on usage.  Ractive({\n  data: {\n    foo:{\n      bar: 'Hello, World!'\n    }\n  },\n  template: `\n    {{#partial myPartial}}{{bar}}{{/partial}}\n\n    {{ myPartial foo}}\n  `\n})", 
            "title": "Context"
        }, 
        {
            "location": "/plugins/#aliases", 
            "text": "References can also be aliased in partials. Simply define aliases as comma-separated  reference as alias  pairs following the partial name on usage.  Ractive({\n  data: {\n    status: 'Me, Hungry!',\n    foo:{\n      bar: 'Hello, World!'\n    }\n  },\n  template: `\n    {{#partial myPartial}}{{msg}} {{state}}{{/partial}}\n\n    {{ myPartial foo.bar as msg, status as state}}\n  `\n})", 
            "title": "Aliases"
        }, 
        {
            "location": "/plugins/#recursive-partials", 
            "text": "Partials can be used recursively. A common use case for this is when reusing partials on a tree-like structure, like a directory listing.  div class='fileSystem' \n  {{#root}}\n    {{ folder}}\n  {{/root}} /div \n\n{{#partial folder}} ul class='folder' \n  {{#files}}\n    {{ file}}\n  {{/files}} /ul \n{{/partial}}\n\n{{#partial file}} li class='file' \n   img class='icon-{{type}}' \n   span {{filename}} /span \n\n   !-- if this is actually a folder, embed the folder partial -- \n  {{# type === 'folder' }}\n    {{ folder}}\n  {{/ type === 'folder' }} /li \n{{/partial}}  rv = Ractive({\n  el: 'container',\n  template: '#myTemplate',\n  data: {\n    root: {\n      files: [\n        { type: 'jpg', filename: 'hello.jpg' },\n        { type: 'mp3', filename: 'NeverGonna.mp3' },\n        { type: 'folder', filename: 'subfolder', files: [\n          { type: 'txt', filename: 'README.txt' },\n          { type: 'folder', filename: 'rabbithole', files: [\n            { type: 'txt', filename: 'Inception.txt' }\n          ]}\n        ]}\n      ]\n    }\n  }\n})  In the example above, subfolders use the  {{ folder}}  partial, which uses the  {{ file}}  partial for each file, and if any of those files are folders, the  {{ folder}}  partial will be invoked again, and so on until there are no more files.  Beware of cyclical data structures! Ractive makes no attempt to detect cyclicality, and will happily continue rendering partials until the  Big Crunch  (or your browser exceeds its maximum call stack size. Whichever is sooner).", 
            "title": "Recursive partials"
        }, 
        {
            "location": "/plugins/#injecting-partials", 
            "text": "One good use of partials is to vary the shape of a template according to some condition, the same way you might use  dependency injection  elsewhere in your code.  For example, you might offer a different view to mobile users:  div class='main' \n   div class='content' \n    {{ content}}\n   /div \n\n   div class='sidebar' \n    {{ sidebar}}\n   /div  /div   isMobile = /mobile/i.test( navigator.userAgent ); // please don't do this in real life!\n\nractive = Ractive({\n  el: myContainer,\n  template: myTemplate,\n  partials: {\n    content: isMobile ? mobileContentPartial : desktopContentPartial,\n    sidebar: isMobile ? mobileSidebarPartial : desktopSidebarPartial\n  }\n})  Or you might make it possible to extend a subclass without overriding its template:  div class='modal-background' \n   div class='modal' \n    {{ modalContent}}\n   /div  /div   // Create a Modal subclass\nModal = Ractive.extend({\n  template: modalTemplate,\n  init () {\n    var self = this, resizeHandler\n\n    resizeHandler = () =  {\n      self.center()\n    }\n\n    // when the window resizes, keep the modal horizontally and vertically centred\n    window.addEventListener( 'resize', resizeHandler )\n\n    // clean up after ourselves later\n    this.on( 'teardown', function () {\n      window.removeEventListener( 'resize', resizeHandler )\n    })\n\n    // manually call this.center() the first time\n    this.center()\n  },\n  center () {\n    // centering logic goes here\n  }\n})\n\nhelloModal = Modal({\n  el: document.body,\n  partials: {\n    modalContent: ' p Hello! /p a class= modal-button  proxy-tap= close Close /a '\n  }\n})\n\nhelloModal.on( 'close', function () {\n  this.teardown()\n})", 
            "title": "Injecting partials"
        }, 
        {
            "location": "/plugins/#partial-expressions", 
            "text": "Expressions can also be used to reference a partial instead of fixed partial names. Ractive will evaluate the expression and use its return value to select a partial. This is useful when you want the data to indicate what type of partial it should render with.  In the following example,  organisms  contains a list of organisms whose  type  can either be  person  or  animal . Partials for each type is defined and the list uses the  type  of each item to determine which partial to use.  {{#partial person}}Hi! I am {{.name}} and I have {{.fingerCount}} fingers!{{/}}\n\n{{#partial animal}}Hi! I am a {{.name}} and I have {{.legCount}} legs!{{/}} ul \n  {{# organisms }}\n     li {{  type }} /li \n  {{/}} /ul   In the case where there's a collision between the expression and a partial of the same name, Ractive will not evaluate the expression and instead, will immediately resolve to that partial.  In the following example, a partial named  type  is defined. Instead of evaluating  type 's value, it will resolve to the partial named  type .  {{#partial person}}Hi! I am {{.name}} and I have {{.fingerCount}} fingers!{{/}}\n\n{{#partial animal}}Hi! I am a {{.name}} and I have {{.legCount}} legs!{{/}}\n\n{{#partial type}}Hi! I am {{.name}}{{/}} ul \n  {{# organisms }}\n     li {{  type }} /li \n  {{/}} /ul   Partials can also be registered on-the-fly as well as have functions determine the partial to use.  In the following example,  makePartial  registers a partial on the fly using  template  and  id , and returns the partial name for use in the template.  Ractive({\n  el: 'main',\n  template: `\n     span Add a partial: /span \n     textarea value= {{tpl}}  / /div \n     button on-click= @this.add() Add /button br/ \n\n    {{#list}}\n      {{  @this.makePartial(.id, .template) }}\n    {{/}}\n  `,\n  data: {\n    list: [],\n    tpl: '',\n\n  },\n  add () {\n    this.push('list', {\n      id: Math.random(),\n      template: this.get('tpl')\n    })\n    this.set('tpl', '')\n  },\n  makePartial (id, template) {\n    const name = 'partial-' + id\n    this.partials[name] = this.partials[name] || template\n    return name\n  }\n})", 
            "title": "Partial expressions"
        }, 
        {
            "location": "/plugins/#updating-partials", 
            "text": "Partials may be reset after they are rendered using  ractive.resetPartial() . A reset partial will update everywhere it is referenced, so if it is used multiple times or inherited by a component, those instances will be updated as well. If a component has a partial with the same name as a parent partial, partial resets will not affect it since it is a different partial.  It should be noted that partials evaluate lazily, so it is possible to cause a single partial to update by wrapping it in a conditional section and causing the section to be hidden and re-shown.  {{^toggle}}{{ rickroll}}{{/}}  ractive.partials.rickroll = 'I wouldn\\'t do that to you, chum.'\nractive.set('toggle', true)\nractive.set('toggle', false)", 
            "title": "Updating Partials"
        }, 
        {
            "location": "/plugins/#examples_6", 
            "text": "Here's an example of a gallery using a partial for its thumbnail information:  !-- The partial called  thumbnail  --  figure class='thumbnail' \n   img src='assets/thumbnails/{{id}}.jpg' \n   figcaption {{description}} /figcaption  /figure  !-- The template that uses the partial --  div class='gallery' \n  {{#items}}\n    {{ thumbnail}}\n  {{/items}} /div", 
            "title": "Examples"
        }, 
        {
            "location": "/plugins/#transitions", 
            "text": "Transitions allow you to control how enter the DOM and how they leave the DOM. This allows you to define intro and outro behavior, particularly animations, when elements go in and out of the page.", 
            "title": "Transitions"
        }, 
        {
            "location": "/plugins/#writing_7", 
            "text": "const myTransition = ( t[, ...args]] ) =  {\n  // Manipulate the DOM.\n  // Call t.complete() when completed.\n}  Transitions are simply functions that get called to animate a specified element.  t  is a transition helper object that aids in the implementation of the transition.  [args]  is the arguments passed in via the transition directive.  Transitions are expected to be asynchronous. In order to signal Ractive that the transition has completed, the transition must call the  t.complete() .  Note that transitions control the element's arrival and departure to the page. That means upon completion, any styling done to the element will be removed automatically.", 
            "title": "Writing"
        }, 
        {
            "location": "/plugins/#registering_7", 
            "text": "Like other plugins, there's 3 ways you can register transitions:", 
            "title": "Registering"
        }, 
        {
            "location": "/plugins/#globally-via-the-ractivetransitions-static-property", 
            "text": "Ractive.transitions.myTransition = myTransition", 
            "title": "Globally, via the Ractive.transitions static property."
        }, 
        {
            "location": "/plugins/#per-component-via-the-components-transitions-initialization-property", 
            "text": "const MyComponent = Ractive.extend({\n  transitions: { myTransition }\n})", 
            "title": "Per component, via the component's transitions initialization property."
        }, 
        {
            "location": "/plugins/#per-instance-via-the-instances-transitions-initialization-property", 
            "text": "const ractive = Ractive({\n  transitions: { myTransition }\n})", 
            "title": "Per instance, via the instance's transitions initialization property."
        }, 
        {
            "location": "/plugins/#using_7", 
            "text": "Transitions are added to an element via the  *-in ,  *-out  or  *-in-out  directives. The transition may be applied on element render ( -in ), on element removal ( -out ), or both ( -in-out ).  div myTransition-in Intro-only /div  div myTransition-out Outro-only /div  div myTransition-in-out Intro and outro /div   Arguments are passed to the transition function by supplying comma-separated expressions as values to  *-in ,  *-out  or  *-in-out . These expressions will become the second argument and onwards of the transition function.  div myTransition-in-out= 'Hello, World!', 42 Hello, World! /div", 
            "title": "Using"
        }, 
        {
            "location": "/plugins/#examples_7", 
            "text": "The following example demonstrates a \"flash\" transition which colors the element green upon attachment, and red prior to removal.  Ractive.transitions.flash = (t, params) =  {\n  // Process params and declaring defaults.\n  const options = t.processParams(params, {\n    color: t.isIntro ? '#0f0' : '#f00',\n    duration: 400\n  })\n\n  // The  transition \n  t.setStyle('color', options.color)\n\n  // Signal Ractive that the transition is complete.\n  setTimeout(t.complete, options.duration)\n}\n\nRactive({\n  el: 'body',\n  template: `\n     button on-click='@this.insert()' Insert item /button \n     button on-click='@this.remove()' Remove item /button \n     ul \n      {{#items}}\n       li flash-in-out {{this}} /li \n      {{/items}}\n     /ul \n  `,\n  data: {\n    items: []\n  },\n  insert () {\n    this.push('items', Date.now())\n  },\n  remove () {\n    this.splice('items', 0, 1)\n  }\n})", 
            "title": "Examples"
        }, 
        {
            "location": "/resources/", 
            "text": "Learning material\n\n\nTutorials\n\n\n\n\nHello, world!\n\n\nNested Properties\n\n\nExpressions\n\n\nEvents\n\n\nConditional Sections\n\n\nIterative Sections\n\n\nTwo-way Binding\n\n\nPartials\n\n\nTriples (Embedded HTML)\n\n\nComponents\n\n\nAnimations\n\n\nSVG\n\n\nTransitions\n\n\nDecorators\n\n\n\n\nExamples\n\n\n\n\ndagnelies/ractive-examples\n\n\n\n\nPlugins\n\n\nAdaptors\n\n\nInterface with different backends.\n\n\n\n\nBackbone\n\n\nBacon.js\n\n\nModella\n by \n@staygrimm\n\n\nPromises\n by \n@lluchs\n\n\nPromise-alt\n by \n@rstacruz\n\n\nRxJS\n\n\nRactive\n by \n@rstacruz\n - Synchronise several Ractive instances.\n\n\nss-ractive\n by Robert Hall \n@arxpoetica\n - Ractive Template Engine wrapper for \nSocketStream\n.\n\n\n\n\nComponents\n\n\nEncapsulate functionality behind the guise of a custom element.\n\n\n\n\nACE Editor\n\n\nRactive-Require\n\n\nCodeMirror\n\n\nBootstrap\n\n\nDatatable\n\n\nSelect\n - A \nselect\n replacement component.\n\n\nStepper\n - A numeric stepper component.\n\n\nSplit\n\n\nractive-modal\n - A modal popup component.\n\n\nractive-materialish\n - A collection of components and plugins for making desktop- and mobile-friendly frontend applications.\n\n\n\n\nDecorators\n\n\nAugment the DOM with more functionality.\n\n\n\n\nChosen\n by \n@rahulcs\n (\n@kalcifer\n)\n\n\nminmaxwidth\n by \n@cfenzo\n\n\nSelect2\n by \n@sandermarechal\n (\n@Prezent\n)\n\n\nSortable\n\n\nTooltip\n\n\n\n\nEasings\n\n\nCustom animation progressions.\n\n\nEvents\n\n\nAugment the DOM with custom events beyond those supported by the browser.\n\n\n\n\nDrag and Drop (HTML5)\n by \n@Nijikokun\n\n\nDrag and Drop (non-HTML5)\n by \n@smallhadroncollider\n\n\nDrag and Drop Sortable List\n by \n@Nijikokun\n\n\nResize\n by \n@smallhadroncollider\n\n\nHover\n\n\nKeys\n\n\nMousewheel\n\n\nTap\n\n\nTouch\n by \n@rstacruz\n\n\nTyping\n by \n@svapreddy\n\n\nViewport\n by \n@svapreddy\n\n\n\n\nPartials\n\n\nReusable pieces of markup.\n\n\nTransitions\n\n\nApply custom animation.\n\n\n\n\nFade\n\n\nFly\n\n\nScale\n by \n@1N50MN14\n\n\nSlide\n\n\nTypewriter\n\n\n\n\nLibraries\n\n\njQuery\n\n\nSergio Castillo\n has made a jQuery mobile plugin, which you can \nsee in action on this JSFiddle\n.\n\n\nLoaders\n\n\nBy itself, neither Ractive nor tools know what to do with a component files. Loaders take in component files and parse them into a representation that other tools understand.\n\n\nVanilla\n\n\n\n\nractive-load\n - Uses \nXHR\n to load your component files and creates component constructors at runtime.\n\n\n\n\nRollup\n\n\n\n\nrollup-plugin-ractive-bin\n - Compile Ractive.js components using rollup.js and the Ractive bin\n\n\n\n\nSystemJS\n\n\n\n\nractem\n - A plugin for SystemJS for loading Ractive components\n\n\n\n\nRequireJS\n\n\n\n\nrvc\n - Converts component files into \nAMD modules\n.\n\n\nrv\n - Loads and pre-compiles Ractive templates from external files. A sample \nRactive + RequireJS sample application\n is also available using rv.\n\n\n\n\nBrowserify\n\n\n\n\nractify\n - Converts component files into \nCJS modules\n.\n\n\nractiveify\n - Similar to ractify, but supports JS/CSS compilation.\n\n\nractive-componentify\n - Similar to ractiveify, but supports \nsource maps\n and partial imports.\n\n\nRactivate\n, a transform that will pre-parse templates. Contributed by \njrajav\n. \n(GitHub repository)\n. A \nstarter project\n is available with a \ngulp.js\n build system.\n\n\n\n\nBroccoli\n\n\n\n\nbroccoli-ractive\n - Converts your component files into either AMD, CJS, or ES modules.\n\n\n\n\nWebpack\n\n\n\n\nractive-component-loader\n - Allows you to load component files as constructors via Webpack.\n\n\nractive-bin-loader\n - Write Ractive.js components and have them available pre-compiled for the rest of your webpack build.\n\n\n\n\nGrunt\n\n\n\n\ngrunt-ractive\n - Compiles Ractive component files into AMD, CJS or ES modules.\n\n\n\n\nBabel\n\n\nTODO\n\n\nTools\n\n\nRactive CLI\n\n\nAs of version 0.9, Ractive now comes with a CLI tool that comes with a few handy commands. See \nractive help\n for more details on available commands.\n\n\nRactive utilities\n\n\nRactive provides a couple of modules to aid you in loader development:\n\n\n\n\nrcu\n - An importable/embeddable library that provides utility APIs to help your loader parse the different portions of the component file.\n\n\nrcu-builders\n - A module that provides utility APIs to help your loader convert parsed component files into other module formats like ES, AMD and CJS.\n\n\n\n\nYeoman\n\n\nJorge Colindres\n has created \ngenerator-ractive\n, a Yeoman generator to quickly set up a Ractive application.", 
            "title": "Resources"
        }, 
        {
            "location": "/resources/#learning-material", 
            "text": "", 
            "title": "Learning material"
        }, 
        {
            "location": "/resources/#tutorials", 
            "text": "Hello, world!  Nested Properties  Expressions  Events  Conditional Sections  Iterative Sections  Two-way Binding  Partials  Triples (Embedded HTML)  Components  Animations  SVG  Transitions  Decorators", 
            "title": "Tutorials"
        }, 
        {
            "location": "/resources/#examples", 
            "text": "dagnelies/ractive-examples", 
            "title": "Examples"
        }, 
        {
            "location": "/resources/#plugins", 
            "text": "", 
            "title": "Plugins"
        }, 
        {
            "location": "/resources/#adaptors", 
            "text": "Interface with different backends.   Backbone  Bacon.js  Modella  by  @staygrimm  Promises  by  @lluchs  Promise-alt  by  @rstacruz  RxJS  Ractive  by  @rstacruz  - Synchronise several Ractive instances.  ss-ractive  by Robert Hall  @arxpoetica  - Ractive Template Engine wrapper for  SocketStream .", 
            "title": "Adaptors"
        }, 
        {
            "location": "/resources/#components", 
            "text": "Encapsulate functionality behind the guise of a custom element.   ACE Editor  Ractive-Require  CodeMirror  Bootstrap  Datatable  Select  - A  select  replacement component.  Stepper  - A numeric stepper component.  Split  ractive-modal  - A modal popup component.  ractive-materialish  - A collection of components and plugins for making desktop- and mobile-friendly frontend applications.", 
            "title": "Components"
        }, 
        {
            "location": "/resources/#decorators", 
            "text": "Augment the DOM with more functionality.   Chosen  by  @rahulcs  ( @kalcifer )  minmaxwidth  by  @cfenzo  Select2  by  @sandermarechal  ( @Prezent )  Sortable  Tooltip", 
            "title": "Decorators"
        }, 
        {
            "location": "/resources/#easings", 
            "text": "Custom animation progressions.", 
            "title": "Easings"
        }, 
        {
            "location": "/resources/#events", 
            "text": "Augment the DOM with custom events beyond those supported by the browser.   Drag and Drop (HTML5)  by  @Nijikokun  Drag and Drop (non-HTML5)  by  @smallhadroncollider  Drag and Drop Sortable List  by  @Nijikokun  Resize  by  @smallhadroncollider  Hover  Keys  Mousewheel  Tap  Touch  by  @rstacruz  Typing  by  @svapreddy  Viewport  by  @svapreddy", 
            "title": "Events"
        }, 
        {
            "location": "/resources/#partials", 
            "text": "Reusable pieces of markup.", 
            "title": "Partials"
        }, 
        {
            "location": "/resources/#transitions", 
            "text": "Apply custom animation.   Fade  Fly  Scale  by  @1N50MN14  Slide  Typewriter", 
            "title": "Transitions"
        }, 
        {
            "location": "/resources/#libraries", 
            "text": "", 
            "title": "Libraries"
        }, 
        {
            "location": "/resources/#jquery", 
            "text": "Sergio Castillo  has made a jQuery mobile plugin, which you can  see in action on this JSFiddle .", 
            "title": "jQuery"
        }, 
        {
            "location": "/resources/#loaders", 
            "text": "By itself, neither Ractive nor tools know what to do with a component files. Loaders take in component files and parse them into a representation that other tools understand.", 
            "title": "Loaders"
        }, 
        {
            "location": "/resources/#vanilla", 
            "text": "ractive-load  - Uses  XHR  to load your component files and creates component constructors at runtime.", 
            "title": "Vanilla"
        }, 
        {
            "location": "/resources/#rollup", 
            "text": "rollup-plugin-ractive-bin  - Compile Ractive.js components using rollup.js and the Ractive bin", 
            "title": "Rollup"
        }, 
        {
            "location": "/resources/#systemjs", 
            "text": "ractem  - A plugin for SystemJS for loading Ractive components", 
            "title": "SystemJS"
        }, 
        {
            "location": "/resources/#requirejs", 
            "text": "rvc  - Converts component files into  AMD modules .  rv  - Loads and pre-compiles Ractive templates from external files. A sample  Ractive + RequireJS sample application  is also available using rv.", 
            "title": "RequireJS"
        }, 
        {
            "location": "/resources/#browserify", 
            "text": "ractify  - Converts component files into  CJS modules .  ractiveify  - Similar to ractify, but supports JS/CSS compilation.  ractive-componentify  - Similar to ractiveify, but supports  source maps  and partial imports.  Ractivate , a transform that will pre-parse templates. Contributed by  jrajav .  (GitHub repository) . A  starter project  is available with a  gulp.js  build system.", 
            "title": "Browserify"
        }, 
        {
            "location": "/resources/#broccoli", 
            "text": "broccoli-ractive  - Converts your component files into either AMD, CJS, or ES modules.", 
            "title": "Broccoli"
        }, 
        {
            "location": "/resources/#webpack", 
            "text": "ractive-component-loader  - Allows you to load component files as constructors via Webpack.  ractive-bin-loader  - Write Ractive.js components and have them available pre-compiled for the rest of your webpack build.", 
            "title": "Webpack"
        }, 
        {
            "location": "/resources/#grunt", 
            "text": "grunt-ractive  - Compiles Ractive component files into AMD, CJS or ES modules.", 
            "title": "Grunt"
        }, 
        {
            "location": "/resources/#babel", 
            "text": "TODO", 
            "title": "Babel"
        }, 
        {
            "location": "/resources/#tools", 
            "text": "", 
            "title": "Tools"
        }, 
        {
            "location": "/resources/#ractive-cli", 
            "text": "As of version 0.9, Ractive now comes with a CLI tool that comes with a few handy commands. See  ractive help  for more details on available commands.", 
            "title": "Ractive CLI"
        }, 
        {
            "location": "/resources/#ractive-utilities", 
            "text": "Ractive provides a couple of modules to aid you in loader development:   rcu  - An importable/embeddable library that provides utility APIs to help your loader parse the different portions of the component file.  rcu-builders  - A module that provides utility APIs to help your loader convert parsed component files into other module formats like ES, AMD and CJS.", 
            "title": "Ractive utilities"
        }, 
        {
            "location": "/resources/#yeoman", 
            "text": "Jorge Colindres  has created  generator-ractive , a Yeoman generator to quickly set up a Ractive application.", 
            "title": "Yeoman"
        }, 
        {
            "location": "/concepts/", 
            "text": "Architecture\n\n\nThere are three major sections in the Ractive source code: The parser which handles template parsing, the models which handle data management and the views which handle the virtual DOM. This document aims to give a breakdown of just what exactly each of these sections do.\n\n\nParser\n\n\nRactive's parser is reponsible for taking in Mustache-like/Handlebar-like templates. Unlike Mustache and Handlebars, however, it turns them into an \nAST\n for use by the runtime. In addition, it also supports a fair amount of ES syntax for use in expressions.\n\n\nEach item expressable in Ractive-flavored mustache has its own parsing function that may also be comprised of other parsing functions. Each bit of ES syntax that Ractive understands for expressions also has its own parsing function. The parser starts at the beginning of the template string and starts applying each parsing function in precedence order. Each function will then consume as much of the template as needed to return an item, like an element, a section, a partial, a bit of text, or an interpolator. It may also return nothing. Most items can also contain children, including items of the same type as themselves, and will thus recurse by trying to parse their content.\n\n\nMustaches\n\n\nEach type of mustache has its own reader that calls the appropriate expression or reference readers internally. For instance, the partial reader reads the current open mustache delimiter (defaults to \n{{\n) followed by a \n. It then expects to find a relaxed reference, meaning it may contain dashes and slashes among other usually-forbidden characters. It may then optionally read a context expression or series of alias definitions\n\n\nExpressions\n\n\nThe expression readers are set arranged such that they can read valid ES expressions with the correct operator precedence by starting with ternary conditionals and trying different expression types from there. Once the expression tree has been parsed, it is flattened into an expression string and a list of references that are used within that string. If the parsing is done with \ncsp\n (Content Security Policy) support enabled, then the expression strings are also turned into functions and attached to the output template structure so that the template can be used as-is from a script tag without \neval\ning.\n\n\nCleanup\n\n\nAfter all of the nodes have been parsed from the template, the template is cleaned up in a process that, among other things, merges adjacent text nodes and forms individual conditional sections out of \nelseif\n/\nelse\n trees.\n\n\nModels\n\n\nRactive wraps any data given to it into a tree-like hierarchy of \nModel\n. Any data that is rendered into a template will be bound to a \nModel\n. Access to read and write data in Ractive is handled through the model hierarchy based on keypaths, which are, generally, a list of object properties that one would need to follow to reach a leaf of the data tree starting from the root. Each key along the keypath has its own corresponding model.\n\n\nModels allow entities that depend upon them to register themeselves to receive change notifications when the model value changes. This is how Ractive keeps track of exactly which parts of the view need to be updated when values change.\n\n\nAll of the data managed by Ractive is represented by its model hierarchy.\n\n\nAlmost every type of Model is a subclass of \nModel\n, so it seems a good place to start. Each model typically has a parent model, a key that is used to access its value from its parent, and a value. Most models also have children of some sort, which are tracked by key such that \n{ foo: { bar: 'baz' } }\n would have a model with a \nchildByKey['foo']\n, which would also have a model at \nchildByKey['bar']\n. The value of each of the models listed there would be the object containing \nfoo: { bar:\nbaz\n}\n, its \nfoo\n child would be the object \nbar: 'baz'\n, and its \nbar\n child would be the string \n'baz'\n. Where children of a model are other models, dependents (\ndeps\n) of a model may be anything that wants to be notified of changes, and each model will typically have a number of dependents, too.\n\n\nEach model has a unique keypath that is assembled by taking its key and each of its parents keys up to the root and joining them with a \n.\n.\n\n\nModels are also inherently lazy, meaning their value is not necessarily available when the are created. A value is retrieved from a model using its \nget\n method which may have the side effect of computing the value. Once a value has been computed, it is generally cached until a change happens that would cause the cache to be invalidated. In most models, there isn't really an opportunity for that change outside of normal change propagation.\n\n\nRootModel\n\n\nEvery tree needs a root, and \nRootModel\n serves that purpose here. Each Ractive instance gets its own \nRootModel\n that is stored at its \nviewmodel\n property. This special model is also the storage point for computations and mappings.\n\n\nKeyModel\n\n\nThe last major model remaining is the \nKeyModel\n. Instances of this represent indices of arrays and keys of objects during iteration. The key flavor never is immutable, becuase the keys of  objects never change (they may be removed, but that doesn't change the key itself). The index flavor \ndoes\n change, but only when the array represented by its parent model is shuffled.\n\n\nOther models\n\n\nThere are a few other types of \nModel\n in the code, such as the \nRactiveModel\n, which represents a Ractive instance, and the \nGlobalModel\n, which represents the global object of the current environment a.k.a. \nwindow\n for browsers and \nglobal\n for Node.js.\n\n\nModel operations\n\n\nChange propagation\n\n\nWhen a change is supplied to a model, its \nset\n method is called, which usually delegates to \napplyValue\n. \napplyValue\n checks to see that the value has actually changed in some way (hint: setting to the same object or array is considered a change because something may have changed further in), and if it has, it will start change notification for all of the model's children and dependents. If the model has resolvers registered with it trying to get an unresolved value, then this is where the unresolved value will be resolved and the resolver satisfied and cleared. Next, any children will be notified that their parent has had a value change and that they may need to update accordingly, which may trigger further cascades of resolution and change notification. Next, any dependents of the model will be notified that the model has had a value change as their \nhandleChange\n methods are called. Finally, upstream models (parents) are notified that a change has taken place somewhere among its children.\n\n\nThe child notification of the propagation is handled by the model's \nmark\n method. \nmark\n also checks to see that the value has actually changed, and if it has, will notify its children and dependents that it has had a value change. This is also the method called when the user signals that they have changed some data externally by calling \nractive.update()\n.\n\n\nShuffling\n\n\nThere is a special form of change wherein an array is modified without being swapped out, which is triggered by array methods like \nsplice\n, \npush\n, and \npop\n. When an array modification happens, change propagation takes a special path through the model that allows more precise DOM manipulation rather than throwing all of the DOM out and replacing it with a new result. This is achieved by having the special array method handlers compute which indexes are actually changed and having the array model's deps that can actally handle a shuffle ignore any untouched indices.\n\n\nThe instance method \nmerge\n does something similar, but instead of modifying the underlying array, it compares the members of the new supplied array against the model array to compute the index changes. It the swaps in the new array and triggers a shuffle based on the computed index changes.\n\n\nAdaptation\n\n\nBetween the change check and the change propagation during \napplyValue\n, there is a step that handles part of adaptation so that external objects with special behaviors, like backbone models, can be used as data sources. An adaptors takes the special object, wraps it up, and returns the wrapper that also has a value that represents the object for consumption by Ractive. Most adaptors also have methods to update values in their source data as well, and those methods are called when an update is applied to an adapted model.\n\n\nComputations\n\n\nA computation is exactly what is sounds like: a getter and optional setter function that are used to provide read and optional write access to some non-fixed piece of data. Each computation is stored in the root model \ncomputations\n hash by its keypath. Computations can be created in two places:\n\n\n\n\nExplicitly when a \ncomputed\n map is passed to a Ractive instantiation or when an entry is later added to a instance's computed map. These may be read/write and have a keypath that mirrors their name.\n\n\nImplicitly when an expression is used in a template. These are read-only and have a keypath that is an expanded representation of their expression.\n\n\n\n\nA computation is also a form of model, so anything that depends on it will subscribe to it as if it were a regular model. Change propagation happens in the same way as a regular model as well.\n\n\nSince computations may depend on other bits of data controlled by Ractive, while they are being retrieved, any references to other models will cause the extra references to be \ncapture\nd. When the computation is complete, the computation will register with each of its captured dependencies so that it will be notified when it needs to invalidate and notify its dependents of the change.\n\n\nMappings\n\n\nWhen a Ractive instance has children, typically components, it may supply a handles to its own data to them in the form of mappings. The child instance stores a reference to the parent model at its mapped name and uses it when its dependents request access to keypaths that start with the mapped name. This allows child instances, which may be isolated, to stay in sync with portions of their parents data easily, because the parent still controls the data (single source of truth) and there is no syncing involved. So if a parent has a component \nComponent foo=\"{{bar.baz.bat.bippy}}\" /\n, then the component instance will get a mapping \nfoo\n that references the parent model at \nbar.baz.bat.bippy\n.\n\n\nVirtual DOM\n\n\nEvery piece of DOM that Ractive can manage has a corresponding class in the virtual DOM to handle the DOM node, which generally end up being either Elements or Text Nodes. View items are grouped together as Fragments of view, which may then be owned by other fragments or items. At the root of every ractive instance is a Fragment instance that contains its entire virtual DOM tree. Each Ractive template construct has at least one analog in the virtual DOM. The bulk of Ractive's view functionality is implemented in the Section, Interpolator, and Element items, with there being a number of specialized element classes to handle special types of HTML element.\n\n\nAll virtual DOM items go through roughly the same lifecycle: creation, binding, rendering, bubbling, updating, unrendering, and unbinding. Creation is basically just the constructor call and almost always is immediately followed by binding. Binding is the point at which the item resolves and registers with its data references. Rendering is the point at which the item inserts an actual DOM node into the DOM. Bubbling and updating are the two halves of the update process, which is discussed in the next section. Unrendering is the point at which the item should no longer be present in the DOM, and it often occurs at the same point as unbinding, which is the point at which the item unregisters with the viewmodel and is effectively destroyed.\n\n\nThere a number of other members, such as events and decorators, and processes, such as change propagation, which are described in detail in the view overview.\n\n\nRactive views are structured virtual DOM trees that are assembled from template AST and manage DOM nodes on the page when they are rendered. Virtual DOM items are grouped together in \nFragment\ns, which contain them, and they may also own \nFragment\ns that contain other items. Each item may contain a reference to a DOM node when rendered, though every item doesn not have a DOM analog.\n\n\nParallel DOM\n\n\nRactive works by maintaining a simplified model of the part of the DOM that it's responsible for. This model contains all the information - about data-binding, event handling and so on - that it needs to keep things up-to-date.\n\n\nYou can inspect the parallel DOM to understand what's going on under the hood, if you're into that sort of thing. Each Ractive instance, once rendered, has a \nfragment\n property. Each fragment has a number of properties:\n\n\n\n\ncontextStack\n - the context stack in which mustache references should be evaluated\n\n\nroot\n - a reference to the Ractive instance to which it belongs\n\n\nowner\n - the \nitem\n that owns this fragment (in the case of the root fragment, the same as \nroot\n)\n\n\nitems\n - the items belonging to this fragment\n\n\n\n\nItems\n means elements, text nodes, and mustaches. Elements may have fragments of their own (i.e. if they have children). A partial mustache will have a fragment, and a section mustache will have zero or more fragments depending on the value of its keypath.\n\n\nElements may also have attributes, which have a different kind of fragment (a \ntext fragment\n as opposed to a \nDOM fragment\n), containing text and mustaches.\n\n\nEach item has a \ndescriptor\n, which is something like DNA. This comes straight from the parsed template.\n\n\nThis is the briefest of overviews - if you want to gain a deeper understanding of what's going on under the hood, \nuse the source\n.\n\n\nStates\n\n\nItems generally follow a fixed lifecycle.\n\n\n\n\nConstruction - the item is created and knows about its parent and the template chunk from which it was created. Its template may also indicate what its children should look like if it has them.\n\n\nbind\n - the item looks up any references is may have and registers with the model(s) that they represent. At this point, the item may create child items and bind them as well.\n\n\nrender\n - the item may create an actual DOM node and tell its children to create their DOM nodes as necessary. The resulting nodes will be inserted into the document.\n\n\nunrender\n - thie item is no longer needed and will be removed from the document immediately or in the near future.\n\n\nunbind\n - this typically goes along with \nunrender\n and tells the models on which this item depends that they should no longer send change notifications to it.\n\n\n\n\nThere is a sixth floating step \nrebind\n that happens any time one dependency models shuffles (and in certain other very special circumstances) that causes the items to re-resolve their models and re-register if necessary.\n\n\nVirtual DOM Items\n\n\nText\n\n\nText is the simplest item. It simply holds a string that it turns into a \nTextNode\n when rendered.\n\n\nInterpolator\n\n\nThis is the next simplest item. It resolves a model for its reference or expression and renders the value of the model as a text node if needed. Interpolators don't necessarily render directly, as they may be used for values by other items, such as attributes, mappings, and bindings.\n\n\nElement\n\n\nAn \nElement\n represents a DOM element. It also contains a number of other items in the form of \nAttribute\ns, \nDecorator\ns, \nTransition\ns, \nEventDirective\ns, and its children in a \nFragment\n.\n\n\nAttributes\n\n\nThere are actually several different items that are treated as attributes for \nElement\ns, event though only two of them actually may render into the DOM.\n\n\n\n\nAttribute\ns - maybe obvious, they these represent a DOM attribute on their parent element. There are a number of different handlers for updating attributes depending on the element and attribute name. The \nupdateDelegate\n for a particular attribute can be found in \ngetUpdateDelegate.js\n.\n\n\nConditionalAttribute\ns - render as a string and are parsed into actual DOM attributes using a \ndiv\n or an \nsvg\n depending on their parent element.\n\n\nMapping\ns - when rendered add a mapping to their component, and when unrendered, remove it. These aren't attached to \nElement\ns, but instead, are attached to \nComponent\ns (see below).\n\n\nEventDirective\ns - when rendered attach an event listener to their parent, and when unrenedered, remove it. Event parameters are kept in sync with their bindings and are evaluated when the event fires.\n\n\nBindingDirective\ns - when rendered and unrendered update their parent element's bindings, if they exist.\n\n\nDecorator\ns - when rendered call the named decorator with their parent element, and when unrenedered, remove it. \nDecorator\ns also have an update cycle related to their parameters.\n\n\nTransition\ns - are a sort of weird case. When rendered, they attach a transition handler to their element, and when the element renders or unrenders, if an appropriate transition handler is registered, will trigger the transition. Transition parameters are also kept in sync with their bindings.\n\n\n\n\nBindings\n\n\nCertain attributes may also trigger a binding to be created on their parent element. For instance, if two-way binding is enabled on the parent element, and the parent element is an \ninput\n, a \nvalue\n attribute with a single \nInterpolator\n as its content will cause a two-way binding to be created between the value of the \ninput\n and the model of the \nInterpolator\n. This binding will handle updating the model when the input \nvalue\n has changed. There are a few other types of bindings for managing check values, content editables, name-bound lists of checkboxes, and other miscellaneous special values.\n\n\nA \nlazy\n binding directive will cause any associated two-way bindings to fire either after a timeout or on blur, depending on the value of the \nlazy\n directive.\n\n\nSection\n\n\nSection\ns come in many flavors, depending on the chunk of template from which they are created. A section may provide context, be conditional (positive or negative), or be iterative. Generic sections (\n{{#something}}...{{/}}\n in template) will adjust their type, to a certain extent, based on the value of their model. A generic section will always provide context in the form of their model. An \nif\n-style conditional section, including \nelseif\n, \nelse\n, and \nunless\n do not provide context. An \neach\n section will always provide context in the form of the current iteration. A \nwith\n section will always provide context as its model, but it will only render if its model is considered truthy by Ractive, which is pretty much the same as JS truthy except \n{}\n and \n[]\n are falsey. A generic section will be context/conditional if it is anything other than an array, which will make it iterative.\n\n\nSections that provide context do so by binding their \nFragment\ns with their model so that the reference resolution process can find the appropriate contexts when resolving.\n\n\nContext/Conditional\n\n\nContext and conditional sections will render and unrender their child fragment as their model changes truthiness. Conditional sections always stand alone, even it they have \nelseif\n or \nelse\n branches nested within them, because those branches are turned into independent sections during parsing.\n\n\nIterative\n\n\nIf section is designated iterative (\n{{#each ...}}\n) or is a general section with an array value resolution, the section will create a special form of fragment for each index or key in the value. The special form \nRepeatedFragment\n handles mapping of indices, keys, and references to those to a corresponding model. Iterative sections also have special handling for shuffles so that DOM is not wholesale destroyed and recreated when the array shuffles.\n\n\nIterative sections may supply an alias for their context, so that referencing the iterated value is a little bit easier. See \nAliases\n below for more info, as this is just a slightly specialized form of that.\n\n\nIterative sections may also supply key and/or index aliases so that their keys and/or indices may be referenced by a name from within their child fragments.\n\n\nAlias\n\n\nAlias sections simply resolve their models and act as a lookup endpoint for reference resolution. Aliasing happens entirely in the view.\n\n\nComponent\n\n\nA component is a sort-of special form of \nElement\n that, instead of creating a DOM element, creates a new Ractive instance. The child instance will be rendered and unrendered in place of the component placeholder in the DOM.\n\n\nAny plain \nAttribute\ns with a single \nInterpolator\n as content in a component's template are turned into \nMapping\ns.\n\n\nThe resolution process no longer happens strictly within the vDOM, as the result of \nRactive.getContext\n also uses the target \nElement\n's fragment to resolve relative references. Event objects are also extended with methods from the same helper.\n\n\nUpdates\n\n\nThe \nrunloop\n controls when the DOM is actually updated and when transitions start in \nbatch\nes. It also handles resolving promises when transitions have completed and the DOM is completely up to date.\n\n\nAs changes propagate through the viewmodel, view items are notified of the change through their \nhandleChange\n method. Most items just set a dirty flag and notify their parent, via their \nbubble\n method, that they will need to be updated at the completion of the runloop turn. The root fragment of each instance affected will then register with the runloop. Once the changes are ready to be flushed to the view, each fragment registered with the runloop is called on to update, where the process happens in reverse, with each parent fragment checking to see if there is a change it needs to respond to and propagating the update downward to its children.\n\n\nData management\n\n\nDependents\n\n\nRactive maintains a dependency graph in order to do only the minimum amount of work necessary to keep the DOM up-to-date. If you inspect a Ractive instance, you'll see a property called \n_deps\n. This is where all dependants are listed, indexed by their dependency.\n\n\nExpression dependencies\n\n\nRactive uses dynamic analysis to determine dependencies. Depedendencies are determined by capturing references in the viewmodel while the function is executing. Dependencies for functions are re-captured each time the function is executed.\n\n\np\n{{ formattedName() }}\n/p\n\n\n\n\n\nvar ractive = Ractive({\n  template: template,\n  el: output,\n  data: {\n    user: { firstName: 'John', lastName: 'Public' },\n    formattedName () {\n      return this.get('user.lastName') + ', ' + this.get('user.firstName')\n    }\n  }\n}\n\n\n\n\nResult:\n\n\np\nPublic, John\n/p\n\n\n\n\n\nIn this example, the function \nformattedName\n will depend on both \nuser.firstName\n and \nuser.lastName\n, and updating either (or \nuser\n) will cause any expressions referencing \nformattedName\n to be re-evaluated as well.\n\n\nractive.set('user.firstName', 'Jane')\n\n\n\n\nResult:\n\n\np\nPublic, Jane\n/p\n\n\n\n\n\nPriority\n\n\nRactive runs updates based on priority. For instance, when a subtree of the DOM needs to be removed while at the same time updates are pending for that subtree. What Ractive does is prioritize the removal of the subtree over the updates. This causes the dependents on the subtree to unregister themselves, eliminating the need to update, resulting with only the removal operation being done.\n\n\nIndirect dependencies\n\n\nIf you have a mustache which depends on \nfoo.bar\n, and \nfoo\n changes, it's quite possible that the mustache needs to re-render. We say that the mustache has an \nindirect dependency\n on \nfoo\n, or that it has a \ndirect dependency on a downstream keypath\n of \nfoo\n.\n\n\nThis relationship is expressed through the \n_depsMap\n property of a Ractive instance - whenever \nfoo\n changes, as well as dealing with direct \nfoo\n dependants we check the map for those indirect dependants.\n\n\nIn the case of expressions and observers, we also need to consider dependants of \nupstream keypaths\n. For example, suppose we have a section based on a sorted array - if we modify one of the members of the array, we need to see if the sort order has changed or not as a result:\n\n\n{{#( sort( list, 'name' ) )}}\n  \np\n{{name}}\n/p\n\n{{/()}}\n\n\n\n\nractive = Ractive({\n  el: myContainer,\n  template: myTemplate,\n  data: {\n    list: [{ name: 'Bob' }, { name: 'Charles' }, { name: 'Alice' }],\n    sort ( list, property ) {\n      return list.slice().sort( function ( a, b ) {\n        return a[ property ] \n b[ property ] ? -1 : 1\n      })\n    }\n  }\n})\n\n// renders Alice, Bob, Charles\n\nractive.set( 'list[0].name', 'Zebediah' )\n\n// updates to Alice, Charles, Zebediah\n\n\n\n\nIn the example, setting \nlist[0].name\n causes dependants of \nlist\n to be updated.\n\n\nAs well as expressions, Observers respond to both upstream and downstream changes.\n\n\nExpressions with multiple dependencies\n\n\nThe expression \n{{ a + b }}\n has two dependencies - \na\n and \nb\n (or more accurately, whatever those references resolve to). The \n_deps\n graph actually includes objects representing those individual references, rather than the expression itself - the reference objects then notify the expression (if their value has changed) that it will need to re-evaluate itself.\n\n\nBecause the expression has multiple dependencies, it won't trigger an update straight away - it will wait until all the new data has come in first. So doing \nractive.set({ a: 1, b: 2 })\n will only trigger one update, not two.\n\n\nTwo-way binding\n\n\nTwo-way binding allows data to update bi-directionally, from data to the UI and vice versa.\n\n\n\n\n\nRactive({\n  data: {\n    msg: 'Hello, World!'\n  },\n  template: `\n    \ninput type=\ntext\n value=\n{{ msg }}\n {{ msg }}\n\n    \nbutton on-click=\n@this.set('msg', 'Lorem Ipsum')\nTo lipsum\n/button\n\n  `\n})\n\n\n\n\nTwo-way binding can be disabled via the \ntwoway\n initialization option or the \ntwoway\n input directive.\n\n\nAmbiguous references\n\n\nAn ambiguous reference refers to a reference whose data does not exist at the time of construction. Ractive must make an assumption, following a resolution algorithm, on what ambiguous references resolve to. Until a suitable keypath pops into existence, ambiguous references resolve to \nundefined\n.\n\n\n\n\n\nRactive({\n  data: {},\n  template: `\n    \ninput value=\n{{ msg }}\n {{ msg }}\n  `,\n})\n\n\n\n\nAmbiguous references can be locked to a specific keypath, skipping the whole resolution process, using keypath prefixes.\n\n\nLazy updates\n\n\nBy default, Ractive uses various events (i.e. \nchange\n, \nclick\n, \ninput\n, \nkeypress\n) to listen for changes on interactive elements and immediately update bound data. In cases where data updates should only take place after the element loses focus, Ractive also supports lazy updating.\n\n\n\n\n\nRactive({\n  lazy: true,\n  data: {\n    msg: ''\n  },\n  template: `\n    \ndiv\nType and click outside the input\n/div\n\n    \ninput type=\ntext\n value=\n{{ msg }}\n {{ msg }}\n  `\n})\n\n\n\n\nLazy updates can be enabled via the \nlazy\n initialization option or the \nlazy\n directive.\n\n\nComputed Properties\n\n\nComputed properties are top-level pseudo-data references whose value is defined by a computation and which automatically update when its dependencies update.\n\n\nFunction syntax\n\n\nThe function syntax defines a computed property as a function that returns the computed value. The context of the function is the current instance.\n\n\n\n\n\nRactive({\n  data: {\n    width: 200,\n    length: 300\n  },\n  computed: {\n    area () {\n      return this.get('width') * this.get('length')\n    }\n  },\n  template: `\n    Width: \ninput type=\ntext\n value=\n{{ width }}\n\n    Length: \ninput type=\ntext\n value=\n{{ length }}\n\n    Area: {{ area }}\n  `\n})\n\n\n\n\nExpression syntax\n\n\nThe expression syntax defines a computed property as a string containing a JavaScript expression. \n${}\n is replaced internally with a \nractive.get()\n, using its contents as a keypath.\n\n\n\n\n\nRactive({\n  data: {\n    width: 200,\n    length: 300\n  },\n  computed: {\n    area: '${width} * ${length}'\n  },\n  template: `\n    Width: \ninput type=\ntext\n value=\n{{ width }}\n\n    Length: \ninput type=\ntext\n value=\n{{ length }}\n\n    Area: {{ area }}\n  `\n})\n\n\n\n\nAccessor syntax\n\n\nBoth function and expression syntaxes only describe retrieval of the computed property's value, and therefore makes the computed property read-only. The accessor syntax defines a computed property by providing \nget\n and \nset\n methods. \nget\n is called to retrieve its value and \nset\n is called when something updates its value.\n\n\n\n\n\nRactive({\n  data: {\n    side: 200\n  },\n  computed: {\n    area: {\n      get () {\n        return Math.pow(this.get('side'), 2)\n      },\n      set(v) {\n        this.set('side', Math.sqrt(v))\n      }\n    }\n  },\n  template: `\n    Side: \ninput type=\ntext\n value=\n{{ side }}\n\n    Area: \ninput type=\ntext\n value=\n{{ area }}\n\n  `\n})\n\n\n\n\nBoth function and expression syntaxes are supported for the \nget\n method.\n\n\nObservers\n\n\nNested properties\n\n\nObservers observe \nupstream\n and \ndownstream\n keypaths. This allows observers to execute when data is updated indirectly, whether if it's the enclosing structure or a descendant structure.\n\n\n\n\n\nconst instance = Ractive({\n  data: {\n    foo: {\n      bar: 1\n    }\n  },\n  observe: {\n    'foo' (newValue) {\n      console.log('foo changed to', newValue)\n    },\n    'foo.bar' (newValue) {\n      console.log('foo.bar changed to', newValue)\n    }\n  }\n})\n\ninstance.set('foo.bar', 2)\ninstance.set('foo', { bar: 3 })\n\n\n\n\nObservers can be set to only execute on the specified keypath via the \nstrict\n option for both \nobserve\n initialization option and \nractive.observe()\n.\n\n\nWildcards\n\n\nWildcards allow observers to observe keypaths whose segments cannot be determined in advance. This is useful when observing an array, observing items within an array, or observing changes on object properties.\n\n\n\n\n\nconst instance = Ractive({\n  data: {\n    people: [\n      {name: 'Rich Harris'},\n      {name: 'Marty Nelson'}\n    ],\n    config: {\n      allowComments: true,\n      allowEdit: false\n    }\n  },\n  observe: {\n    // Observe changes on the array\n    'people.*' () {\n      console.log('array observer', arguments)\n    },\n    // Observe changes on the name property of any item in the array\n    'people.*.name' () {\n      console.log('array item observer', arguments)\n    },\n    // Observe changes on any property of an object\n    'config.*' () {\n      console.log('object property observer', arguments)\n    }\n  }\n})\n\ninstance.push('people', {name: 'Jason Brown'})\ninstance.set('people.3', {name: 'Jack Black'})\ninstance.set('config.allowEdit', true)\n\n\n\n\nMultiple sources\n\n\nMultiple keypaths can be observed by adding them one after the other, separating them with a space.\n\n\n\n\n\nconst instance = Ractive({\n  data: {\n    user: {username: 'browniefed'},\n    config: {isAdmin: false},\n    commentCount: 0\n  },\n  observe: {\n    'user.username config.isAdmin commentCount' () {\n      console.log('data changed', arguments)\n    }\n  }\n})\n\ninstance.set('user.username', 'chris')\ninstance.set('config.isAdmin', true)\ninstance.set('commentCount', 42)\n\n\n\n\nCaveats\n\n\nObservers do not defensively clone the old and new values as identity of these values may be essential. Thus, observers on non-primitive values may result in having identically equal old and new values.\n\n\n\n\n\nconst instance = Ractive({\n  data: {\n    config: {\n      allowComments: true,\n      allowEdit: false\n    }\n  },\n  observe: {\n    'config' (newValue, oldValue) {\n      console.log(newValue === oldValue)\n    }\n  }\n})\n\ninstance.set('config.allowEdit', true)\n\n\n\n\nBoth \nobserve\n initialization option and \nractive.observe()\n accept an \nold\n option which allows you to define the old value passed to the observer prior to modifications.\n\n\nComponents\n\n\nMappings\n\n\nMappings connect pieces of data on the enclosing instance to data on enclosed instances. Changes on one side will reflect on the other.\n\n\nRactive.components.MyComponent = Ractive.extend({\n  data: {\n    message: ''\n  },\n  template: `\n    \ninput type=\ntext\n value=\n{{ message }}\n\n  `\n})\n\nconst instance = Ractive({\n  el: 'body',\n  data: {\n    text: ''\n  },\n  template: `\n    \nMyComponent message=\n{{ text }} /\n\n  `\n})\n\nractive.set('text', 'Hello World!')\n\n\n\n\nIn the example above, \ntext\n on the instance is mapped to \nMyComponent\n's \nmessage\n. Updates on \ntext\n will update \nmessage\n and any UI elements bound to it. Updates on \nmessage\n, like editing the \ninput\n bound with it, will update \ntext\n.\n\n\nData context\n\n\nEach component instance comes with its own data context so that its data does not pollute the primary data. Any mapping between the component and the enclosing instance will still update across both contexts.\n\n\nRactive.components.MyComponent = Ractive.extend({\n  data: {\n    shades: '',\n    option: ''\n  }\n})\n\nconst instance = Ractive({\n  template: `\n    \nMyComponent shades='{{colors}}' option='A' /\n\n  `,\n  data: {\n    name: 'Colors',\n    colors: ['red', 'blue', 'yellow']\n  }\n})\n\nconst widget = ractive.findComponent('MyComponent')\n\nractive.get() // {\ncolors\n:[\nred\n,\nblue\n,\nyellow\n], \nname\n:\nColors\n}\nwidget.get()  // {\nshades\n:[\nred\n,\nblue\n,\nyellow\n], \noption\n:\nA\n}\n\nractive.set('colors.1', 'green')\n\nractive.get() // {\ncolors\n:[\nred\n,\ngreen\n,\nyellow\n], \nname\n:\nColors\n}\nwidget.get()  // {\nshades\n:[\nred\n,\ngreen\n,\nyellow\n], \noption\n:\nA\n}\n\n\n\n\nIn the example above, the enclosing instance data holds \nname\n and \ncolors\n. \ncolors\n is mapped to \nshades\n and \noption\n is set on an instance of \nMyComponent\n. Upon inspection, \nname\n from the enclosing instance does not cross over to \nMyComponent\n nor does \noption\n cross over to the enclosing instance. However, since \ncolors\n on the instance is mapped to \nshades\n on the component, any modifications on either side will reflect on the other.\n\n\nIsolation\n\n\nBy default, components are \"isolated\". Descendant components can update ancestor data only when there is an explicit mapping between them. This avoids unintended mutation of ancestor data and ensures portability of components.\n\n\nRactive.components.ChildComponent = Ractive.extend({\n  template: 'Message missing {{ message }}'\n})\n\nconst instance = Ractive({\n  el: 'body',\n  template: '\nChildComponent /\n',\n  data: {\n    message: 'The ChildComponent will not know anything about this message'\n  }\n})\n\n\n\n\nIn the example above, \nChildComponent\n will not print anything since \nmessage\n is not defined in the component and due to isolation, the component cannot see the instance's \nmessage\n.\n\n\nIsolation can be disabled via the \nisolated\n initialization option.\n\n\nEvent Management\n\n\nLike many other libraries, Ractive implements its own \npublish/subscribe\n mechanism for triggering and responding to particular events. One of the advantages of using Ractive-managed events is that events are automatically unsubscribed and unreferenced once the instance is torn down, avoiding the need to do manual housekeeping.\n\n\nSources\n\n\nEvent API\n\n\nEvents that are published as a result of using the event APIs directly (i.e. \nractive.fire\n). Most of the other event sources use the event APIs to publish events at some point in their operation.\n\n\ninstance.fire('someevent', 'Hello, World!')\n\n\n\n\nLifecycle events\n\n\nLifecycle events are events that are published by an instance during the different phases of its existence. Ractive instances publish the following lifecycle events:\n\n\n\n\nconstruct\n\n\nconfig\n\n\ninit\n\n\nrender\n\n\ncomplete\n\n\nupdate\n\n\ninsert\n\n\ndetach\n\n\nunrender\n\n\nteardown\n\n\ndestruct\n\n\n\n\nLifecycle event names are reserved. They should not be used as names of other events.\n\n\nDOM events\n\n\nDOM events are events that are published by the DOM.\n\n\nbutton on-click=\n...\n\n\n\n\n\nCustom events\n\n\nCustom events are events that are published by event plugins.\n\n\nimg on-tap=\n...\n\n\n\n\n\nComponent events\n\n\nComponent events are events that are published by \ncomponents\n.\n\n\nMyModal on-close=\n...\n /\n\n\n\n\n\nHandling\n\n\nEvent API\n\n\nEvents published from the direct use of the event APIs are also handled by directly using the event APIs (i.e. \nractive.on\n, \nractive.once\n). Most of the other handling methods use the event APIs to handle events at some point in their operation.\n\n\ninstance.on('someevent', (context, message) =\n {\n  console.log(message)\n})\n\n\n\n\nLifecycle events\n\n\nLifecycle events are handled by assigning a function to the appropriate lifecycle event initialization option.\n\n\nRactive({\n  onrender () {\n    console.log('instance has been rendered')\n  }\n})\n\n\n\n\nThe event APIs can also subscribe to lifecycle events. However, the handler must subscribe prior to the event publishing. Using the lifecycle event initialization options is the safer option to ensure the correct timing of subscriptions.\n\n\nProxy syntax\n\n\nRactive instances do not immediately subscribe to template-based events (DOM events, component events, custom events). The proxy syntax \"proxies\" template-based events into events that the current instance can subscribe to. From there, the events are handled by event APIs. Arguments are not supported in this syntax.\n\n\nRactive({\n  template: `\n    \nbutton on-click=\nbuttonclicked\nClick Me!\n/button\n\n  `,\n  on: {\n    buttonclicked (context) {\n      console.log('button clicked')\n    }\n  }\n})\n\n\n\n\nExpression syntax\n\n\nA more powerful form of template-based event handling is the expression syntax, which allows the use of expressions as their values. This form acts very similar to inline scripts plus some useful additions. The expression syntax also has full, unmustached access to data and special references.\n\n\nThe first form is a special form of the proxy syntax. It accepts an array whose first item is the event name, and the rest are its arguments.\n\n\nRactive({\n  template: `\n    \nbutton on-click=\n['buttonclicked', 'foo', 'bar']\nClick Me!\n/button\n\n  `,\n  on: {\n    buttonclicked (context, foo, bar) {\n      console.log('button clicked passing', foo, bar)\n    }\n  }\n})\n\n\n\n\nThe second form uses expressions directly. This allows unrestricted access to almost anything, from calling instance methods, custom methods, or even firing a proxy event manually.\n\n\nRactive({\n  data: { msg: '' },\n  template: `\n    \nbutton on-click=\n@this.set('msg', 'Hello, World!')\nSet message\n/button\n\n    \nbutton on-click=\n@this.greetz(msg)\nPrint message\n/button\n\n    \nbutton on-click=\n@this.fire('manualproxy', msg)\nPrint message via proxy\n/button\n\n    \nbutton on-click=\n@this.set('foo', 1), @this.set('bar', 2)\nCccombo!!!\n/button\n\n  `,\n  greetz(message) {\n    console.log(`${message}`)\n  },\n  on: {\n    manualproxy (context, message) {\n      console.log(`${message}`)\n    }\n  }\n})\n\n\n\n\nEvent context\n\n\nEvent handlers, regardless of event source, receive an \ncontext\n object as first argument. The \ncontext\n object is a special instance of a context object augmented with additional event-related properties where applicable.\n\n\n\n\nname\n - The name of the published event.\n\n\nnode\n - A reference to the DOM node publishing the event. Only available on DOM events.\n\n\nevent\n - A reference to the DOM event. Only available on DOM\n\n\noriginal\n - A reference to the DOM event. Only available on DOM\n\n\ncomponent\n - A reference to the component that published the event. Only available on propagated events.\n\n\n\n\nRactive({\n  template: `\n    \nbutton on-click=\nbuttonclicked\nClick Me!\n/button\n\n  `,\n  on: {\n    buttonclicked (context) {\n      console.log(event.node.type) // submit\n    }\n  }\n})\n\n\n\n\nNamespacing\n\n\nPattern-matching is supported on any type of event, allowing a form of event namespacing. This is done by using a keypath-like event name and using wildcards (\n*\n) on segments during subscription.\n\n\nRactive({\n  el: 'body',\n  append: true,\n  template: `\n    \nbutton on-click=\nfoo.bar\nClick Me!\n/button\n\n    \nbutton on-click=\nfoo.baz\nClick Me!\n/button\n\n    \nbutton on-click=\nfoo.bam\nClick Me!\n/button\n\n    \nbutton on-click=\nqux.bar\nClick Me!\n/button\n\n    \nbutton on-click=\nqux.baz\nClick Me!\n/button\n\n    \nbutton on-click=\nqux.bam\nClick Me!\n/button\n\n  `,\n  on: {\n    '*.bar' (context) {\n      console.log('A bar event was published')\n    },\n    'qux.*' (context) {\n      console.log('A qux event was published')\n    }\n  }\n})\n\n\n\n\nBe aware that handlers subscribing to just \n*\n will fire for \nall\n events.\n\n\nPropagation\n\n\nDOM event propagation\n\n\nNative DOM event propagation is preserved, allowing things such as delegation.\n\n\nRactive({\n  template: `\n    \ndiv on-click=\nbuttonclicked\n\n      \nbutton type=\nbutton\nClick Me!\n/button\n\n    \n/div\n\n  `,\n  on: {\n    buttonclicked (context) {\n      console.log('button clicked')\n    }\n  }\n})\n\n\n\n\nComponent propagation\n\n\nPropagation across component boundaries is also supported. Propagating events are namespaced using the publishing component's name as prefix. This applies to component, proxy, and even lifecycle events.\n\n\nconst ChildComponent = Ractive.extend({\n  template: '\ndiv\n/div\n',\n  oncomplete () {\n    this.fire('childevent')\n  }\n})\n\nconst ParentComponent = Ractive.extend({\n  components: { ChildComponent },\n  template: '\nChildComponent /\n'\n})\n\nconst instance = Ractive({\n  components: { ParentComponent },\n  template: '\nParentComponent /\n'\n})\n\ninstance.on('ChildComponent.childevent', function () {\n  console.log('Hello World!')\n})\n\n\n\n\nStopping propagation\n\n\nPropagation can be stopped by simply returning \nfalse\n from an event handler. If the event is a DOM event, \nevent.stopPropagation()\n and \nevent.preventDefault()\n are automatically called.\n\n\nRactive({\n  template: `\n    \ndiv on-click=\nancestorbuttonclick\n\n      \nbutton on-click=\ndescendantbuttonclick\nClick Me!\n/button\n\n    \n/div\n\n  `,\n  on: {\n    ancestorbuttonclick (context) {\n      console.log('This will not run')\n    },\n    descendantbuttonclick (context) {\n      console.log('This will run')\n      return false\n    }\n  }\n})\n\n\n\n\nReturning \nfalse\n also stops propagation across components.\n\n\nconst ChildComponent = Ractive.extend({\n  template: '\ndiv\n/div\n',\n  oncomplete () {\n    this.fire('childevent')\n  }\n})\n\nconst ParentComponent = Ractive.extend({\n  components: { ChildComponent },\n  template: '\nChildComponent /\n',\n  on: {\n    'ChildComponent.childevent' () {\n      return false\n    }\n  }\n})\n\nconst instance = Ractive({\n  components: { ParentComponent },\n  template: '\nParentComponent /\n'\n})\n\ninstance.on('ChildComponent.childevent', function () {\n  console.log('This will not run')\n})\n\n\n\n\nAssigning a handler using \non-*\n will also stop propagation. However, if \non-*\n is assigned a proxy event and not stopped, that proxy event will propagate in place of the stopped event.\n\n\nconst ChildComponent = Ractive.extend({\n  template: '\ndiv\n/div\n',\n  oncomplete () {\n    this.fire('childevent1')\n    this.fire('childevent2')\n    this.fire('childevent3')\n    this.fire('childevent4')\n  }\n})\n\nconst ParentComponent = Ractive.extend({\n  components: { ChildComponent },\n  template: `\n    \nChildComponent\n      on-childevent1=\n\n      on-childevent2=\nchildevent2proxy\n\n      on-childevent3=\nchildevent3proxy\n\n      on-childevent4=\n@this.parentMethod()\n\n    /\n\n  `,\n  on: {\n    childevent2proxy () {\n      // childevent2proxy replaces childevent2\n    },\n    childevent3proxy () {\n      // childevent3proxy replaces childevent3 but stopped\n      return false\n    }\n  },\n  parentMethod () {\n    // childevent4 handled by a method\n  }\n})\n\nconst instance = Ractive({\n  components: { ParentComponent },\n  template: '\nParentComponent /\n'\n})\n\ninstance.on('ChildComponent.childevent1', function () {\n  console.log('childevent1 stopped by a blank handler')\n})\n\ninstance.on('ChildComponent.childevent2', function () {\n  console.log('childevent2 stopped by a proxy event')\n})\n\ninstance.on('ChildComponent.childevent3', function () {\n  console.log('childevent3 stopped by a proxy event')\n})\n\ninstance.on('ChildComponent.childevent4', function () {\n  console.log('childevent4 stopped by a method call')\n})\n\ninstance.on('ParentComponent.childevent3proxy', function () {\n  console.log('childevent3proxy stopped by returning false')\n})\n\n// This one gets through since its proxy event was left to propagate\ninstance.on('ParentComponent.childevent2proxy', function () {\n  console.log('childevent2proxy fired')\n})\n\n\n\n\nRendering\n\n\nSynchronous rendering\n\n\nRactive does not batch renders, asynchronously render, nor render at next tick. The instance's DOM is updated immediately after its dependencies update. This is a trade-off between optimization and predictability. Ractive chose the latter route to make it easier to anticipate the state of the DOM at any given moment.\n\n\n\n\n\nconst instance = Ractive({\n  target: 'body',\n  data: {\n    count: 0,\n  },\n  template: `\n    \ndiv\n{{ count }}\n/div\n\n  `,\n})\n\nconst div = instance.find('div')\n\nconsole.log('Before:', div.innerHTML)\ninstance.set('count', 100)\nconsole.log('After:', div.innerHTML)\n\n// Before: 0\n// After: 100\n\n\n\n\nThe only time rendering happens asynchronously is during animations and transitions. All mutator methods return a promise which resolves when the animations and/or transitions resulting from these operations complete.\n\n\n\n\n\nconst instance = Ractive({\n  target: 'body',\n  data: {\n    count: 0,\n  },\n  template: `\n    \ndiv\n{{ count }}\n/div\n\n  `,\n})\n\nconst div = instance.find('div')\n\nconsole.log('Before:', div.innerHTML)\ninstance.animate('count', 100).then(() =\n {\n  console.log('Resolved:', div.innerHTML)\n})\nconsole.log('After:', div.innerHTML)\n\n// Before: 0\n// After: 0\n//\n// Resolved: 100\n\n\n\n\nScoped CSS\n\n\nCSS provided via the \ncss\n initialization option is scoped to the component.\n\n\nconst Component = Ractive.extend({\n  template: `\n    \nspan\nI'm red\n/span\n\n    \ndiv\n\n      \nspan\nI'm also red\n/span\n\n    \n/div\n\n  `,\n  css: `\n    span { color: red }\n  `\n})\n\nRactive({\n  components: { Component },\n  el: 'body',\n  template: `\n    \nComponent /\n\n    \nspan\nI'm not red\n/span\n\n  `\n})\n\n\n\n\nThis is done by generating a unique id for each component definition. That ID is then added to each selector defined in \ncss\n and to each top-level element in the component's DOM.\n\n\nspan[data-ractive-css~=\n{6f9bd745-a6b9-9346-0c8c-e3cc94b3d2a5}\n],\n[data-ractive-css~=\n{6f9bd745-a6b9-9346-0c8c-e3cc94b3d2a5}\n] span {\n  color: red\n}\n\n\n\n\nspan data-ractive-css=\n{6f9bd745-a6b9-9346-0c8c-e3cc94b3d2a5}\nI'm red\n/span\n\n\ndiv data-ractive-css=\n{6f9bd745-a6b9-9346-0c8c-e3cc94b3d2a5}\n\n  \nspan\nI'm also red\n/span\n\n\n/div\n\n\nspan\nI'm not red\n/span\n\n\n\n\n\nCurrently, there are a few limitations to this feature:\n\n\n\n\nID-based scoping is not true component scoping and will affect elements of descendant components.\n\n\ncss\n can only be used with components and not on direct Ractive instances. This may change in the future.\n\n\n\n\nProgressive Enhancement\n\n\nTODO\n\n\nServer-side\n\n\nServer-side rendering can be achieved using \nractive.toHTML()\n and \nractive.toCSS()\n. Both methods render the instance and its descendants at their current state to HTML and CSS, respectively.\n\n\nconst Component1 = Ractive.extend({\n  data: {\n    message: ''\n  },\n  template: `\n    \ndiv class=\ncomponent1\n{{message}}\n/div\n\n  `,\n  css: `\n    .component1 { color: red }\n  `\n})\n\nconst Component2 = Ractive.extend({\n  data: {\n    greeting: ''\n  },\n  template: `\n    \ndiv class=\ncomponent2\n{{greeting}}\n/div\n\n  `,\n  css: `\n    .component2 { color: green }\n  `\n})\n\nconst App = Ractive.extend({\n  components: {\n    Component1,\n    Component2\n  },\n  data: {\n    greet: '',\n    msg: ''\n  },\n  template: `\n    \nComponent1 message=\n{{ msg }}\n /\n\n    \nComponent2 greeting=\n{{ greet }}\n /\n\n  `\n})\n\nconst state = { greet: 'Good Morning!', msg: 'Hello, World!' }\nconst app = App({ data: state })\nconst html = app.toHTML()\nconst css = app.toCSS()\n\n\n\n\nCurrently, there are a few limitations to this feature:\n\n\n\n\nractive.toHTML()\n prints HTML without component IDs while \nractive.toCSS()\n prints out selectors with component IDs, which causes the HTML and CSS to not match up.\n\n\nA workaround is to render the CSS as is by setting \nnoCssTransform\n to \ntrue\n and to use a CSS naming convention (i.e BEM, OOCSS, SMACSS) to match up selectors with their elements.\n\n\n\n\n\n\nractive.toHTML()\n does not automatically insert the document CSS when rendering a component that represents a full document. This must be done manually.\n\n\n\n\nSecurity\n\n\nUse of the Function constructor\n\n\nRactive uses the \nFunction\n constructor only to convert expressions (i.e. mustache expressions, expression-style computed properties) into value-generating functions. As of 0.9, \nallowExpressions\n initialization option is available to toggle the expression-to-function feature. Setting it to \nfalse\n will tell Ractive neither to parse nor process expressions.\n\n\nContent Security Policy\n\n\nOut of the box, Ractive will violate certain CSP directives due to the use of the \nFunction\n constructor for evaluating expressions, and dynamically generated \nstyle\n elements for Ractive-managed CSS.\n\n\nIn order to avoid violating \nscript-src\n, either:\n\n\n\n\nPre-parse templates. As of 0.8, the parser will store expressions as functions on the AST. To preserve the functions when serializing the AST, use libraries like \nnode-tosource\n or \nserialize-javascript\n instead of \nJSON.stringify()\n.\n\n\nSet \nallowExpressions\n initialization option to \nfalse\n. This will tell Ractive to avoid evaluating expressions.\n\n\nAdd the \nscript-src 'unsafe-eval'\n CSP directive. This will allow the use of the \nFunction\n constructor.\n\n\n\n\nIn order to avoid violating \nstyle-src\n, either:\n\n\n\n\nAdd \nstyle-src 'unsafe-inline'\n to your CSP directives. This will allow the use of dynamically generated \nstyle\n elements.\n\n\n\n\nTemplates\n\n\nStrictly speaking, Ractive templates are not HTML. They are markup representations of objects that are used to construct HTML. Simply put, templates are \nHTML-like\n. Ractive parses templates into \nAST\ns which contain everything Ractive needs to know to construct an instance's DOM, data bindings, events and transitions etc.\n\n\nRactive.parse('\ndiv class=\nmessage\nHello World!\n/div\n')\n\n// {\nv\n:4,\nt\n:[{\nt\n:7,\ne\n:\ndiv\n,\nm\n:[{\nn\n:\nclass\n,\nf\n:\nmessage\n,\nt\n:13}],\nf\n:[\nHello World!\n]}]}\n\n\n\n\nKeypaths\n\n\nA keypath is a kind of reference that represents the location of a piece of data.\n\n\nRactive({\n  data: {\n    foo: {\n      bar: {\n        baz: {\n          qux: 'Hello, World!'\n        }\n      }\n    }\n  },\n  template: `\n    {{ foo.bar.baz.qux }}\n  `\n})\n\n\n\n\nDot and bracket notations\n\n\nDot and bracket notation rules for keypaths are similar to vanilla JS. The only addition to this is that the dot notation can also be used to access arrays, by using the index directly on the segment.\n\n\nconst instance = Ractive({\n  data: {\n    items: [1, 2, 3],\n    foo: {\n      bar: {\n        baz: {\n          qux: 'Hello, World!',\n          'dotted.key': 'Me, Hungry!'\n        }\n      }\n    },\n    dynamicKey: 'bar'\n  },\n  template: `\n    {{ foo['bar']['baz']['qux'] }} \n!-- bracket notation object access --\n\n    {{ foo.bar.baz.qux }}          \n!-- dot notation object access --\n\n\n    {{ items[0] }} \n!-- bracket notation array access --\n\n    {{ items.0 }}  \n!-- dot notation array access --\n\n\n    {{ foo.bar.baz['dotted.key'] }} \n!-- dotted key access --\n\n\n    {{ foo[dynamicKey].baz.qux }} \n!-- dynamic key access --\n\n  `\n})\n\n\n\n\nMissing properties\n\n\nIn JavaScript, trying to access a child property of an object that does not exist would throw an error. In Ractive, it would simply return \nundefined\n or render nothing.\n\n\nconst instance = Ractive({\n  data: {\n    numbers: [ 1, 2, 3 ]\n  },\n  template: `\n    {{ letters[0] }}\n  `\n})\n\nractive.get( 'letters[0]' ) // undefined\n\n\n\n\nUpstream and downstream keypaths\n\n\nRactive has this concept of \"upstream\" and \"downstream\" keypaths. Upstream keypaths are ancestor keypaths. For the keypath \nfoo.bar.baz.qux\n, it's upstream keypaths are \nfoo\n, \nfoo.bar\n and \nfoo.bar.baz\n. Downstream keypaths are descendant keypaths. For the \nfoo\n keypath, it's downstream keypaths would be \nfoo.bar\n, \nfoo.bar.baz\n and \nfoo.bar.baz.qux\n.\n\n\nReferences\n\n\nA reference is a string that refers to a piece of data. A keypath is an example of a reference, one that points to a specific location in the data. Special references are also a form of reference, one that provides to a certain value.\n\n\nReference resolution\n\n\nRactive follows the following resolution algorithm to find the value of a reference:\n\n\n\n\nIf the reference is a special reference (\n/^@/\n), resolve with the matching special model.\n\n\nIf the reference is explicit (prefixed/relative) or matches a path in the current context exactly, resolve with the model relative to the current context.\n\n\nIf the reference keypath only has one key, see if it matches a helper, and if so, resolve with that model. If not, match with the base key for the rest of the steps e.g. \nfoo\n in \nfoo.bar.baz\n.\n\n\nGrab the current virtual node from the template hierarchy.\n\n\nIf the base matches an alias, section indexes, or keys, resolve with that model.\n\n\nIf the base matches a path on the context, resolve with the model relative to the context.\n\n\nRemove the innermost context from the stack. If there are still contexts left in the stack, goto 4.\n\n\nIf \nresolveInstanceMembers\n is true and the base matches an instance member, resolve with the path to the member.\n\n\nIf the reference is a valid keypath by itself, resolve with that keypath in the starting context.\n\n\n\n\nContext stack\n\n\nWhenever Ractive encounters section mustaches or similar constructs, it stores the context in a \ncontext stack\n. Ractive then resolves references relative to the top of the stack, and popping off contexts until the reference resolves to a keypath.\n\n\nRactive({\n  data: {\n    qux: 'Me, Hungry!',\n    foo: {\n      bar: {\n        baz: 'Hello, World!'\n      }\n    }\n  },\n  template: `\n                \n!-- context is the root of the data --\n\n    {{#foo}}    \n!-- context is now foo --\n\n      {{#bar}}  \n!-- context is now foo.bar --\n\n        {{baz}} \n!-- Resolution order: foo.bar.baz, foo.baz, baz. Resolved at foo.bar.baz. --\n\n        {{qux}} \n!-- Resolution order: foo.bar.quz, foo.qux, qux. Resolved at qux. --\n\n      {{/}}\n    {{/}}\n  `,\n})\n\n\n\n\nConditional attributes\n\n\nSections can toggle attributes, whether it's one attribute, multiple attributes or specific values of the attribute.\n\n\n!-- one attribute --\n\n\na href=\n/\n {{#if currentPage}}class=\nactive\n{{/if}}\nHome\n/a\n\n\n\n!-- multiple attributes --\n\n\na href=\n/\n {{#if currentPage}}class=\nactive\n title=\nCurrent page\n{{/if}}\nHome\n/a\n\n\n\n!-- specific attribute value --\n\n\na href=\n/\n class=\nnav-link {{#if currentPage}}nav-link--active{{/if}}\nHome\n/a\n\n\n\n\n\nOptimization\n\n\nPre-parsing\n\n\nParsing templates can be a very slow operation. As an optimization option, templates can be pre-parsed outside of runtime, speeding up app initialization. Most loaders do pre-parsing of templates as part of their build process. A parsed template is approximately 30-40% larger than the markup version, making it a trade-off between space and processing.\n\n\nLimiting template expressions\n\n\nWhile expressions provide power and convenience when building templates, it incurs a performance penalty as Ractive sets up each one on a per-instance level. To avoid this overhead, there are several places where logic can move to, trimming down expressions into mere function calls.\n\n\nFunctions can be set on the data globally via \nRactive.defaults.data\n.\n\n\nRactive.defaults.data.customLogic = function () { ... }\n\nRactive({\n  template: `\n    {{ customLogic() }}\n  `\n})\n\n\n\n\nFunctions can also be defined on a component level using methods.\n\n\nconst Component = Ractive.extend({\n  template: `\n    {{ @this.customLogic() }}\n  `,\n  customLogic () {\n    ...\n  }\n})\n\n\n\n\nExpression processing\n\n\nWhen Ractive parses a template, it creates a string representation of the expression structure and keeps track of its dependencies. Then Ractive converts these expression strings into a function which can be called to generate the expression's value.\n\n\nRactive optimizes this routine starting by generating the same expression string for structurally-identical expressions. Then a value-generating function is created for each \ndistinct\n expression string, cached globally and shared to all instances. Furthermore, Ractive caches the generated values and only updates them when the expression's dependencies update.\n\n\n// Expression parsing\nRactive.parse('{{ a + b }}{{ c + d }}')\n\n// {\n//   \nv\n: 4,\n//   \nt\n: [\n//     {\n//       \nt\n: 2,\n//       \nx\n: {\n//         \nr\n: [\na\n,\nb\n], \n-- dependencies here\n//         \ns\n: \n_0+_1\n    \n-- expression string here\n//       }\n//     },\n//     {\n//       \nt\n: 2,\n//       \nx\n: {\n//         \nr\n: [\nc\n,\nd\n], \n-- dependencies here\n//         \ns\n: \n_0+_1\n    \n-- expression string here\n//       }\n//     }\n//   ],\n//   \ne\n: {}\n// }\n\n// Building and caching of the expression resolver of `_0+_1`\nconst expressionFunctionsCache = {}\nexpressionFunctionsCache['_0+_1'] = new Function('_0', '_1', 'return _0+_1')\n\n// Evaluate {{ a + b }}\nconst dep = ['a', 'b']\nconst exp = '_0+_1'\nconst arg = dep.map(instance.get)\nconst val = expressionFunctionsCache[exp].apply(instance, arg)\n\n// Evaluate {{ c + d }}\nconst dep = ['c', 'd']\nconst exp = '_0+_1'\nconst arg = dep.map(instance.get)\nconst val = expressionFunctionsCache[exp].apply(instance, arg)\n\n\n\n\nThe \nFunction\n constructor was chosen over \neval\n because it allows Ractive to compile the expression string \nonce\n as well as \ncache\n the resulting function, instead of evaluating the string every time the value is needed.", 
            "title": "Concepts"
        }, 
        {
            "location": "/concepts/#architecture", 
            "text": "There are three major sections in the Ractive source code: The parser which handles template parsing, the models which handle data management and the views which handle the virtual DOM. This document aims to give a breakdown of just what exactly each of these sections do.", 
            "title": "Architecture"
        }, 
        {
            "location": "/concepts/#parser", 
            "text": "Ractive's parser is reponsible for taking in Mustache-like/Handlebar-like templates. Unlike Mustache and Handlebars, however, it turns them into an  AST  for use by the runtime. In addition, it also supports a fair amount of ES syntax for use in expressions.  Each item expressable in Ractive-flavored mustache has its own parsing function that may also be comprised of other parsing functions. Each bit of ES syntax that Ractive understands for expressions also has its own parsing function. The parser starts at the beginning of the template string and starts applying each parsing function in precedence order. Each function will then consume as much of the template as needed to return an item, like an element, a section, a partial, a bit of text, or an interpolator. It may also return nothing. Most items can also contain children, including items of the same type as themselves, and will thus recurse by trying to parse their content.", 
            "title": "Parser"
        }, 
        {
            "location": "/concepts/#mustaches", 
            "text": "Each type of mustache has its own reader that calls the appropriate expression or reference readers internally. For instance, the partial reader reads the current open mustache delimiter (defaults to  {{ ) followed by a  . It then expects to find a relaxed reference, meaning it may contain dashes and slashes among other usually-forbidden characters. It may then optionally read a context expression or series of alias definitions", 
            "title": "Mustaches"
        }, 
        {
            "location": "/concepts/#expressions", 
            "text": "The expression readers are set arranged such that they can read valid ES expressions with the correct operator precedence by starting with ternary conditionals and trying different expression types from there. Once the expression tree has been parsed, it is flattened into an expression string and a list of references that are used within that string. If the parsing is done with  csp  (Content Security Policy) support enabled, then the expression strings are also turned into functions and attached to the output template structure so that the template can be used as-is from a script tag without  eval ing.", 
            "title": "Expressions"
        }, 
        {
            "location": "/concepts/#cleanup", 
            "text": "After all of the nodes have been parsed from the template, the template is cleaned up in a process that, among other things, merges adjacent text nodes and forms individual conditional sections out of  elseif / else  trees.", 
            "title": "Cleanup"
        }, 
        {
            "location": "/concepts/#models", 
            "text": "Ractive wraps any data given to it into a tree-like hierarchy of  Model . Any data that is rendered into a template will be bound to a  Model . Access to read and write data in Ractive is handled through the model hierarchy based on keypaths, which are, generally, a list of object properties that one would need to follow to reach a leaf of the data tree starting from the root. Each key along the keypath has its own corresponding model.  Models allow entities that depend upon them to register themeselves to receive change notifications when the model value changes. This is how Ractive keeps track of exactly which parts of the view need to be updated when values change.  All of the data managed by Ractive is represented by its model hierarchy.  Almost every type of Model is a subclass of  Model , so it seems a good place to start. Each model typically has a parent model, a key that is used to access its value from its parent, and a value. Most models also have children of some sort, which are tracked by key such that  { foo: { bar: 'baz' } }  would have a model with a  childByKey['foo'] , which would also have a model at  childByKey['bar'] . The value of each of the models listed there would be the object containing  foo: { bar: baz } , its  foo  child would be the object  bar: 'baz' , and its  bar  child would be the string  'baz' . Where children of a model are other models, dependents ( deps ) of a model may be anything that wants to be notified of changes, and each model will typically have a number of dependents, too.  Each model has a unique keypath that is assembled by taking its key and each of its parents keys up to the root and joining them with a  . .  Models are also inherently lazy, meaning their value is not necessarily available when the are created. A value is retrieved from a model using its  get  method which may have the side effect of computing the value. Once a value has been computed, it is generally cached until a change happens that would cause the cache to be invalidated. In most models, there isn't really an opportunity for that change outside of normal change propagation.", 
            "title": "Models"
        }, 
        {
            "location": "/concepts/#rootmodel", 
            "text": "Every tree needs a root, and  RootModel  serves that purpose here. Each Ractive instance gets its own  RootModel  that is stored at its  viewmodel  property. This special model is also the storage point for computations and mappings.", 
            "title": "RootModel"
        }, 
        {
            "location": "/concepts/#keymodel", 
            "text": "The last major model remaining is the  KeyModel . Instances of this represent indices of arrays and keys of objects during iteration. The key flavor never is immutable, becuase the keys of  objects never change (they may be removed, but that doesn't change the key itself). The index flavor  does  change, but only when the array represented by its parent model is shuffled.", 
            "title": "KeyModel"
        }, 
        {
            "location": "/concepts/#other-models", 
            "text": "There are a few other types of  Model  in the code, such as the  RactiveModel , which represents a Ractive instance, and the  GlobalModel , which represents the global object of the current environment a.k.a.  window  for browsers and  global  for Node.js.", 
            "title": "Other models"
        }, 
        {
            "location": "/concepts/#model-operations", 
            "text": "", 
            "title": "Model operations"
        }, 
        {
            "location": "/concepts/#change-propagation", 
            "text": "When a change is supplied to a model, its  set  method is called, which usually delegates to  applyValue .  applyValue  checks to see that the value has actually changed in some way (hint: setting to the same object or array is considered a change because something may have changed further in), and if it has, it will start change notification for all of the model's children and dependents. If the model has resolvers registered with it trying to get an unresolved value, then this is where the unresolved value will be resolved and the resolver satisfied and cleared. Next, any children will be notified that their parent has had a value change and that they may need to update accordingly, which may trigger further cascades of resolution and change notification. Next, any dependents of the model will be notified that the model has had a value change as their  handleChange  methods are called. Finally, upstream models (parents) are notified that a change has taken place somewhere among its children.  The child notification of the propagation is handled by the model's  mark  method.  mark  also checks to see that the value has actually changed, and if it has, will notify its children and dependents that it has had a value change. This is also the method called when the user signals that they have changed some data externally by calling  ractive.update() .", 
            "title": "Change propagation"
        }, 
        {
            "location": "/concepts/#shuffling", 
            "text": "There is a special form of change wherein an array is modified without being swapped out, which is triggered by array methods like  splice ,  push , and  pop . When an array modification happens, change propagation takes a special path through the model that allows more precise DOM manipulation rather than throwing all of the DOM out and replacing it with a new result. This is achieved by having the special array method handlers compute which indexes are actually changed and having the array model's deps that can actally handle a shuffle ignore any untouched indices.  The instance method  merge  does something similar, but instead of modifying the underlying array, it compares the members of the new supplied array against the model array to compute the index changes. It the swaps in the new array and triggers a shuffle based on the computed index changes.", 
            "title": "Shuffling"
        }, 
        {
            "location": "/concepts/#adaptation", 
            "text": "Between the change check and the change propagation during  applyValue , there is a step that handles part of adaptation so that external objects with special behaviors, like backbone models, can be used as data sources. An adaptors takes the special object, wraps it up, and returns the wrapper that also has a value that represents the object for consumption by Ractive. Most adaptors also have methods to update values in their source data as well, and those methods are called when an update is applied to an adapted model.", 
            "title": "Adaptation"
        }, 
        {
            "location": "/concepts/#computations", 
            "text": "A computation is exactly what is sounds like: a getter and optional setter function that are used to provide read and optional write access to some non-fixed piece of data. Each computation is stored in the root model  computations  hash by its keypath. Computations can be created in two places:   Explicitly when a  computed  map is passed to a Ractive instantiation or when an entry is later added to a instance's computed map. These may be read/write and have a keypath that mirrors their name.  Implicitly when an expression is used in a template. These are read-only and have a keypath that is an expanded representation of their expression.   A computation is also a form of model, so anything that depends on it will subscribe to it as if it were a regular model. Change propagation happens in the same way as a regular model as well.  Since computations may depend on other bits of data controlled by Ractive, while they are being retrieved, any references to other models will cause the extra references to be  capture d. When the computation is complete, the computation will register with each of its captured dependencies so that it will be notified when it needs to invalidate and notify its dependents of the change.", 
            "title": "Computations"
        }, 
        {
            "location": "/concepts/#mappings", 
            "text": "When a Ractive instance has children, typically components, it may supply a handles to its own data to them in the form of mappings. The child instance stores a reference to the parent model at its mapped name and uses it when its dependents request access to keypaths that start with the mapped name. This allows child instances, which may be isolated, to stay in sync with portions of their parents data easily, because the parent still controls the data (single source of truth) and there is no syncing involved. So if a parent has a component  Component foo=\"{{bar.baz.bat.bippy}}\" / , then the component instance will get a mapping  foo  that references the parent model at  bar.baz.bat.bippy .", 
            "title": "Mappings"
        }, 
        {
            "location": "/concepts/#virtual-dom", 
            "text": "Every piece of DOM that Ractive can manage has a corresponding class in the virtual DOM to handle the DOM node, which generally end up being either Elements or Text Nodes. View items are grouped together as Fragments of view, which may then be owned by other fragments or items. At the root of every ractive instance is a Fragment instance that contains its entire virtual DOM tree. Each Ractive template construct has at least one analog in the virtual DOM. The bulk of Ractive's view functionality is implemented in the Section, Interpolator, and Element items, with there being a number of specialized element classes to handle special types of HTML element.  All virtual DOM items go through roughly the same lifecycle: creation, binding, rendering, bubbling, updating, unrendering, and unbinding. Creation is basically just the constructor call and almost always is immediately followed by binding. Binding is the point at which the item resolves and registers with its data references. Rendering is the point at which the item inserts an actual DOM node into the DOM. Bubbling and updating are the two halves of the update process, which is discussed in the next section. Unrendering is the point at which the item should no longer be present in the DOM, and it often occurs at the same point as unbinding, which is the point at which the item unregisters with the viewmodel and is effectively destroyed.  There a number of other members, such as events and decorators, and processes, such as change propagation, which are described in detail in the view overview.  Ractive views are structured virtual DOM trees that are assembled from template AST and manage DOM nodes on the page when they are rendered. Virtual DOM items are grouped together in  Fragment s, which contain them, and they may also own  Fragment s that contain other items. Each item may contain a reference to a DOM node when rendered, though every item doesn not have a DOM analog.", 
            "title": "Virtual DOM"
        }, 
        {
            "location": "/concepts/#parallel-dom", 
            "text": "Ractive works by maintaining a simplified model of the part of the DOM that it's responsible for. This model contains all the information - about data-binding, event handling and so on - that it needs to keep things up-to-date.  You can inspect the parallel DOM to understand what's going on under the hood, if you're into that sort of thing. Each Ractive instance, once rendered, has a  fragment  property. Each fragment has a number of properties:   contextStack  - the context stack in which mustache references should be evaluated  root  - a reference to the Ractive instance to which it belongs  owner  - the  item  that owns this fragment (in the case of the root fragment, the same as  root )  items  - the items belonging to this fragment   Items  means elements, text nodes, and mustaches. Elements may have fragments of their own (i.e. if they have children). A partial mustache will have a fragment, and a section mustache will have zero or more fragments depending on the value of its keypath.  Elements may also have attributes, which have a different kind of fragment (a  text fragment  as opposed to a  DOM fragment ), containing text and mustaches.  Each item has a  descriptor , which is something like DNA. This comes straight from the parsed template.  This is the briefest of overviews - if you want to gain a deeper understanding of what's going on under the hood,  use the source .", 
            "title": "Parallel DOM"
        }, 
        {
            "location": "/concepts/#states", 
            "text": "Items generally follow a fixed lifecycle.   Construction - the item is created and knows about its parent and the template chunk from which it was created. Its template may also indicate what its children should look like if it has them.  bind  - the item looks up any references is may have and registers with the model(s) that they represent. At this point, the item may create child items and bind them as well.  render  - the item may create an actual DOM node and tell its children to create their DOM nodes as necessary. The resulting nodes will be inserted into the document.  unrender  - thie item is no longer needed and will be removed from the document immediately or in the near future.  unbind  - this typically goes along with  unrender  and tells the models on which this item depends that they should no longer send change notifications to it.   There is a sixth floating step  rebind  that happens any time one dependency models shuffles (and in certain other very special circumstances) that causes the items to re-resolve their models and re-register if necessary.", 
            "title": "States"
        }, 
        {
            "location": "/concepts/#virtual-dom-items", 
            "text": "", 
            "title": "Virtual DOM Items"
        }, 
        {
            "location": "/concepts/#text", 
            "text": "Text is the simplest item. It simply holds a string that it turns into a  TextNode  when rendered.", 
            "title": "Text"
        }, 
        {
            "location": "/concepts/#interpolator", 
            "text": "This is the next simplest item. It resolves a model for its reference or expression and renders the value of the model as a text node if needed. Interpolators don't necessarily render directly, as they may be used for values by other items, such as attributes, mappings, and bindings.", 
            "title": "Interpolator"
        }, 
        {
            "location": "/concepts/#element", 
            "text": "An  Element  represents a DOM element. It also contains a number of other items in the form of  Attribute s,  Decorator s,  Transition s,  EventDirective s, and its children in a  Fragment .", 
            "title": "Element"
        }, 
        {
            "location": "/concepts/#attributes", 
            "text": "There are actually several different items that are treated as attributes for  Element s, event though only two of them actually may render into the DOM.   Attribute s - maybe obvious, they these represent a DOM attribute on their parent element. There are a number of different handlers for updating attributes depending on the element and attribute name. The  updateDelegate  for a particular attribute can be found in  getUpdateDelegate.js .  ConditionalAttribute s - render as a string and are parsed into actual DOM attributes using a  div  or an  svg  depending on their parent element.  Mapping s - when rendered add a mapping to their component, and when unrendered, remove it. These aren't attached to  Element s, but instead, are attached to  Component s (see below).  EventDirective s - when rendered attach an event listener to their parent, and when unrenedered, remove it. Event parameters are kept in sync with their bindings and are evaluated when the event fires.  BindingDirective s - when rendered and unrendered update their parent element's bindings, if they exist.  Decorator s - when rendered call the named decorator with their parent element, and when unrenedered, remove it.  Decorator s also have an update cycle related to their parameters.  Transition s - are a sort of weird case. When rendered, they attach a transition handler to their element, and when the element renders or unrenders, if an appropriate transition handler is registered, will trigger the transition. Transition parameters are also kept in sync with their bindings.", 
            "title": "Attributes"
        }, 
        {
            "location": "/concepts/#bindings", 
            "text": "Certain attributes may also trigger a binding to be created on their parent element. For instance, if two-way binding is enabled on the parent element, and the parent element is an  input , a  value  attribute with a single  Interpolator  as its content will cause a two-way binding to be created between the value of the  input  and the model of the  Interpolator . This binding will handle updating the model when the input  value  has changed. There are a few other types of bindings for managing check values, content editables, name-bound lists of checkboxes, and other miscellaneous special values.  A  lazy  binding directive will cause any associated two-way bindings to fire either after a timeout or on blur, depending on the value of the  lazy  directive.", 
            "title": "Bindings"
        }, 
        {
            "location": "/concepts/#section", 
            "text": "Section s come in many flavors, depending on the chunk of template from which they are created. A section may provide context, be conditional (positive or negative), or be iterative. Generic sections ( {{#something}}...{{/}}  in template) will adjust their type, to a certain extent, based on the value of their model. A generic section will always provide context in the form of their model. An  if -style conditional section, including  elseif ,  else , and  unless  do not provide context. An  each  section will always provide context in the form of the current iteration. A  with  section will always provide context as its model, but it will only render if its model is considered truthy by Ractive, which is pretty much the same as JS truthy except  {}  and  []  are falsey. A generic section will be context/conditional if it is anything other than an array, which will make it iterative.  Sections that provide context do so by binding their  Fragment s with their model so that the reference resolution process can find the appropriate contexts when resolving.", 
            "title": "Section"
        }, 
        {
            "location": "/concepts/#contextconditional", 
            "text": "Context and conditional sections will render and unrender their child fragment as their model changes truthiness. Conditional sections always stand alone, even it they have  elseif  or  else  branches nested within them, because those branches are turned into independent sections during parsing.", 
            "title": "Context/Conditional"
        }, 
        {
            "location": "/concepts/#iterative", 
            "text": "If section is designated iterative ( {{#each ...}} ) or is a general section with an array value resolution, the section will create a special form of fragment for each index or key in the value. The special form  RepeatedFragment  handles mapping of indices, keys, and references to those to a corresponding model. Iterative sections also have special handling for shuffles so that DOM is not wholesale destroyed and recreated when the array shuffles.  Iterative sections may supply an alias for their context, so that referencing the iterated value is a little bit easier. See  Aliases  below for more info, as this is just a slightly specialized form of that.  Iterative sections may also supply key and/or index aliases so that their keys and/or indices may be referenced by a name from within their child fragments.", 
            "title": "Iterative"
        }, 
        {
            "location": "/concepts/#alias", 
            "text": "Alias sections simply resolve their models and act as a lookup endpoint for reference resolution. Aliasing happens entirely in the view.", 
            "title": "Alias"
        }, 
        {
            "location": "/concepts/#component", 
            "text": "A component is a sort-of special form of  Element  that, instead of creating a DOM element, creates a new Ractive instance. The child instance will be rendered and unrendered in place of the component placeholder in the DOM.  Any plain  Attribute s with a single  Interpolator  as content in a component's template are turned into  Mapping s.  The resolution process no longer happens strictly within the vDOM, as the result of  Ractive.getContext  also uses the target  Element 's fragment to resolve relative references. Event objects are also extended with methods from the same helper.", 
            "title": "Component"
        }, 
        {
            "location": "/concepts/#updates", 
            "text": "The  runloop  controls when the DOM is actually updated and when transitions start in  batch es. It also handles resolving promises when transitions have completed and the DOM is completely up to date.  As changes propagate through the viewmodel, view items are notified of the change through their  handleChange  method. Most items just set a dirty flag and notify their parent, via their  bubble  method, that they will need to be updated at the completion of the runloop turn. The root fragment of each instance affected will then register with the runloop. Once the changes are ready to be flushed to the view, each fragment registered with the runloop is called on to update, where the process happens in reverse, with each parent fragment checking to see if there is a change it needs to respond to and propagating the update downward to its children.", 
            "title": "Updates"
        }, 
        {
            "location": "/concepts/#data-management", 
            "text": "", 
            "title": "Data management"
        }, 
        {
            "location": "/concepts/#dependents", 
            "text": "Ractive maintains a dependency graph in order to do only the minimum amount of work necessary to keep the DOM up-to-date. If you inspect a Ractive instance, you'll see a property called  _deps . This is where all dependants are listed, indexed by their dependency.", 
            "title": "Dependents"
        }, 
        {
            "location": "/concepts/#expression-dependencies", 
            "text": "Ractive uses dynamic analysis to determine dependencies. Depedendencies are determined by capturing references in the viewmodel while the function is executing. Dependencies for functions are re-captured each time the function is executed.  p {{ formattedName() }} /p   var ractive = Ractive({\n  template: template,\n  el: output,\n  data: {\n    user: { firstName: 'John', lastName: 'Public' },\n    formattedName () {\n      return this.get('user.lastName') + ', ' + this.get('user.firstName')\n    }\n  }\n}  Result:  p Public, John /p   In this example, the function  formattedName  will depend on both  user.firstName  and  user.lastName , and updating either (or  user ) will cause any expressions referencing  formattedName  to be re-evaluated as well.  ractive.set('user.firstName', 'Jane')  Result:  p Public, Jane /p", 
            "title": "Expression dependencies"
        }, 
        {
            "location": "/concepts/#priority", 
            "text": "Ractive runs updates based on priority. For instance, when a subtree of the DOM needs to be removed while at the same time updates are pending for that subtree. What Ractive does is prioritize the removal of the subtree over the updates. This causes the dependents on the subtree to unregister themselves, eliminating the need to update, resulting with only the removal operation being done.", 
            "title": "Priority"
        }, 
        {
            "location": "/concepts/#indirect-dependencies", 
            "text": "If you have a mustache which depends on  foo.bar , and  foo  changes, it's quite possible that the mustache needs to re-render. We say that the mustache has an  indirect dependency  on  foo , or that it has a  direct dependency on a downstream keypath  of  foo .  This relationship is expressed through the  _depsMap  property of a Ractive instance - whenever  foo  changes, as well as dealing with direct  foo  dependants we check the map for those indirect dependants.  In the case of expressions and observers, we also need to consider dependants of  upstream keypaths . For example, suppose we have a section based on a sorted array - if we modify one of the members of the array, we need to see if the sort order has changed or not as a result:  {{#( sort( list, 'name' ) )}}\n   p {{name}} /p \n{{/()}}  ractive = Ractive({\n  el: myContainer,\n  template: myTemplate,\n  data: {\n    list: [{ name: 'Bob' }, { name: 'Charles' }, { name: 'Alice' }],\n    sort ( list, property ) {\n      return list.slice().sort( function ( a, b ) {\n        return a[ property ]   b[ property ] ? -1 : 1\n      })\n    }\n  }\n})\n\n// renders Alice, Bob, Charles\n\nractive.set( 'list[0].name', 'Zebediah' )\n\n// updates to Alice, Charles, Zebediah  In the example, setting  list[0].name  causes dependants of  list  to be updated.  As well as expressions, Observers respond to both upstream and downstream changes.", 
            "title": "Indirect dependencies"
        }, 
        {
            "location": "/concepts/#expressions-with-multiple-dependencies", 
            "text": "The expression  {{ a + b }}  has two dependencies -  a  and  b  (or more accurately, whatever those references resolve to). The  _deps  graph actually includes objects representing those individual references, rather than the expression itself - the reference objects then notify the expression (if their value has changed) that it will need to re-evaluate itself.  Because the expression has multiple dependencies, it won't trigger an update straight away - it will wait until all the new data has come in first. So doing  ractive.set({ a: 1, b: 2 })  will only trigger one update, not two.", 
            "title": "Expressions with multiple dependencies"
        }, 
        {
            "location": "/concepts/#two-way-binding", 
            "text": "Two-way binding allows data to update bi-directionally, from data to the UI and vice versa.   Ractive({\n  data: {\n    msg: 'Hello, World!'\n  },\n  template: `\n     input type= text  value= {{ msg }}  {{ msg }}\n\n     button on-click= @this.set('msg', 'Lorem Ipsum') To lipsum /button \n  `\n})  Two-way binding can be disabled via the  twoway  initialization option or the  twoway  input directive.", 
            "title": "Two-way binding"
        }, 
        {
            "location": "/concepts/#ambiguous-references", 
            "text": "An ambiguous reference refers to a reference whose data does not exist at the time of construction. Ractive must make an assumption, following a resolution algorithm, on what ambiguous references resolve to. Until a suitable keypath pops into existence, ambiguous references resolve to  undefined .   Ractive({\n  data: {},\n  template: `\n     input value= {{ msg }}  {{ msg }}\n  `,\n})  Ambiguous references can be locked to a specific keypath, skipping the whole resolution process, using keypath prefixes.", 
            "title": "Ambiguous references"
        }, 
        {
            "location": "/concepts/#lazy-updates", 
            "text": "By default, Ractive uses various events (i.e.  change ,  click ,  input ,  keypress ) to listen for changes on interactive elements and immediately update bound data. In cases where data updates should only take place after the element loses focus, Ractive also supports lazy updating.   Ractive({\n  lazy: true,\n  data: {\n    msg: ''\n  },\n  template: `\n     div Type and click outside the input /div \n     input type= text  value= {{ msg }}  {{ msg }}\n  `\n})  Lazy updates can be enabled via the  lazy  initialization option or the  lazy  directive.", 
            "title": "Lazy updates"
        }, 
        {
            "location": "/concepts/#computed-properties", 
            "text": "Computed properties are top-level pseudo-data references whose value is defined by a computation and which automatically update when its dependencies update.", 
            "title": "Computed Properties"
        }, 
        {
            "location": "/concepts/#function-syntax", 
            "text": "The function syntax defines a computed property as a function that returns the computed value. The context of the function is the current instance.   Ractive({\n  data: {\n    width: 200,\n    length: 300\n  },\n  computed: {\n    area () {\n      return this.get('width') * this.get('length')\n    }\n  },\n  template: `\n    Width:  input type= text  value= {{ width }} \n    Length:  input type= text  value= {{ length }} \n    Area: {{ area }}\n  `\n})", 
            "title": "Function syntax"
        }, 
        {
            "location": "/concepts/#expression-syntax", 
            "text": "The expression syntax defines a computed property as a string containing a JavaScript expression.  ${}  is replaced internally with a  ractive.get() , using its contents as a keypath.   Ractive({\n  data: {\n    width: 200,\n    length: 300\n  },\n  computed: {\n    area: '${width} * ${length}'\n  },\n  template: `\n    Width:  input type= text  value= {{ width }} \n    Length:  input type= text  value= {{ length }} \n    Area: {{ area }}\n  `\n})", 
            "title": "Expression syntax"
        }, 
        {
            "location": "/concepts/#accessor-syntax", 
            "text": "Both function and expression syntaxes only describe retrieval of the computed property's value, and therefore makes the computed property read-only. The accessor syntax defines a computed property by providing  get  and  set  methods.  get  is called to retrieve its value and  set  is called when something updates its value.   Ractive({\n  data: {\n    side: 200\n  },\n  computed: {\n    area: {\n      get () {\n        return Math.pow(this.get('side'), 2)\n      },\n      set(v) {\n        this.set('side', Math.sqrt(v))\n      }\n    }\n  },\n  template: `\n    Side:  input type= text  value= {{ side }} \n    Area:  input type= text  value= {{ area }} \n  `\n})  Both function and expression syntaxes are supported for the  get  method.", 
            "title": "Accessor syntax"
        }, 
        {
            "location": "/concepts/#observers", 
            "text": "", 
            "title": "Observers"
        }, 
        {
            "location": "/concepts/#nested-properties", 
            "text": "Observers observe  upstream  and  downstream  keypaths. This allows observers to execute when data is updated indirectly, whether if it's the enclosing structure or a descendant structure.   const instance = Ractive({\n  data: {\n    foo: {\n      bar: 1\n    }\n  },\n  observe: {\n    'foo' (newValue) {\n      console.log('foo changed to', newValue)\n    },\n    'foo.bar' (newValue) {\n      console.log('foo.bar changed to', newValue)\n    }\n  }\n})\n\ninstance.set('foo.bar', 2)\ninstance.set('foo', { bar: 3 })  Observers can be set to only execute on the specified keypath via the  strict  option for both  observe  initialization option and  ractive.observe() .", 
            "title": "Nested properties"
        }, 
        {
            "location": "/concepts/#wildcards", 
            "text": "Wildcards allow observers to observe keypaths whose segments cannot be determined in advance. This is useful when observing an array, observing items within an array, or observing changes on object properties.   const instance = Ractive({\n  data: {\n    people: [\n      {name: 'Rich Harris'},\n      {name: 'Marty Nelson'}\n    ],\n    config: {\n      allowComments: true,\n      allowEdit: false\n    }\n  },\n  observe: {\n    // Observe changes on the array\n    'people.*' () {\n      console.log('array observer', arguments)\n    },\n    // Observe changes on the name property of any item in the array\n    'people.*.name' () {\n      console.log('array item observer', arguments)\n    },\n    // Observe changes on any property of an object\n    'config.*' () {\n      console.log('object property observer', arguments)\n    }\n  }\n})\n\ninstance.push('people', {name: 'Jason Brown'})\ninstance.set('people.3', {name: 'Jack Black'})\ninstance.set('config.allowEdit', true)", 
            "title": "Wildcards"
        }, 
        {
            "location": "/concepts/#multiple-sources", 
            "text": "Multiple keypaths can be observed by adding them one after the other, separating them with a space.   const instance = Ractive({\n  data: {\n    user: {username: 'browniefed'},\n    config: {isAdmin: false},\n    commentCount: 0\n  },\n  observe: {\n    'user.username config.isAdmin commentCount' () {\n      console.log('data changed', arguments)\n    }\n  }\n})\n\ninstance.set('user.username', 'chris')\ninstance.set('config.isAdmin', true)\ninstance.set('commentCount', 42)", 
            "title": "Multiple sources"
        }, 
        {
            "location": "/concepts/#caveats", 
            "text": "Observers do not defensively clone the old and new values as identity of these values may be essential. Thus, observers on non-primitive values may result in having identically equal old and new values.   const instance = Ractive({\n  data: {\n    config: {\n      allowComments: true,\n      allowEdit: false\n    }\n  },\n  observe: {\n    'config' (newValue, oldValue) {\n      console.log(newValue === oldValue)\n    }\n  }\n})\n\ninstance.set('config.allowEdit', true)  Both  observe  initialization option and  ractive.observe()  accept an  old  option which allows you to define the old value passed to the observer prior to modifications.", 
            "title": "Caveats"
        }, 
        {
            "location": "/concepts/#components", 
            "text": "", 
            "title": "Components"
        }, 
        {
            "location": "/concepts/#mappings_1", 
            "text": "Mappings connect pieces of data on the enclosing instance to data on enclosed instances. Changes on one side will reflect on the other.  Ractive.components.MyComponent = Ractive.extend({\n  data: {\n    message: ''\n  },\n  template: `\n     input type= text  value= {{ message }} \n  `\n})\n\nconst instance = Ractive({\n  el: 'body',\n  data: {\n    text: ''\n  },\n  template: `\n     MyComponent message= {{ text }} / \n  `\n})\n\nractive.set('text', 'Hello World!')  In the example above,  text  on the instance is mapped to  MyComponent 's  message . Updates on  text  will update  message  and any UI elements bound to it. Updates on  message , like editing the  input  bound with it, will update  text .", 
            "title": "Mappings"
        }, 
        {
            "location": "/concepts/#data-context", 
            "text": "Each component instance comes with its own data context so that its data does not pollute the primary data. Any mapping between the component and the enclosing instance will still update across both contexts.  Ractive.components.MyComponent = Ractive.extend({\n  data: {\n    shades: '',\n    option: ''\n  }\n})\n\nconst instance = Ractive({\n  template: `\n     MyComponent shades='{{colors}}' option='A' / \n  `,\n  data: {\n    name: 'Colors',\n    colors: ['red', 'blue', 'yellow']\n  }\n})\n\nconst widget = ractive.findComponent('MyComponent')\n\nractive.get() // { colors :[ red , blue , yellow ],  name : Colors }\nwidget.get()  // { shades :[ red , blue , yellow ],  option : A }\n\nractive.set('colors.1', 'green')\n\nractive.get() // { colors :[ red , green , yellow ],  name : Colors }\nwidget.get()  // { shades :[ red , green , yellow ],  option : A }  In the example above, the enclosing instance data holds  name  and  colors .  colors  is mapped to  shades  and  option  is set on an instance of  MyComponent . Upon inspection,  name  from the enclosing instance does not cross over to  MyComponent  nor does  option  cross over to the enclosing instance. However, since  colors  on the instance is mapped to  shades  on the component, any modifications on either side will reflect on the other.", 
            "title": "Data context"
        }, 
        {
            "location": "/concepts/#isolation", 
            "text": "By default, components are \"isolated\". Descendant components can update ancestor data only when there is an explicit mapping between them. This avoids unintended mutation of ancestor data and ensures portability of components.  Ractive.components.ChildComponent = Ractive.extend({\n  template: 'Message missing {{ message }}'\n})\n\nconst instance = Ractive({\n  el: 'body',\n  template: ' ChildComponent / ',\n  data: {\n    message: 'The ChildComponent will not know anything about this message'\n  }\n})  In the example above,  ChildComponent  will not print anything since  message  is not defined in the component and due to isolation, the component cannot see the instance's  message .  Isolation can be disabled via the  isolated  initialization option.", 
            "title": "Isolation"
        }, 
        {
            "location": "/concepts/#event-management", 
            "text": "Like many other libraries, Ractive implements its own  publish/subscribe  mechanism for triggering and responding to particular events. One of the advantages of using Ractive-managed events is that events are automatically unsubscribed and unreferenced once the instance is torn down, avoiding the need to do manual housekeeping.", 
            "title": "Event Management"
        }, 
        {
            "location": "/concepts/#sources", 
            "text": "", 
            "title": "Sources"
        }, 
        {
            "location": "/concepts/#event-api", 
            "text": "Events that are published as a result of using the event APIs directly (i.e.  ractive.fire ). Most of the other event sources use the event APIs to publish events at some point in their operation.  instance.fire('someevent', 'Hello, World!')", 
            "title": "Event API"
        }, 
        {
            "location": "/concepts/#lifecycle-events", 
            "text": "Lifecycle events are events that are published by an instance during the different phases of its existence. Ractive instances publish the following lifecycle events:   construct  config  init  render  complete  update  insert  detach  unrender  teardown  destruct   Lifecycle event names are reserved. They should not be used as names of other events.", 
            "title": "Lifecycle events"
        }, 
        {
            "location": "/concepts/#dom-events", 
            "text": "DOM events are events that are published by the DOM.  button on-click= ...", 
            "title": "DOM events"
        }, 
        {
            "location": "/concepts/#custom-events", 
            "text": "Custom events are events that are published by event plugins.  img on-tap= ...", 
            "title": "Custom events"
        }, 
        {
            "location": "/concepts/#component-events", 
            "text": "Component events are events that are published by  components .  MyModal on-close= ...  /", 
            "title": "Component events"
        }, 
        {
            "location": "/concepts/#handling", 
            "text": "", 
            "title": "Handling"
        }, 
        {
            "location": "/concepts/#event-api_1", 
            "text": "Events published from the direct use of the event APIs are also handled by directly using the event APIs (i.e.  ractive.on ,  ractive.once ). Most of the other handling methods use the event APIs to handle events at some point in their operation.  instance.on('someevent', (context, message) =  {\n  console.log(message)\n})", 
            "title": "Event API"
        }, 
        {
            "location": "/concepts/#lifecycle-events_1", 
            "text": "Lifecycle events are handled by assigning a function to the appropriate lifecycle event initialization option.  Ractive({\n  onrender () {\n    console.log('instance has been rendered')\n  }\n})  The event APIs can also subscribe to lifecycle events. However, the handler must subscribe prior to the event publishing. Using the lifecycle event initialization options is the safer option to ensure the correct timing of subscriptions.", 
            "title": "Lifecycle events"
        }, 
        {
            "location": "/concepts/#proxy-syntax", 
            "text": "Ractive instances do not immediately subscribe to template-based events (DOM events, component events, custom events). The proxy syntax \"proxies\" template-based events into events that the current instance can subscribe to. From there, the events are handled by event APIs. Arguments are not supported in this syntax.  Ractive({\n  template: `\n     button on-click= buttonclicked Click Me! /button \n  `,\n  on: {\n    buttonclicked (context) {\n      console.log('button clicked')\n    }\n  }\n})", 
            "title": "Proxy syntax"
        }, 
        {
            "location": "/concepts/#expression-syntax_1", 
            "text": "A more powerful form of template-based event handling is the expression syntax, which allows the use of expressions as their values. This form acts very similar to inline scripts plus some useful additions. The expression syntax also has full, unmustached access to data and special references.  The first form is a special form of the proxy syntax. It accepts an array whose first item is the event name, and the rest are its arguments.  Ractive({\n  template: `\n     button on-click= ['buttonclicked', 'foo', 'bar'] Click Me! /button \n  `,\n  on: {\n    buttonclicked (context, foo, bar) {\n      console.log('button clicked passing', foo, bar)\n    }\n  }\n})  The second form uses expressions directly. This allows unrestricted access to almost anything, from calling instance methods, custom methods, or even firing a proxy event manually.  Ractive({\n  data: { msg: '' },\n  template: `\n     button on-click= @this.set('msg', 'Hello, World!') Set message /button \n     button on-click= @this.greetz(msg) Print message /button \n     button on-click= @this.fire('manualproxy', msg) Print message via proxy /button \n     button on-click= @this.set('foo', 1), @this.set('bar', 2) Cccombo!!! /button \n  `,\n  greetz(message) {\n    console.log(`${message}`)\n  },\n  on: {\n    manualproxy (context, message) {\n      console.log(`${message}`)\n    }\n  }\n})", 
            "title": "Expression syntax"
        }, 
        {
            "location": "/concepts/#event-context", 
            "text": "Event handlers, regardless of event source, receive an  context  object as first argument. The  context  object is a special instance of a context object augmented with additional event-related properties where applicable.   name  - The name of the published event.  node  - A reference to the DOM node publishing the event. Only available on DOM events.  event  - A reference to the DOM event. Only available on DOM  original  - A reference to the DOM event. Only available on DOM  component  - A reference to the component that published the event. Only available on propagated events.   Ractive({\n  template: `\n     button on-click= buttonclicked Click Me! /button \n  `,\n  on: {\n    buttonclicked (context) {\n      console.log(event.node.type) // submit\n    }\n  }\n})", 
            "title": "Event context"
        }, 
        {
            "location": "/concepts/#namespacing", 
            "text": "Pattern-matching is supported on any type of event, allowing a form of event namespacing. This is done by using a keypath-like event name and using wildcards ( * ) on segments during subscription.  Ractive({\n  el: 'body',\n  append: true,\n  template: `\n     button on-click= foo.bar Click Me! /button \n     button on-click= foo.baz Click Me! /button \n     button on-click= foo.bam Click Me! /button \n     button on-click= qux.bar Click Me! /button \n     button on-click= qux.baz Click Me! /button \n     button on-click= qux.bam Click Me! /button \n  `,\n  on: {\n    '*.bar' (context) {\n      console.log('A bar event was published')\n    },\n    'qux.*' (context) {\n      console.log('A qux event was published')\n    }\n  }\n})  Be aware that handlers subscribing to just  *  will fire for  all  events.", 
            "title": "Namespacing"
        }, 
        {
            "location": "/concepts/#propagation", 
            "text": "", 
            "title": "Propagation"
        }, 
        {
            "location": "/concepts/#dom-event-propagation", 
            "text": "Native DOM event propagation is preserved, allowing things such as delegation.  Ractive({\n  template: `\n     div on-click= buttonclicked \n       button type= button Click Me! /button \n     /div \n  `,\n  on: {\n    buttonclicked (context) {\n      console.log('button clicked')\n    }\n  }\n})", 
            "title": "DOM event propagation"
        }, 
        {
            "location": "/concepts/#component-propagation", 
            "text": "Propagation across component boundaries is also supported. Propagating events are namespaced using the publishing component's name as prefix. This applies to component, proxy, and even lifecycle events.  const ChildComponent = Ractive.extend({\n  template: ' div /div ',\n  oncomplete () {\n    this.fire('childevent')\n  }\n})\n\nconst ParentComponent = Ractive.extend({\n  components: { ChildComponent },\n  template: ' ChildComponent / '\n})\n\nconst instance = Ractive({\n  components: { ParentComponent },\n  template: ' ParentComponent / '\n})\n\ninstance.on('ChildComponent.childevent', function () {\n  console.log('Hello World!')\n})", 
            "title": "Component propagation"
        }, 
        {
            "location": "/concepts/#stopping-propagation", 
            "text": "Propagation can be stopped by simply returning  false  from an event handler. If the event is a DOM event,  event.stopPropagation()  and  event.preventDefault()  are automatically called.  Ractive({\n  template: `\n     div on-click= ancestorbuttonclick \n       button on-click= descendantbuttonclick Click Me! /button \n     /div \n  `,\n  on: {\n    ancestorbuttonclick (context) {\n      console.log('This will not run')\n    },\n    descendantbuttonclick (context) {\n      console.log('This will run')\n      return false\n    }\n  }\n})  Returning  false  also stops propagation across components.  const ChildComponent = Ractive.extend({\n  template: ' div /div ',\n  oncomplete () {\n    this.fire('childevent')\n  }\n})\n\nconst ParentComponent = Ractive.extend({\n  components: { ChildComponent },\n  template: ' ChildComponent / ',\n  on: {\n    'ChildComponent.childevent' () {\n      return false\n    }\n  }\n})\n\nconst instance = Ractive({\n  components: { ParentComponent },\n  template: ' ParentComponent / '\n})\n\ninstance.on('ChildComponent.childevent', function () {\n  console.log('This will not run')\n})  Assigning a handler using  on-*  will also stop propagation. However, if  on-*  is assigned a proxy event and not stopped, that proxy event will propagate in place of the stopped event.  const ChildComponent = Ractive.extend({\n  template: ' div /div ',\n  oncomplete () {\n    this.fire('childevent1')\n    this.fire('childevent2')\n    this.fire('childevent3')\n    this.fire('childevent4')\n  }\n})\n\nconst ParentComponent = Ractive.extend({\n  components: { ChildComponent },\n  template: `\n     ChildComponent\n      on-childevent1= \n      on-childevent2= childevent2proxy \n      on-childevent3= childevent3proxy \n      on-childevent4= @this.parentMethod() \n    / \n  `,\n  on: {\n    childevent2proxy () {\n      // childevent2proxy replaces childevent2\n    },\n    childevent3proxy () {\n      // childevent3proxy replaces childevent3 but stopped\n      return false\n    }\n  },\n  parentMethod () {\n    // childevent4 handled by a method\n  }\n})\n\nconst instance = Ractive({\n  components: { ParentComponent },\n  template: ' ParentComponent / '\n})\n\ninstance.on('ChildComponent.childevent1', function () {\n  console.log('childevent1 stopped by a blank handler')\n})\n\ninstance.on('ChildComponent.childevent2', function () {\n  console.log('childevent2 stopped by a proxy event')\n})\n\ninstance.on('ChildComponent.childevent3', function () {\n  console.log('childevent3 stopped by a proxy event')\n})\n\ninstance.on('ChildComponent.childevent4', function () {\n  console.log('childevent4 stopped by a method call')\n})\n\ninstance.on('ParentComponent.childevent3proxy', function () {\n  console.log('childevent3proxy stopped by returning false')\n})\n\n// This one gets through since its proxy event was left to propagate\ninstance.on('ParentComponent.childevent2proxy', function () {\n  console.log('childevent2proxy fired')\n})", 
            "title": "Stopping propagation"
        }, 
        {
            "location": "/concepts/#rendering", 
            "text": "", 
            "title": "Rendering"
        }, 
        {
            "location": "/concepts/#synchronous-rendering", 
            "text": "Ractive does not batch renders, asynchronously render, nor render at next tick. The instance's DOM is updated immediately after its dependencies update. This is a trade-off between optimization and predictability. Ractive chose the latter route to make it easier to anticipate the state of the DOM at any given moment.   const instance = Ractive({\n  target: 'body',\n  data: {\n    count: 0,\n  },\n  template: `\n     div {{ count }} /div \n  `,\n})\n\nconst div = instance.find('div')\n\nconsole.log('Before:', div.innerHTML)\ninstance.set('count', 100)\nconsole.log('After:', div.innerHTML)\n\n// Before: 0\n// After: 100  The only time rendering happens asynchronously is during animations and transitions. All mutator methods return a promise which resolves when the animations and/or transitions resulting from these operations complete.   const instance = Ractive({\n  target: 'body',\n  data: {\n    count: 0,\n  },\n  template: `\n     div {{ count }} /div \n  `,\n})\n\nconst div = instance.find('div')\n\nconsole.log('Before:', div.innerHTML)\ninstance.animate('count', 100).then(() =  {\n  console.log('Resolved:', div.innerHTML)\n})\nconsole.log('After:', div.innerHTML)\n\n// Before: 0\n// After: 0\n//\n// Resolved: 100", 
            "title": "Synchronous rendering"
        }, 
        {
            "location": "/concepts/#scoped-css", 
            "text": "CSS provided via the  css  initialization option is scoped to the component.  const Component = Ractive.extend({\n  template: `\n     span I'm red /span \n     div \n       span I'm also red /span \n     /div \n  `,\n  css: `\n    span { color: red }\n  `\n})\n\nRactive({\n  components: { Component },\n  el: 'body',\n  template: `\n     Component / \n     span I'm not red /span \n  `\n})  This is done by generating a unique id for each component definition. That ID is then added to each selector defined in  css  and to each top-level element in the component's DOM.  span[data-ractive-css~= {6f9bd745-a6b9-9346-0c8c-e3cc94b3d2a5} ],\n[data-ractive-css~= {6f9bd745-a6b9-9346-0c8c-e3cc94b3d2a5} ] span {\n  color: red\n}  span data-ractive-css= {6f9bd745-a6b9-9346-0c8c-e3cc94b3d2a5} I'm red /span  div data-ractive-css= {6f9bd745-a6b9-9346-0c8c-e3cc94b3d2a5} \n   span I'm also red /span  /div  span I'm not red /span   Currently, there are a few limitations to this feature:   ID-based scoping is not true component scoping and will affect elements of descendant components.  css  can only be used with components and not on direct Ractive instances. This may change in the future.", 
            "title": "Scoped CSS"
        }, 
        {
            "location": "/concepts/#progressive-enhancement", 
            "text": "TODO", 
            "title": "Progressive Enhancement"
        }, 
        {
            "location": "/concepts/#server-side", 
            "text": "Server-side rendering can be achieved using  ractive.toHTML()  and  ractive.toCSS() . Both methods render the instance and its descendants at their current state to HTML and CSS, respectively.  const Component1 = Ractive.extend({\n  data: {\n    message: ''\n  },\n  template: `\n     div class= component1 {{message}} /div \n  `,\n  css: `\n    .component1 { color: red }\n  `\n})\n\nconst Component2 = Ractive.extend({\n  data: {\n    greeting: ''\n  },\n  template: `\n     div class= component2 {{greeting}} /div \n  `,\n  css: `\n    .component2 { color: green }\n  `\n})\n\nconst App = Ractive.extend({\n  components: {\n    Component1,\n    Component2\n  },\n  data: {\n    greet: '',\n    msg: ''\n  },\n  template: `\n     Component1 message= {{ msg }}  / \n     Component2 greeting= {{ greet }}  / \n  `\n})\n\nconst state = { greet: 'Good Morning!', msg: 'Hello, World!' }\nconst app = App({ data: state })\nconst html = app.toHTML()\nconst css = app.toCSS()  Currently, there are a few limitations to this feature:   ractive.toHTML()  prints HTML without component IDs while  ractive.toCSS()  prints out selectors with component IDs, which causes the HTML and CSS to not match up.  A workaround is to render the CSS as is by setting  noCssTransform  to  true  and to use a CSS naming convention (i.e BEM, OOCSS, SMACSS) to match up selectors with their elements.    ractive.toHTML()  does not automatically insert the document CSS when rendering a component that represents a full document. This must be done manually.", 
            "title": "Server-side"
        }, 
        {
            "location": "/concepts/#security", 
            "text": "", 
            "title": "Security"
        }, 
        {
            "location": "/concepts/#use-of-the-function-constructor", 
            "text": "Ractive uses the  Function  constructor only to convert expressions (i.e. mustache expressions, expression-style computed properties) into value-generating functions. As of 0.9,  allowExpressions  initialization option is available to toggle the expression-to-function feature. Setting it to  false  will tell Ractive neither to parse nor process expressions.", 
            "title": "Use of the Function constructor"
        }, 
        {
            "location": "/concepts/#content-security-policy", 
            "text": "Out of the box, Ractive will violate certain CSP directives due to the use of the  Function  constructor for evaluating expressions, and dynamically generated  style  elements for Ractive-managed CSS.  In order to avoid violating  script-src , either:   Pre-parse templates. As of 0.8, the parser will store expressions as functions on the AST. To preserve the functions when serializing the AST, use libraries like  node-tosource  or  serialize-javascript  instead of  JSON.stringify() .  Set  allowExpressions  initialization option to  false . This will tell Ractive to avoid evaluating expressions.  Add the  script-src 'unsafe-eval'  CSP directive. This will allow the use of the  Function  constructor.   In order to avoid violating  style-src , either:   Add  style-src 'unsafe-inline'  to your CSP directives. This will allow the use of dynamically generated  style  elements.", 
            "title": "Content Security Policy"
        }, 
        {
            "location": "/concepts/#templates", 
            "text": "Strictly speaking, Ractive templates are not HTML. They are markup representations of objects that are used to construct HTML. Simply put, templates are  HTML-like . Ractive parses templates into  AST s which contain everything Ractive needs to know to construct an instance's DOM, data bindings, events and transitions etc.  Ractive.parse(' div class= message Hello World! /div ')\n\n// { v :4, t :[{ t :7, e : div , m :[{ n : class , f : message , t :13}], f :[ Hello World! ]}]}", 
            "title": "Templates"
        }, 
        {
            "location": "/concepts/#keypaths", 
            "text": "A keypath is a kind of reference that represents the location of a piece of data.  Ractive({\n  data: {\n    foo: {\n      bar: {\n        baz: {\n          qux: 'Hello, World!'\n        }\n      }\n    }\n  },\n  template: `\n    {{ foo.bar.baz.qux }}\n  `\n})", 
            "title": "Keypaths"
        }, 
        {
            "location": "/concepts/#dot-and-bracket-notations", 
            "text": "Dot and bracket notation rules for keypaths are similar to vanilla JS. The only addition to this is that the dot notation can also be used to access arrays, by using the index directly on the segment.  const instance = Ractive({\n  data: {\n    items: [1, 2, 3],\n    foo: {\n      bar: {\n        baz: {\n          qux: 'Hello, World!',\n          'dotted.key': 'Me, Hungry!'\n        }\n      }\n    },\n    dynamicKey: 'bar'\n  },\n  template: `\n    {{ foo['bar']['baz']['qux'] }}  !-- bracket notation object access -- \n    {{ foo.bar.baz.qux }}           !-- dot notation object access -- \n\n    {{ items[0] }}  !-- bracket notation array access -- \n    {{ items.0 }}   !-- dot notation array access -- \n\n    {{ foo.bar.baz['dotted.key'] }}  !-- dotted key access -- \n\n    {{ foo[dynamicKey].baz.qux }}  !-- dynamic key access -- \n  `\n})", 
            "title": "Dot and bracket notations"
        }, 
        {
            "location": "/concepts/#missing-properties", 
            "text": "In JavaScript, trying to access a child property of an object that does not exist would throw an error. In Ractive, it would simply return  undefined  or render nothing.  const instance = Ractive({\n  data: {\n    numbers: [ 1, 2, 3 ]\n  },\n  template: `\n    {{ letters[0] }}\n  `\n})\n\nractive.get( 'letters[0]' ) // undefined", 
            "title": "Missing properties"
        }, 
        {
            "location": "/concepts/#upstream-and-downstream-keypaths", 
            "text": "Ractive has this concept of \"upstream\" and \"downstream\" keypaths. Upstream keypaths are ancestor keypaths. For the keypath  foo.bar.baz.qux , it's upstream keypaths are  foo ,  foo.bar  and  foo.bar.baz . Downstream keypaths are descendant keypaths. For the  foo  keypath, it's downstream keypaths would be  foo.bar ,  foo.bar.baz  and  foo.bar.baz.qux .", 
            "title": "Upstream and downstream keypaths"
        }, 
        {
            "location": "/concepts/#references", 
            "text": "A reference is a string that refers to a piece of data. A keypath is an example of a reference, one that points to a specific location in the data. Special references are also a form of reference, one that provides to a certain value.", 
            "title": "References"
        }, 
        {
            "location": "/concepts/#reference-resolution", 
            "text": "Ractive follows the following resolution algorithm to find the value of a reference:   If the reference is a special reference ( /^@/ ), resolve with the matching special model.  If the reference is explicit (prefixed/relative) or matches a path in the current context exactly, resolve with the model relative to the current context.  If the reference keypath only has one key, see if it matches a helper, and if so, resolve with that model. If not, match with the base key for the rest of the steps e.g.  foo  in  foo.bar.baz .  Grab the current virtual node from the template hierarchy.  If the base matches an alias, section indexes, or keys, resolve with that model.  If the base matches a path on the context, resolve with the model relative to the context.  Remove the innermost context from the stack. If there are still contexts left in the stack, goto 4.  If  resolveInstanceMembers  is true and the base matches an instance member, resolve with the path to the member.  If the reference is a valid keypath by itself, resolve with that keypath in the starting context.", 
            "title": "Reference resolution"
        }, 
        {
            "location": "/concepts/#context-stack", 
            "text": "Whenever Ractive encounters section mustaches or similar constructs, it stores the context in a  context stack . Ractive then resolves references relative to the top of the stack, and popping off contexts until the reference resolves to a keypath.  Ractive({\n  data: {\n    qux: 'Me, Hungry!',\n    foo: {\n      bar: {\n        baz: 'Hello, World!'\n      }\n    }\n  },\n  template: `\n                 !-- context is the root of the data -- \n    {{#foo}}     !-- context is now foo -- \n      {{#bar}}   !-- context is now foo.bar -- \n        {{baz}}  !-- Resolution order: foo.bar.baz, foo.baz, baz. Resolved at foo.bar.baz. -- \n        {{qux}}  !-- Resolution order: foo.bar.quz, foo.qux, qux. Resolved at qux. -- \n      {{/}}\n    {{/}}\n  `,\n})", 
            "title": "Context stack"
        }, 
        {
            "location": "/concepts/#conditional-attributes", 
            "text": "Sections can toggle attributes, whether it's one attribute, multiple attributes or specific values of the attribute.  !-- one attribute --  a href= /  {{#if currentPage}}class= active {{/if}} Home /a  !-- multiple attributes --  a href= /  {{#if currentPage}}class= active  title= Current page {{/if}} Home /a  !-- specific attribute value --  a href= /  class= nav-link {{#if currentPage}}nav-link--active{{/if}} Home /a", 
            "title": "Conditional attributes"
        }, 
        {
            "location": "/concepts/#optimization", 
            "text": "", 
            "title": "Optimization"
        }, 
        {
            "location": "/concepts/#pre-parsing", 
            "text": "Parsing templates can be a very slow operation. As an optimization option, templates can be pre-parsed outside of runtime, speeding up app initialization. Most loaders do pre-parsing of templates as part of their build process. A parsed template is approximately 30-40% larger than the markup version, making it a trade-off between space and processing.", 
            "title": "Pre-parsing"
        }, 
        {
            "location": "/concepts/#limiting-template-expressions", 
            "text": "While expressions provide power and convenience when building templates, it incurs a performance penalty as Ractive sets up each one on a per-instance level. To avoid this overhead, there are several places where logic can move to, trimming down expressions into mere function calls.  Functions can be set on the data globally via  Ractive.defaults.data .  Ractive.defaults.data.customLogic = function () { ... }\n\nRactive({\n  template: `\n    {{ customLogic() }}\n  `\n})  Functions can also be defined on a component level using methods.  const Component = Ractive.extend({\n  template: `\n    {{ @this.customLogic() }}\n  `,\n  customLogic () {\n    ...\n  }\n})", 
            "title": "Limiting template expressions"
        }, 
        {
            "location": "/concepts/#expression-processing", 
            "text": "When Ractive parses a template, it creates a string representation of the expression structure and keeps track of its dependencies. Then Ractive converts these expression strings into a function which can be called to generate the expression's value.  Ractive optimizes this routine starting by generating the same expression string for structurally-identical expressions. Then a value-generating function is created for each  distinct  expression string, cached globally and shared to all instances. Furthermore, Ractive caches the generated values and only updates them when the expression's dependencies update.  // Expression parsing\nRactive.parse('{{ a + b }}{{ c + d }}')\n\n// {\n//    v : 4,\n//    t : [\n//     {\n//        t : 2,\n//        x : {\n//          r : [ a , b ],  -- dependencies here\n//          s :  _0+_1      -- expression string here\n//       }\n//     },\n//     {\n//        t : 2,\n//        x : {\n//          r : [ c , d ],  -- dependencies here\n//          s :  _0+_1      -- expression string here\n//       }\n//     }\n//   ],\n//    e : {}\n// }\n\n// Building and caching of the expression resolver of `_0+_1`\nconst expressionFunctionsCache = {}\nexpressionFunctionsCache['_0+_1'] = new Function('_0', '_1', 'return _0+_1')\n\n// Evaluate {{ a + b }}\nconst dep = ['a', 'b']\nconst exp = '_0+_1'\nconst arg = dep.map(instance.get)\nconst val = expressionFunctionsCache[exp].apply(instance, arg)\n\n// Evaluate {{ c + d }}\nconst dep = ['c', 'd']\nconst exp = '_0+_1'\nconst arg = dep.map(instance.get)\nconst val = expressionFunctionsCache[exp].apply(instance, arg)  The  Function  constructor was chosen over  eval  because it allows Ractive to compile the expression string  once  as well as  cache  the resulting function, instead of evaluating the string every time the value is needed.", 
            "title": "Expression processing"
        }, 
        {
            "location": "/support/", 
            "text": "Support\n\n\nGetting in touch\n\n\n\n\nGitter\n\n\nGitHub\n\n\nTwitter\n\n\nStackOverflow\n\n\nGoogle Groups\n\n\n\n\nLegacy documentation\n\n\n0.9\n\n\n\n\nAPI\n\n\nPlugins\n\n\nConcepts\n\n\n\n\n0.8 and older\n\n\nDocumentation for versions 0.8 and older can be found at \nhttps://ractive.js.org/v0.x\n.\n\n\nBuilds\n\n\n\n\nRegular (\nractive.js\n, \nractive.min.js\n, \nractive.mjs\n) - Ractive with batteries included. Intended for maximum compatibility.\n\n\nRuntime (\nruntime.js\n, \nruntime.min.js\n, \nruntime.mjs\n) - Ractive without the template parser. Intended for workflows that pre-parse templates which do not require the parser at runtime.\n\n\n\n\nSource maps are included for all variants of Ractive.\n\n\nBrowser support\n\n\nES5 support\n is the minimum requirement. Ractive also comes with the following polyfills:\n\n\n\n\nPromise\n\n\nArray.prototype.find\n\n\nObject.assign\n\n\nperformance.now\n\n\nrequestAnimationFrame\n\n\n\n\nSVGs\n\n\nRactive doesn't mind whether you're rendering HTML or SVG - it treats both the same way. Unfortunately, some browsers (notably IE8 and below, and Android 2.3 and below) \ndo\n care.\n\n\n\n\nThis browser does not support namespaces other than http://www.w3.org/1999/xhtml. The most likely cause of this error is that you're trying to render SVG in an older browser. See https://github.com/RactiveJS/Ractive/wiki/SVG-and-older-browsers for more information\n\n\n\n\nIf the browser logs an error like the one above, \nthe only winning move is not to play\n. Ractive provides \nRactive.svg\n to indicate if the browser handles SVGs properly. This may be used to supply fallback content in place of the SVG.\n\n\nRactive({\n  el: 'container',\n  template: Ractive.svg ? awesomeVectorGraphicsContent : highResolutionImageContent\n})\n\n\n\n\nMigrating from previous versions\n\n\nThese are notes to help you migrate from an older version of Ractive.js to a newer one, mostly centered on breaking changes between versions. If you'd like to find out more about new features, you can check out the \nchangelog\n.\n\n\nMigrating from 0.9\n\n\nDefaults\n\n\nresolveInstanceMembers\n now defaults to \nfalse\n to avoid foot maimings associated with common instance member names and ambiguous references.\n\n\nComputations\n\n\nThe stringy syntax for computed properties has changed to plain old expression syntax. This means that \n${length} * ${width}\n as a computation is now just \nlength * width\n, which is hopefully a little less surprising given \n${interpolator}\n syntax in template strings.\n\n\n'.'s in computation keypaths must now be escaped if they're meant to be part of a single key, as you can now add computations below the root level.\n\n\nTemplate format\n\n\nTemplate positions in parsed template AST are now stored in the \nq\n member rather than the \np\n member to avoid accidental overlap with local partials.\n\n\nData\n\n\nChecking that a value exists at some keypath in the data will no longer exclude the root prototypes (\nObject\n, \nFunction\n, \nArray\n) because doing so creates issues when dealing with \nObject.create(null)\n. If you keep your references unambiguous, this shouldn't cause any issues. The simplest example of where this can cause trouble is with \n{ items: [{ length: 10 }, {}] }\n in \n{{#each items}}{{length}}{{/each}}\n where the second length will be that of the items array because the object has no length property but its parent context, the array, does.\n\n\nAliases now take precedent over properties from contexts above their alias defintions. This means that \n{{#with { foo: 10 } }}{{#with 42 as foo}}{{foo}}{{/with}}{{/with}}\n results in \n42\n rather than \n10\n, which is hopefully the less surprising behavior.\n\n\nThe context pop reference prefix \n^^/\n now correctly handles \n{{#each}}\n blocks such that \n^^/ === ../../\n from immediately within the block body. This is because \n^^/\n is supposed to jump explicit contexts and not just implicit contexts as provided by each iteration.\n\n\nPolyfills\n\n\npolyfills.js\n is no longer included in the build, as it was just an empty placeholder since the handful of polyfills that were in it were included in the main build.\n\n\nMigrating from 0.8\n\n\nRemoved deprecations\n\n\n0.9 removes any of the remaining deprecations from 0.8, including:\n\n\n\n\ndecorator=\"name:{{arg1}},{{arg2}}\n directives, to be replaced with \nas-name=\"arg1, arg2\"\n\n\nintro=\"name:{{ { arg1: arg1, arg2, arg2 } }}\"\n and the same forms of \noutro\n and \nintro-outro\n to be replaced with \nname-in=\"{ arg1, arg2 }\"\n and the same forms of \nname-out\n and \nname-in-out\n\n\nThe \nractive.data\n getter, to be replaced with \nractive.get()\n, which returns a computed object tree containing virtual keys like mappings, links, and computations. The optional form \nractive.get({ virtual: false })\n will return the raw root object without any virtual keys.\n\n\nLifecycle methods \ninit\n and \nbeforeInit\n, to be replaced with lifecycle events or equivalent instance methods. \nbeforeInit\n corresponds to the \nconstruct\n lifecycle event.\n\n\nPartial comments in the form of \n!-- {{\nmyPartial}} --\n...\n!-- {{/myPartial}} --\n, to be replaced with partial blocks \n{{#partial myPartial}}...{{/partial}}\n\n\n\n\nPart of removing directive deprecations allowed using the plain expression parser for attributes and directives, which means that directives that parse in an expression context are much more resilient to things like quote pileup with strings e.g. \nas-target=\"\"id as a string\"\"\n.\n\n\nNote\n: this also means that directive values aren't processed as HTML before being parsed, so HTML entities are no longer automatically encoded within directive values.\n\n\nTemplate format\n\n\nThe template format produced by \nRactive.parse\n has changed, making it incompatible with previous versions of Ractive.js and their template formats. You will need to re-parse any pre-parsed templates for use with 0.9.\n\n\nEvent delegation\n\n\nRactive will now automatically set up event delegation for elements that contain iterative sections. This installs a single DOM listener on the host element for each event type within the iterative section, and when an event fires from one of the iterative elements with a listener, the parent delegation target handles triggering listeners on the correct elements. This prevents having to set up large numbers of event listeners in iterative sections, but it can also surface inconsistencies in browser event implementations. If you need to disable event delegation for a special case, you can add a \nno-delegation\n attribute to the element containing the iterative section, pass \ndelegate: false\n to your component or instance, or set \nRactive.defaults.delegate\n to \nfalse\n.\n\n\nPartial context\n\n\nAny context provided to a partial \n{{\nmy-partial context}}\n is no longer wrapped around the partial but is instead wrapped around the \ncontent\n of the partial. It's a subtle difference that only shows up when the partial name is an expression e.g. \n{{\n.type ~/external.item}}\n. Before this break, the \n.type\n would resolve to \n~/external.item.type\n, and now it will resolve to \n.type\n on the context in which the partial appears.\n\n\nYielding\n\n\nYielding is no longer restricted to inline partials, and each partial may be yielded more than once. You will no longer get a warning if you try to yield an instance or dynamic partial or if you yield the same partial multiple times.\n\n\nnoIntro\n inheritance\n\n\nThe \nnoIntro\n setting of an instance that contains components will now apply to the components too, unless those components have their own \nnoIntro\n setting.\n\n\nPolyfills\n\n\nThere is no longer a \nlegacy\n build of Ractive.js available. Instead, a separate \npolyfills\n library is available that can be included before Ractive.js is loaded, or you can supply your own polyfills, shims, or shams.\n\n\nNode registry\n\n\nElements with an \nid\n attribute are no longer collected into a \nnodes\n map on the Ractive.js instance. If you require similar functionality, it can be achieved in a much more flexible way with a decorator.\n\n\nUnresolved references\n\n\nReferences that don't resolve are no longer kept in an unresolved state, waiting on an appropriate keypath to pop into existence somewhere in the context hierarchy. Instead, references that don't resolve are immediately resolved in the current context, which tends to be the desired behavior in most circumstances.\n\n\nLive queries\n\n\nElement and component queries no longer support automatically keeping the resulting array up to date as new matching elements or components are rendered. If you require similar functionality, it can be achieved with a decorator for elements or bubbled lifecycle events for components.\n\n\nchange\n event\n\n\nThe \nchange\n event has been removed and replaced by recursive observers, which are strictly opt-in and can be scoped to a deeper keypath than the root.\n\n\nevent\n reference\n\n\nThe \nevent\n special reference available to event directives has been deprecated and replaced with three special references:\n\n\n\n\n@context\n, which is roughly equivalent to \nevent\n, but with both an \nevent\n and \noriginal\n key that point to the original event object. This is a context object.\n\n\n@event\n, which is resolves to the original event that triggered the directive.\n\n\n@node\n, which resolves to the element to which the event directive is attached.\n\n\n\n\nInstance events\n\n\nThe signature for callbacks to instance events, supplied to \nractive.on()\n, now \nalways\n includes a context regardless of the origin of the event (DOM or API). Additionally, the \nfire\n method has changed such that the first argument may be a context object. Any events that need to send an object to the callback as the first post-context argument will need to supply a placeholder context object e.g. \nractive.fire( 'event', { first: 'arg' } )\n becomes \nractive.fire( 'event', {}, { first: 'arg' } )\n.\n\n\nractive.merge\n\n\nractive.merge\n has been removed and replaced by an option on \nractive.set\n, \n{ shuffle: true }\n, which more accurately reflects what actually happens. \nmerge\n did not merge data, but instead re-arranged any DOM associated with the elements in the given array to match the order of the array - hence \nshuffle\n rather than \nmerge\n.\n\n\nIsolation\n\n\nComponents are now \nisolated\n by default. If you need non-\nisolated\n components in order to create implicit mappings as data is accessed, you can pass \nisolated: false\n to \nextend\n when creating the component. If you prefer all components to be non-\nisolated\n by default, you can set \nRactive.defaults.isolated = false\n.\n\n\nFurther, non-\nisolated\n components will now create implicit mappings when necessary for \nset\n operations, including \nadd\n, \nsubtract\n, etc, in addition to \nget\n operations. To avoid creating an implicit mapping with a \nset\n operation from a non-\nisolated\n component, pass \n{ isolated: true }\n as an option to the \nset\n method.\n\n\nMagic and array adaptors\n\n\nThe magic and array adaptors are no longer part of Ractive.js core. They may be reappear as independent plugins at some point in the future.\n\n\nclass-\n directives\n\n\nclass-\n directives are now parsed in an expression context like decorator, transition, and event directives, rather than in a string context like attributes and \nstyle-\n directives. This means that mustaches are no longer required for \nclass-\n directive values, so you should use \nclass-selected=\".selected\"\n rather than \nclass-selected=\"{{.selected}}\"\n.\n\n\ngetNodeInfo\n\n\nractive.getNodeInfo\n has been renamed to \nractive.getContext\n, as has the static version of the function, to more accurately reflect its function. The \ngetNodeInfo\n alias is deprecated and will be removed in a future version.\n\n\nMultiple inheritance\n\n\nComponents can no longer inherit from multiple other components at the same level, meaning that \nRactive.extend(FirstComponent, SecondComponent)\n is no longer possible. You can still set up an inheritance hierachy multiple levels deep with \nconst First = Ractive.extend({ ...options }); const Second = First.extend({ ...others });\n.\n\n\nMigrating from 0.7\n\n\nTemplate format\n\n\nThe template format produced by \nRactive.parse\n has changed, making it incompatible with previous versions of Ractive.js and their template formats. You will need to re-parse any pre-parsed templates for use with 0.8.\n\n\nIE8\n\n\nIE8 is no longer supported. If you still need to support IE8, well, we're very, very sorry...\n\n\nExpressions and binding\n\n\nTwo-way bindings are no longer supported in computed contexts that don't have a \nset\nter, including template expression contexts. This means that \n{{#each filter(list)}}\ninput value=\"{{.name}}\" /\n{{/each}}\n is no longer possible. The reasoning behind this change is that the original \nlist.${index}.name\n is not updated when the binding within the computed context in the \neach\n expression is changed. 0.9 adds an instance flag \nsyncComputedChildren\n that can address this.\n\n\nRelaxed partial names\n\n\nPartial names can now include \n\\\n characters, which can be problematic if you happen to use division with no spaces arount the \n/\n in a partial expression.\n\n\nInteger references\n\n\nIntegers are no longer considered references, even in an array context, meaning that in \n{{#with [1, 2, 3]}}{{0}}{{/with}}\n will no longer result in \n1\n being rendered. Integers are now stricly considered to integer literals. If you need to reference a specific index in an array context, you can do so with a context specific reference like \n{{this.0}}\n.\n\n\nArray modification\n\n\nmodifyArrays\n now defaults to \nfalse\n, so the array adaptor is not applied to arrays automatically as they are added to the instance data. The preferred method of performing array operations is using the \nsplice\n, \npush\n, \npop\n, etc methods on the Ractive.js instance.\n\n\nMigrating from 0.6\n\n\nWhat's new\n\n\nComponents can now access their parents and containers using an official API.\n\n\nBinding directives may be set on elements that support two-way binding. These directives override the settings on the Ractive instance for \ntwoway\n and \nlazy\n.\n\n\nSingle-fire versions of \nractive.on\n and \nractive.observe\n are now available as \nractive.once\n and \nractive.observeOnce\n.\n\n\nInline partials can now be defined within a new section \n{{#partial partial-name}}...{{/partial}}\n. The old comment syntax is now deprecated and will be removed in a future release.\n\n\nInline partials are now scoped to their nearest element. If a partial reference sits in the template below an element with a matching inline partial, the inline partial will be used in the reference. This can be used as a sort of partial inheritance. If an inline partial is defined directly within a component tag or the root of the template, it will be added to the Ractive instance.\n\n\nComponents may now yield to multiple inline partials by supplying the partial name with yield e.g. \n{{yield some-name}}\n. Yielding without a name will still result in non-partial content being yielded. Only inline partials may be yielded. Any partials, including inline and inherited, may still be referenced within a component using a plain partial section e.g. \n{{\npartial}}\n.\n\n\nPartials can now be reset without resorting to manually un/re-rendering them using a wrapping conditional section. This can be done with the new \nresetPartial\n method on Ractive instances.\n\n\nthis.event\n is now available to method-call event handlers.\n\n\nRegular expression literals can now be used in template expressions.\n\n\nYou can now escape mustaches with a '\\' if you'd like them to appear in the template.\n\n\nractive.toggle\n now works with patterns.\n\n\nThe debug setting is no longer set per-instance. It has been replaced with \nRactive.DEBUG\n, which defaults to true. You can set it automatically based on whether or not the your code has been minified with:\n\n\nRactive.DEBUG = /unminified/.test(function(){/*unminified*/})\n\n\n\n\nBreaking changes and deprecation\n\n\n\n\ntwoway\n and \nlazy\n are now reserved attribute names to be used as binding directives.\n\n\nInline partials now belong to their nearest element.\n\n\nThe comment syntax for inline partials is now deprecated.\n\n\nelseif\n is now a reserved identifier.\n\n\nractive.data\n is no longer available. Use \nractive.get()\n to get a shallow copy of the data with any component mappings.\n\n\nChild data always overrides parent data, whether it is a POJO (Plain Old JS Object) or not.\n\n\nractive.debug\n has been replaced with the global \nRactive.DEBUG\n flag.\n\n\n\n\nMigrating from 0.5\n\n\nLifecycle events\n\n\nRactive instances now emit \nlifecycle events\n. If you use \nRactive.extend(...)\n with \ninit()\n, \nbeforeInit()\n or \ncomplete()\n, you will need to replace them - they will continue to work, but will be removed in a future version.\n\n\ninit()\n can be replaced with one of the following methods, or you may need to split your code into both methods. Use \nonrender()\n for code that needs access to the rendered DOM, but is safe being called more than once if you unrender and rerender your ractive instance. Use \noninit()\n for code that should run only once or needs to be run regardless of whether the ractive instance is rendered into the DOM.\n\n\nThe \ninit()\n method also no longer recieves an \noptions\n parameter as the ractive instance now inherits \nall\n options passed to the constructor. You can still access the options directly using the \nonconstruct()\n method.\n\n\nbeforeInit()\n and \ncomplete()\n can be replaced directly with \nonconstruct()\n and \noncomplete()\n respectively.\n\n\nSee the lifecycle events page for more detail.\n\n\nOther Breaking changes\n\n\n\n\nnew Ractive()\n now inherits all options as methods/properties including event hooks. If you have been passing data through custom initialisation options be aware that they will appended to your ractive instance.\n\n\nUsing other elements besides \nscript\n for templates is an now an error. Migrate any templates in non-script elements and include a non-javascript type so the browser does not try to interpret your template:\n\n\n\n\njs\n    \nscript id='template' type='text/ractive'\n\n      Your template goes here\n    \n/script\n\n\n\n\nNew reserved events cannot be used for proxy event names, i.e. \np on-click='init'\n/p\n. These include 'change', 'config', 'construct', 'init', 'render', 'reset', 'teardown', 'unrender', and 'update'. You will need to rename your events.\n\n\nSetting uninitialised data on a component will no longer cause it to leak out into the parent scope\n\n\n'Smart updates', via \nractive.merge()\n and \nractive.shift()\n etc, work across component boundaries. In most cases this is the expected behavior.\n\n\nThe CSS length interpolator has been removed.\n\n\n\n\nMigrating from 0.4\n\n\nBreaking changes\n\n\n\n\nErrors in observers and evaluators are no longer caught\n\n\nNodes are detached as soon as any outro transitions are complete (if any), rather than when \nall\n transitions are complete\n\n\n(Outdated if you are moving to \n0.6.x\n or above) The options argument of \ninit: function(options)\n is now strictly what was passed into the constructor, use \nthis.option\n to access configured value.\n\n\ndata\n with properties on prototype are no longer cloned when accessed. \ndata\n from \"baseClass\" is no longer deconstructed and copied.\n\n\nOptions specified on component constructors will not be picked up as defaults. \ndebug\n now on \ndefaults\n, not constructor\n\n\nSelect bindings follow general browser rules for choosing options. Disabled options have no value.\n\n\nInput values are not coerced to numbers, unless input type is \nnumber\n or \nrange\n\n\n{{this.foo}}\n in templates now means same thing as \n{{.foo}}\n\n\nRendering to an element already render by Ractive causes that element to be torn down (unless appending).\n\n\nIllegal javascript no longer allowed by parser in expressions and will throw\n\n\nParsed template format changed to specify template spec version.\n\n\nProxy-event representation\n\n\nNon-dynamic (bound) fragments of html are no longer stored as single string\n\n\nSee https://github.com/ractivejs/template-spec for current spec.\n\n\nArrays being observed via \narray.*\n no longer send \nitem.length\n event on mutation changes\n\n\nReserved event names in templates ('change', 'config', 'construct', 'init', 'render', 'reset', 'teardown', 'unrender', 'update') will cause the parser to throw an error\n\n\n{{else}}\n support in both handlebars-style blocks and regular mustache conditional blocks, but is now a restricted keyword that cannot be used as a regular reference\n\n\nChild components are created in data order\n\n\nReference expressions resolve left to right and follow same logic as regular mustache references (bind to root, not context, if left-most part is unresolved).\n\n\nImproved attribute parsing and handling:\n\n\ncharacter escaping and whitespace handling in attribute directive arguments\n\n\nboolean and empty string attributes\n\n\nComputed properties no longer create nested objects with keypath like names, i.e. \npage.area: '${width} * ${height}'\n creates a property accessible by \n{{page.area}}\n but not \n{{#page}}{{area}}{{/page}}\n\n\nThe element into which the ractive instance was rendered is no longer available as \nractive.el\n. See \nractive.render()\n and \nractive.insert()\n for more information on moving ractive instances in the DOM.", 
            "title": "Support"
        }, 
        {
            "location": "/support/#support", 
            "text": "", 
            "title": "Support"
        }, 
        {
            "location": "/support/#getting-in-touch", 
            "text": "Gitter  GitHub  Twitter  StackOverflow  Google Groups", 
            "title": "Getting in touch"
        }, 
        {
            "location": "/support/#legacy-documentation", 
            "text": "", 
            "title": "Legacy documentation"
        }, 
        {
            "location": "/support/#09", 
            "text": "API  Plugins  Concepts", 
            "title": "0.9"
        }, 
        {
            "location": "/support/#08-and-older", 
            "text": "Documentation for versions 0.8 and older can be found at  https://ractive.js.org/v0.x .", 
            "title": "0.8 and older"
        }, 
        {
            "location": "/support/#builds", 
            "text": "Regular ( ractive.js ,  ractive.min.js ,  ractive.mjs ) - Ractive with batteries included. Intended for maximum compatibility.  Runtime ( runtime.js ,  runtime.min.js ,  runtime.mjs ) - Ractive without the template parser. Intended for workflows that pre-parse templates which do not require the parser at runtime.   Source maps are included for all variants of Ractive.", 
            "title": "Builds"
        }, 
        {
            "location": "/support/#browser-support", 
            "text": "ES5 support  is the minimum requirement. Ractive also comes with the following polyfills:   Promise  Array.prototype.find  Object.assign  performance.now  requestAnimationFrame", 
            "title": "Browser support"
        }, 
        {
            "location": "/support/#svgs", 
            "text": "Ractive doesn't mind whether you're rendering HTML or SVG - it treats both the same way. Unfortunately, some browsers (notably IE8 and below, and Android 2.3 and below)  do  care.   This browser does not support namespaces other than http://www.w3.org/1999/xhtml. The most likely cause of this error is that you're trying to render SVG in an older browser. See https://github.com/RactiveJS/Ractive/wiki/SVG-and-older-browsers for more information   If the browser logs an error like the one above,  the only winning move is not to play . Ractive provides  Ractive.svg  to indicate if the browser handles SVGs properly. This may be used to supply fallback content in place of the SVG.  Ractive({\n  el: 'container',\n  template: Ractive.svg ? awesomeVectorGraphicsContent : highResolutionImageContent\n})", 
            "title": "SVGs"
        }, 
        {
            "location": "/support/#migrating-from-previous-versions", 
            "text": "These are notes to help you migrate from an older version of Ractive.js to a newer one, mostly centered on breaking changes between versions. If you'd like to find out more about new features, you can check out the  changelog .", 
            "title": "Migrating from previous versions"
        }, 
        {
            "location": "/support/#migrating-from-09", 
            "text": "", 
            "title": "Migrating from 0.9"
        }, 
        {
            "location": "/support/#defaults", 
            "text": "resolveInstanceMembers  now defaults to  false  to avoid foot maimings associated with common instance member names and ambiguous references.", 
            "title": "Defaults"
        }, 
        {
            "location": "/support/#computations", 
            "text": "The stringy syntax for computed properties has changed to plain old expression syntax. This means that  ${length} * ${width}  as a computation is now just  length * width , which is hopefully a little less surprising given  ${interpolator}  syntax in template strings.  '.'s in computation keypaths must now be escaped if they're meant to be part of a single key, as you can now add computations below the root level.", 
            "title": "Computations"
        }, 
        {
            "location": "/support/#template-format", 
            "text": "Template positions in parsed template AST are now stored in the  q  member rather than the  p  member to avoid accidental overlap with local partials.", 
            "title": "Template format"
        }, 
        {
            "location": "/support/#data", 
            "text": "Checking that a value exists at some keypath in the data will no longer exclude the root prototypes ( Object ,  Function ,  Array ) because doing so creates issues when dealing with  Object.create(null) . If you keep your references unambiguous, this shouldn't cause any issues. The simplest example of where this can cause trouble is with  { items: [{ length: 10 }, {}] }  in  {{#each items}}{{length}}{{/each}}  where the second length will be that of the items array because the object has no length property but its parent context, the array, does.  Aliases now take precedent over properties from contexts above their alias defintions. This means that  {{#with { foo: 10 } }}{{#with 42 as foo}}{{foo}}{{/with}}{{/with}}  results in  42  rather than  10 , which is hopefully the less surprising behavior.  The context pop reference prefix  ^^/  now correctly handles  {{#each}}  blocks such that  ^^/ === ../../  from immediately within the block body. This is because  ^^/  is supposed to jump explicit contexts and not just implicit contexts as provided by each iteration.", 
            "title": "Data"
        }, 
        {
            "location": "/support/#polyfills", 
            "text": "polyfills.js  is no longer included in the build, as it was just an empty placeholder since the handful of polyfills that were in it were included in the main build.", 
            "title": "Polyfills"
        }, 
        {
            "location": "/support/#migrating-from-08", 
            "text": "", 
            "title": "Migrating from 0.8"
        }, 
        {
            "location": "/support/#removed-deprecations", 
            "text": "0.9 removes any of the remaining deprecations from 0.8, including:   decorator=\"name:{{arg1}},{{arg2}}  directives, to be replaced with  as-name=\"arg1, arg2\"  intro=\"name:{{ { arg1: arg1, arg2, arg2 } }}\"  and the same forms of  outro  and  intro-outro  to be replaced with  name-in=\"{ arg1, arg2 }\"  and the same forms of  name-out  and  name-in-out  The  ractive.data  getter, to be replaced with  ractive.get() , which returns a computed object tree containing virtual keys like mappings, links, and computations. The optional form  ractive.get({ virtual: false })  will return the raw root object without any virtual keys.  Lifecycle methods  init  and  beforeInit , to be replaced with lifecycle events or equivalent instance methods.  beforeInit  corresponds to the  construct  lifecycle event.  Partial comments in the form of  !-- {{ myPartial}} -- ... !-- {{/myPartial}} -- , to be replaced with partial blocks  {{#partial myPartial}}...{{/partial}}   Part of removing directive deprecations allowed using the plain expression parser for attributes and directives, which means that directives that parse in an expression context are much more resilient to things like quote pileup with strings e.g.  as-target=\"\"id as a string\"\" .  Note : this also means that directive values aren't processed as HTML before being parsed, so HTML entities are no longer automatically encoded within directive values.", 
            "title": "Removed deprecations"
        }, 
        {
            "location": "/support/#template-format_1", 
            "text": "The template format produced by  Ractive.parse  has changed, making it incompatible with previous versions of Ractive.js and their template formats. You will need to re-parse any pre-parsed templates for use with 0.9.", 
            "title": "Template format"
        }, 
        {
            "location": "/support/#event-delegation", 
            "text": "Ractive will now automatically set up event delegation for elements that contain iterative sections. This installs a single DOM listener on the host element for each event type within the iterative section, and when an event fires from one of the iterative elements with a listener, the parent delegation target handles triggering listeners on the correct elements. This prevents having to set up large numbers of event listeners in iterative sections, but it can also surface inconsistencies in browser event implementations. If you need to disable event delegation for a special case, you can add a  no-delegation  attribute to the element containing the iterative section, pass  delegate: false  to your component or instance, or set  Ractive.defaults.delegate  to  false .", 
            "title": "Event delegation"
        }, 
        {
            "location": "/support/#partial-context", 
            "text": "Any context provided to a partial  {{ my-partial context}}  is no longer wrapped around the partial but is instead wrapped around the  content  of the partial. It's a subtle difference that only shows up when the partial name is an expression e.g.  {{ .type ~/external.item}} . Before this break, the  .type  would resolve to  ~/external.item.type , and now it will resolve to  .type  on the context in which the partial appears.", 
            "title": "Partial context"
        }, 
        {
            "location": "/support/#yielding", 
            "text": "Yielding is no longer restricted to inline partials, and each partial may be yielded more than once. You will no longer get a warning if you try to yield an instance or dynamic partial or if you yield the same partial multiple times.", 
            "title": "Yielding"
        }, 
        {
            "location": "/support/#nointro-inheritance", 
            "text": "The  noIntro  setting of an instance that contains components will now apply to the components too, unless those components have their own  noIntro  setting.", 
            "title": "noIntro inheritance"
        }, 
        {
            "location": "/support/#polyfills_1", 
            "text": "There is no longer a  legacy  build of Ractive.js available. Instead, a separate  polyfills  library is available that can be included before Ractive.js is loaded, or you can supply your own polyfills, shims, or shams.", 
            "title": "Polyfills"
        }, 
        {
            "location": "/support/#node-registry", 
            "text": "Elements with an  id  attribute are no longer collected into a  nodes  map on the Ractive.js instance. If you require similar functionality, it can be achieved in a much more flexible way with a decorator.", 
            "title": "Node registry"
        }, 
        {
            "location": "/support/#unresolved-references", 
            "text": "References that don't resolve are no longer kept in an unresolved state, waiting on an appropriate keypath to pop into existence somewhere in the context hierarchy. Instead, references that don't resolve are immediately resolved in the current context, which tends to be the desired behavior in most circumstances.", 
            "title": "Unresolved references"
        }, 
        {
            "location": "/support/#live-queries", 
            "text": "Element and component queries no longer support automatically keeping the resulting array up to date as new matching elements or components are rendered. If you require similar functionality, it can be achieved with a decorator for elements or bubbled lifecycle events for components.", 
            "title": "Live queries"
        }, 
        {
            "location": "/support/#change-event", 
            "text": "The  change  event has been removed and replaced by recursive observers, which are strictly opt-in and can be scoped to a deeper keypath than the root.", 
            "title": "change event"
        }, 
        {
            "location": "/support/#event-reference", 
            "text": "The  event  special reference available to event directives has been deprecated and replaced with three special references:   @context , which is roughly equivalent to  event , but with both an  event  and  original  key that point to the original event object. This is a context object.  @event , which is resolves to the original event that triggered the directive.  @node , which resolves to the element to which the event directive is attached.", 
            "title": "event reference"
        }, 
        {
            "location": "/support/#instance-events", 
            "text": "The signature for callbacks to instance events, supplied to  ractive.on() , now  always  includes a context regardless of the origin of the event (DOM or API). Additionally, the  fire  method has changed such that the first argument may be a context object. Any events that need to send an object to the callback as the first post-context argument will need to supply a placeholder context object e.g.  ractive.fire( 'event', { first: 'arg' } )  becomes  ractive.fire( 'event', {}, { first: 'arg' } ) .", 
            "title": "Instance events"
        }, 
        {
            "location": "/support/#ractivemerge", 
            "text": "ractive.merge  has been removed and replaced by an option on  ractive.set ,  { shuffle: true } , which more accurately reflects what actually happens.  merge  did not merge data, but instead re-arranged any DOM associated with the elements in the given array to match the order of the array - hence  shuffle  rather than  merge .", 
            "title": "ractive.merge"
        }, 
        {
            "location": "/support/#isolation", 
            "text": "Components are now  isolated  by default. If you need non- isolated  components in order to create implicit mappings as data is accessed, you can pass  isolated: false  to  extend  when creating the component. If you prefer all components to be non- isolated  by default, you can set  Ractive.defaults.isolated = false .  Further, non- isolated  components will now create implicit mappings when necessary for  set  operations, including  add ,  subtract , etc, in addition to  get  operations. To avoid creating an implicit mapping with a  set  operation from a non- isolated  component, pass  { isolated: true }  as an option to the  set  method.", 
            "title": "Isolation"
        }, 
        {
            "location": "/support/#magic-and-array-adaptors", 
            "text": "The magic and array adaptors are no longer part of Ractive.js core. They may be reappear as independent plugins at some point in the future.", 
            "title": "Magic and array adaptors"
        }, 
        {
            "location": "/support/#class-directives", 
            "text": "class-  directives are now parsed in an expression context like decorator, transition, and event directives, rather than in a string context like attributes and  style-  directives. This means that mustaches are no longer required for  class-  directive values, so you should use  class-selected=\".selected\"  rather than  class-selected=\"{{.selected}}\" .", 
            "title": "class- directives"
        }, 
        {
            "location": "/support/#getnodeinfo", 
            "text": "ractive.getNodeInfo  has been renamed to  ractive.getContext , as has the static version of the function, to more accurately reflect its function. The  getNodeInfo  alias is deprecated and will be removed in a future version.", 
            "title": "getNodeInfo"
        }, 
        {
            "location": "/support/#multiple-inheritance", 
            "text": "Components can no longer inherit from multiple other components at the same level, meaning that  Ractive.extend(FirstComponent, SecondComponent)  is no longer possible. You can still set up an inheritance hierachy multiple levels deep with  const First = Ractive.extend({ ...options }); const Second = First.extend({ ...others }); .", 
            "title": "Multiple inheritance"
        }, 
        {
            "location": "/support/#migrating-from-07", 
            "text": "", 
            "title": "Migrating from 0.7"
        }, 
        {
            "location": "/support/#template-format_2", 
            "text": "The template format produced by  Ractive.parse  has changed, making it incompatible with previous versions of Ractive.js and their template formats. You will need to re-parse any pre-parsed templates for use with 0.8.", 
            "title": "Template format"
        }, 
        {
            "location": "/support/#ie8", 
            "text": "IE8 is no longer supported. If you still need to support IE8, well, we're very, very sorry...", 
            "title": "IE8"
        }, 
        {
            "location": "/support/#expressions-and-binding", 
            "text": "Two-way bindings are no longer supported in computed contexts that don't have a  set ter, including template expression contexts. This means that  {{#each filter(list)}} input value=\"{{.name}}\" / {{/each}}  is no longer possible. The reasoning behind this change is that the original  list.${index}.name  is not updated when the binding within the computed context in the  each  expression is changed. 0.9 adds an instance flag  syncComputedChildren  that can address this.", 
            "title": "Expressions and binding"
        }, 
        {
            "location": "/support/#relaxed-partial-names", 
            "text": "Partial names can now include  \\  characters, which can be problematic if you happen to use division with no spaces arount the  /  in a partial expression.", 
            "title": "Relaxed partial names"
        }, 
        {
            "location": "/support/#integer-references", 
            "text": "Integers are no longer considered references, even in an array context, meaning that in  {{#with [1, 2, 3]}}{{0}}{{/with}}  will no longer result in  1  being rendered. Integers are now stricly considered to integer literals. If you need to reference a specific index in an array context, you can do so with a context specific reference like  {{this.0}} .", 
            "title": "Integer references"
        }, 
        {
            "location": "/support/#array-modification", 
            "text": "modifyArrays  now defaults to  false , so the array adaptor is not applied to arrays automatically as they are added to the instance data. The preferred method of performing array operations is using the  splice ,  push ,  pop , etc methods on the Ractive.js instance.", 
            "title": "Array modification"
        }, 
        {
            "location": "/support/#migrating-from-06", 
            "text": "", 
            "title": "Migrating from 0.6"
        }, 
        {
            "location": "/support/#whats-new", 
            "text": "Components can now access their parents and containers using an official API.  Binding directives may be set on elements that support two-way binding. These directives override the settings on the Ractive instance for  twoway  and  lazy .  Single-fire versions of  ractive.on  and  ractive.observe  are now available as  ractive.once  and  ractive.observeOnce .  Inline partials can now be defined within a new section  {{#partial partial-name}}...{{/partial}} . The old comment syntax is now deprecated and will be removed in a future release.  Inline partials are now scoped to their nearest element. If a partial reference sits in the template below an element with a matching inline partial, the inline partial will be used in the reference. This can be used as a sort of partial inheritance. If an inline partial is defined directly within a component tag or the root of the template, it will be added to the Ractive instance.  Components may now yield to multiple inline partials by supplying the partial name with yield e.g.  {{yield some-name}} . Yielding without a name will still result in non-partial content being yielded. Only inline partials may be yielded. Any partials, including inline and inherited, may still be referenced within a component using a plain partial section e.g.  {{ partial}} .  Partials can now be reset without resorting to manually un/re-rendering them using a wrapping conditional section. This can be done with the new  resetPartial  method on Ractive instances.  this.event  is now available to method-call event handlers.  Regular expression literals can now be used in template expressions.  You can now escape mustaches with a '\\' if you'd like them to appear in the template.  ractive.toggle  now works with patterns.  The debug setting is no longer set per-instance. It has been replaced with  Ractive.DEBUG , which defaults to true. You can set it automatically based on whether or not the your code has been minified with:  Ractive.DEBUG = /unminified/.test(function(){/*unminified*/})", 
            "title": "What's new"
        }, 
        {
            "location": "/support/#breaking-changes-and-deprecation", 
            "text": "twoway  and  lazy  are now reserved attribute names to be used as binding directives.  Inline partials now belong to their nearest element.  The comment syntax for inline partials is now deprecated.  elseif  is now a reserved identifier.  ractive.data  is no longer available. Use  ractive.get()  to get a shallow copy of the data with any component mappings.  Child data always overrides parent data, whether it is a POJO (Plain Old JS Object) or not.  ractive.debug  has been replaced with the global  Ractive.DEBUG  flag.", 
            "title": "Breaking changes and deprecation"
        }, 
        {
            "location": "/support/#migrating-from-05", 
            "text": "", 
            "title": "Migrating from 0.5"
        }, 
        {
            "location": "/support/#lifecycle-events", 
            "text": "Ractive instances now emit  lifecycle events . If you use  Ractive.extend(...)  with  init() ,  beforeInit()  or  complete() , you will need to replace them - they will continue to work, but will be removed in a future version.  init()  can be replaced with one of the following methods, or you may need to split your code into both methods. Use  onrender()  for code that needs access to the rendered DOM, but is safe being called more than once if you unrender and rerender your ractive instance. Use  oninit()  for code that should run only once or needs to be run regardless of whether the ractive instance is rendered into the DOM.  The  init()  method also no longer recieves an  options  parameter as the ractive instance now inherits  all  options passed to the constructor. You can still access the options directly using the  onconstruct()  method.  beforeInit()  and  complete()  can be replaced directly with  onconstruct()  and  oncomplete()  respectively.  See the lifecycle events page for more detail.", 
            "title": "Lifecycle events"
        }, 
        {
            "location": "/support/#other-breaking-changes", 
            "text": "new Ractive()  now inherits all options as methods/properties including event hooks. If you have been passing data through custom initialisation options be aware that they will appended to your ractive instance.  Using other elements besides  script  for templates is an now an error. Migrate any templates in non-script elements and include a non-javascript type so the browser does not try to interpret your template:   js\n     script id='template' type='text/ractive' \n      Your template goes here\n     /script   New reserved events cannot be used for proxy event names, i.e.  p on-click='init' /p . These include 'change', 'config', 'construct', 'init', 'render', 'reset', 'teardown', 'unrender', and 'update'. You will need to rename your events.  Setting uninitialised data on a component will no longer cause it to leak out into the parent scope  'Smart updates', via  ractive.merge()  and  ractive.shift()  etc, work across component boundaries. In most cases this is the expected behavior.  The CSS length interpolator has been removed.", 
            "title": "Other Breaking changes"
        }, 
        {
            "location": "/support/#migrating-from-04", 
            "text": "", 
            "title": "Migrating from 0.4"
        }, 
        {
            "location": "/support/#breaking-changes", 
            "text": "Errors in observers and evaluators are no longer caught  Nodes are detached as soon as any outro transitions are complete (if any), rather than when  all  transitions are complete  (Outdated if you are moving to  0.6.x  or above) The options argument of  init: function(options)  is now strictly what was passed into the constructor, use  this.option  to access configured value.  data  with properties on prototype are no longer cloned when accessed.  data  from \"baseClass\" is no longer deconstructed and copied.  Options specified on component constructors will not be picked up as defaults.  debug  now on  defaults , not constructor  Select bindings follow general browser rules for choosing options. Disabled options have no value.  Input values are not coerced to numbers, unless input type is  number  or  range  {{this.foo}}  in templates now means same thing as  {{.foo}}  Rendering to an element already render by Ractive causes that element to be torn down (unless appending).  Illegal javascript no longer allowed by parser in expressions and will throw  Parsed template format changed to specify template spec version.  Proxy-event representation  Non-dynamic (bound) fragments of html are no longer stored as single string  See https://github.com/ractivejs/template-spec for current spec.  Arrays being observed via  array.*  no longer send  item.length  event on mutation changes  Reserved event names in templates ('change', 'config', 'construct', 'init', 'render', 'reset', 'teardown', 'unrender', 'update') will cause the parser to throw an error  {{else}}  support in both handlebars-style blocks and regular mustache conditional blocks, but is now a restricted keyword that cannot be used as a regular reference  Child components are created in data order  Reference expressions resolve left to right and follow same logic as regular mustache references (bind to root, not context, if left-most part is unresolved).  Improved attribute parsing and handling:  character escaping and whitespace handling in attribute directive arguments  boolean and empty string attributes  Computed properties no longer create nested objects with keypath like names, i.e.  page.area: '${width} * ${height}'  creates a property accessible by  {{page.area}}  but not  {{#page}}{{area}}{{/page}}  The element into which the ractive instance was rendered is no longer available as  ractive.el . See  ractive.render()  and  ractive.insert()  for more information on moving ractive instances in the DOM.", 
            "title": "Breaking changes"
        }, 
        {
            "location": "/legacy/0.9/api/", 
            "text": "Mustaches\n\n\nVariables\n\n\n{{ }}\n, \n{{\n }}\n and \n{{{ }}}\n render a reference. They are also used for binding when used on directives. \n{{ }}\n escapes the reference while \n{{\n }}\n and \n{{{ }}}\n do not.\n\n\nRactive({\n  data: {\n    name: \nChris\n,\n    company: \nb\nGitHub\n/b\n\n  },\n  template: `\n    {{name}}      \n!-- Chris --\n\n    {{age}}       \n!--  --\n\n    {{company}}   \n!-- \nlt;b\ngt;GitHub\nlt;/b\ngt; --\n\n    {{\ncompany}}  \n!-- \nb\nGitHub\n/b\n --\n\n    {{{company}}} \n!-- \nb\nGitHub\n/b\n --\n\n  `\n})\n\n\n\n\nSections\n\n\nSections render a block of markup depending on the value referenced.\n\n\nIf the reference is an array, it renders the block of markup for each item in the array. The context of the section is the value of the currently iterated item. The iteration index is made available by adding a \n:\n after the array reference followed by the index reference.\n\n\nRactive({\n  data: {\n    people: [{name: 'Alice'},{name: 'Bob'},{name: 'Eve'}]\n  },\n  template: `\n    {{#people}} {{name}} {{/people}}\n    {{#people:i}} {{i}} {{name}} {{/people}}\n  `\n})\n\n\n\n\nIf the reference is an object \nand the key reference is provided\n, the section iterates through the object properties. The context of the section is the value of the currently iterated property. The iteration key is made available by adding a \n:\n after the object reference followed by the key reference.\n\n\nRactive({\n  data: {\n    places: { loc1: 'server room', loc2: 'networking lab', loc3: 'pantry'}\n  },\n  template: `\n    {{#places:key}}\n      {{ key }} {{ this }}\n    {{/places}}\n  `\n})\n\n\n\n\nIf the reference is some other truthy value or an object but not providing the iteration key reference, it renders the block of markup using the reference as context.\n\n\nRactive({\n  data: {\n    isAdmin: true,\n    foo: {\n      bar: {\n        baz: {\n          qux: 'Hello, World!'\n        }\n      }\n    }\n  },\n  template: `\n    {{#isAdmin}} Hello Admin! {{/isAdmin}}\n\n    {{#foo.bar.baz}} {{qux}} {{/foo.bar.baz}}\n  `\n})\n\n\n\n\nInverted Sections\n\n\n{{^ }}\n renders a block of markup if the reference is falsy or is an empty iterable.\n\n\nRactive({\n  data: {\n    real: false,\n    people: []\n  },\n  template: `\n    {{^real}} Nope, not real {{/real}}\n\n    {{^people}} There's no people {{/people}}\n  `\n})\n\n\n\n\nOptional section closing text\n\n\nRegular (\n{{# }}\n) and inverted (\n{{^ }}\n) sections can be closed with optional closing text. If the closing text is provided and the section is opened with a reference, the closing text must match the opening text. Otherwise, a warning will be issued for the mismatch. If the section is opened with an expression, the closing text will always be ignored.\n\n\nRactive({\n  data: {\n    items: [1,2,3]\n  },\n  template: `\n    {{#items}}\n      {{this}}\n    {{/items}}\n\n    {{#items}}\n      {{this}}\n    {{/}}\n\n    {{# a.concat(b) }}\n      {{this}}\n    {{/ I'm actually ignored but should be something meaningful like a.concat(b) }}\n  `\n})\n\n\n\n\nIf sections\n\n\n{{#if }}\n renders a block of markup if the reference is truthy or a non-empty iterable. \n{{else}}\n and \n{{elseif}}\n are supported and render if the previous condition failed.\n\n\nRactive({\n  data: {\n    foo: false,\n    bar: false\n  },\n  template: `\n    {{#if foo}}\n      foo\n    {{elseif bar}}\n      bar\n    {{else}}\n      baz\n    {{/if}}\n  `\n})\n\n\n\n\nUnless sections\n\n\n{{#unless }}\n renders a block of markup if the reference is falsy or is an empty iterable. Unlike \n{{#if }}\n, the \n{{#unless }}\n section does not support \n{{else}}\n nor \n{{elseif}}\n.\n\n\nRactive({\n  data: {\n    real: false,\n  },\n  template: `\n    {{#unless real}} Fake {{/unless}}\n  `\n})\n\n\n\n\nEach sections\n\n\n{{#each }}\n renders the block of markup for each item in the iterable. The context of the section is the value of the currently iterated item. \n{{else}}\n and \n{{elseif}}\n are supported and render if the iterable is empty.\n\n\nRactive({\n  data: {\n    people: [{name: 'Alice'},{name: 'Bob'},{name: 'Eve'}]\n  },\n  template: `\n    {{#each people}}\n      Hi! I'm {{name}}!\n    {{else}}\n      There's nobody here\n    {{/each}}\n  `\n})\n\n\n\n\nWith sections\n\n\n{{#with }}\n alters the current section's context by sticking a reference in front of the resolution order. This causes everything within the section to resolve to that reference's context and data hierarchy first before the original section's.\n\n\nRactive({\n  el: 'body',\n  append: true,\n  data: {\n    foo: {\n      qux: 2,\n      bar: {\n        baz: 1\n      }\n    },\n    fee: {\n      baz: 'a'\n    }\n  },\n  template: `\n    \n!-- context becomes foo --\n\n    {{#foo}}\n\n      \n!-- context becomes foo.bar --\n\n      {{#bar}}\n\n        \n!-- resolution order: [foo.bar.baz], foo.baz, baz --\n\n        {{baz}}\n\n        \n!-- resolution order: foo.bar.qux, [foo.qux], baz --\n\n        {{qux}}\n\n        \n!-- sticks fee in front of foo.bar on the resolution order --\n\n        {{#with ~/fee}}\n\n          \n!-- resolution order: [fee.baz], foo.bar.baz, foo.baz, baz --\n\n          {{baz}}\n\n          \n!-- resolution order: fee.qux, foo.bar.qux, [foo.qux], qux --\n\n          {{qux}}\n        {{/with}}\n\n      {{/}}\n    {{/}}\n  `\n})\n\n\n\n\n{{else}}\n and \n{{elseif}}\n are supported and render when the context reference does not exist.\n\n\nRactive({\n  data: {},\n  template: `\n    {{#with people}}\n      {{joe}}\n    {{/else}}\n      Context missing\n    {{/with}}\n  `\n})\n\n\n\n\n{{#with }}\n also allows aliasing of references, including special references. Aliasing is in the form of \nreference as alias\n pairs. Multiple alias pairs can be done by separating each with a comma. In this mode, the context within the block is not altered.\n\n\nRactive({\n  el: 'body',\n  append: true,\n  data: {\n    foo: 1,\n    bar: {\n      foo: 2,\n      baz: 3\n    }\n  },\n  template: `\n    {{foo}} \n!-- 1 --\n\n\n    {{#with foo as qux, @global as world}}\n      {{#bar}}\n        {{qux}} \n!-- 1 --\n\n        {{foo}} \n!-- 2 --\n\n        {{baz}} \n!-- 3 --\n\n      {{/}}\n    {{/with}}\n  `\n})\n\n\n\n\nIn-template partials\n\n\n{{#partial }}\n defines a partial that is scoped to the nearest enclosing element or the containing component if defined at the top level of the template.\n\n\nRactive({\n  data: {\n    people: [{name: 'Alice'},{name: 'Bob'},{name: 'Eve'}],\n    places: [{name: 'server room'},{name: 'networking lab'},{name: 'pantry'}]\n  },\n  template: `\n    {{#partial item}}\n      \nli class=\nitem\n{{this}}!\n/li\n\n    {{/partial}}\n\n    \nul\n\n      {{#each people}}\n        {{\n item }}\n      {{/each}}\n    \n/ul\n\n\n    \nul\n\n      {{#each places}}\n        {{\n item }}\n      {{/each}}\n    \n/ul\n\n\n    \ndiv\n\n      {{#partial scopedPartial}}\n        \nli class=\nitem\n{{this}}!\n/li\n\n      {{/partial}}\n\n      \nul\n\n        {{#each things}}\n          {{\n scopedPartial }}\n        {{/each}}\n      \n/ul\n\n    \n/div\n\n  `\n})\n\n\n\n\nStatic mustaches\n\n\n[[ ]]\n, \n[[\n ]]\n and \n[[[ ]]]\n render the reference only during the initial render. After the initial render, any changes to the referece will not update the UI, nor does any change on bound UI elements cause the reference to change. They are the one-time render counterparts of \n{{ }}\n, \n{{\n }}\n and \n{{{ }}}\n, respectively.\n\n\nconst instance = Ractive({\n  data: {\n    msg: 'Hello, World!',\n    admin: false\n  },\n  template: `\n    Will change when updated: {{ msg }}     \n!-- changes to \nMe, Hungry!\n after the change --\n\n    Will not change when updated: [[ msg ]] \n!-- remains \nHello, World!\n after the change --\n\n\n    [[# if admin ]]\n      Hello, admin\n    [[else]]\n      Hello, normal user\n    [[/if]]\n  `\n})\n\ninstance.set({ msg: 'Me, Hungry!' })\ninstance.set('admin', true) // rendering remains 'Hello, normal user'\n\n\n\n\nExpressions\n\n\nExpressions in mustaches are evaluated, and its result is used as the referenced value. Any changes to the expression's dependencies will re-evaluate the expression and update the rendered value. References to variables are taken from the current context and follow the regular reference resolution routine.\n\n\nRactive({\n  data: {\n    num1: 2,\n    num2: 3,\n    a: [1,2,3],\n    b: [4,5,6],\n    fn: () =\n true\n  },\n  template: `\n    {{ num1 + num2 }}\n\n    {{# a.concat(b) }} {{this}} {{/}}\n    {{#each a.concat(b) }} {{this}} {{/each}}\n\n    {{# fn() }} Yasss!!! {{/}}\n    {{#if fn() }} Yasss!!! {{/if}}\n  `\n})\n\n\n\n\nAlmost any valid JavaScript expression can be used, with a few exceptions:\n\n\n\n\nNo assignment operators (i.e. \na = b\n, \na += 1\n, \na--\n and so on).\n\n\nNo \nnew\n, \ndelete\n, or \nvoid\n operators.\n\n\nNo function literals (i.e. anything that involves the \nfunction\n keyword).\n\n\n\n\nExpressions support only a subset of globals:\n\n\n\n\nArray\n\n\nDate\n\n\nJSON\n\n\nMath\n\n\nNaN\n\n\nRegExp\n\n\ndecodeURI\n\n\ndecodeURIComponent\n\n\nencodeURI\n\n\nencodeURIComponent\n\n\nisFinite\n\n\nisNaN\n\n\nnull\n\n\nparseFloat\n\n\nparseInt\n\n\nundefined\n\n\n\n\nComments\n\n\n{{! }}\n defines a template comment. Comments are ignored by the parser and never make it to the AST.\n\n\nRactive({\n  template: `\n    \nh1\nToday{{! ignore me }}.\n/h1\n\n  `\n})\n\n\n\n\nNote:\n \n{{!foo}}\n is also a valid expression, and expressions have a higher precedence in the parser than comments. To ensure that your comments are always treated as such, you can add a \n#\n after the \n!\n e.g. \n{{!# comment }}\n because \n#\n is never valid in an expression.\n\n\nCustom delimiters\n\n\n{{= =}}\n defines custom delimiters. Custom delimiters should not contain whitespace or the equals sign.\n\n\nRactive({\n  data: {\n    msg: 'Hello, World!'\n  },\n  template: `\n    {{ msg }}\n\n    {{=\n% %\n=}}\n    \n% msg %\n\n  `\n})\n\n\n\n\nEscaping mustaches\n\n\n\\\n prepended on a mustache interprets the mustache as literal text.\n\n\n{{ ref }} \\{{ ref }} \n!-- value {{ ref }} --\n\n\n\n\n\nFor multi-mustache structures, \n\\\n must be prepended on all involved mustaches.\n\n\n\\{{#if foo }} \\{{ bar }} \\{{/if}} \n!-- {{#if foo }} {{ bar }} {{/if}} --\n\n\n\n\n\nTo interpret a \n\\\n as a literal slash before a mustache, simply prepend another \n\\\n. Any further \n\\\n prepended will be treated in this manner.\n\n\nRactive({\n  data: {\n    msg: 'Hello, World!'\n  },\n  template: `\n    \\\\{{ msg }}   \n!-- \\Hello, World! --\n\n    \\\\\\{{ msg }}  \n!-- \\\\Hello, World! --\n\n    \\\\\\\\{{ msg }} \n!-- \\\\\\Hello, World! --\n\n  `\n})\n\n\n\n\nAnchors\n\n\n# /\n define anchors which are mounting points where instances can be mounted to dynamically during runtime.\n\n\nExamples\n\n\nExample 1\n\n\n\n\n\nconst MyComponent = Ractive.extend({\n  template: `\n    \ndiv\n{{ message }}\n/div\n\n  `\n})\n\nRactive({\n  target: 'body',\n  data: {\n    msg: 'Hello, World!'\n  },\n  template: `\n    \n# mountpoint7 /\n\n  `,\n  oninit () {\n    // Create new instance\n    const myComponent = MyComponent()\n\n    // Link msg of parent to message of instance\n    myComponent.link('msg', 'message', { ractive: this })\n\n    // It's mount'in time!\n    this.attachChild(myComponent, { target: 'mountpoint7'})\n  }\n})\n\n\n\n\nExample 2\n: Attaching, detaching, firing events, creating two-way bindings within the template\n\n\n\n\n\nMyComponent = Ractive.extend({\n    template: ...\n})\n\nRactive({\n    ...\n    template: `\n        \nbutton on-click=\nmove\nmove it\n/button\n\n        \n# mountpoint-one on-click=\nhello\n message=\n{{msg}}\n /\n\n        \n# mountpoint-two on-click=\nhello\n message=\n{{ msg + ' + ' + msg }}\n /\n\n        \ninput value=\n{{msg}}\n /\n\n    `,\n    onrender () {\n        // Create new instance\n        myInstance = MyComponent()\n        this.attachChild(myInstance, { target: 'mountpoint-one'})\n        this.on({\n            move () {\n                this.detachChild(myInstance)\n                this.attachChild(myInstance, { target: 'mountpoint-two'})\n            },\n            hello(ctx) {\n                // fire an event as you would do with a regular component\n            }\n        })\n    }\n})\n\n\n\n\n{{\ncontent}}\n\n\n{{\ncontent}}\n renders the inner HTML in the context of the component. Partials, components, and any other valid template items can be used as inner HTML.\n\n\nRactive.components.ChildComponent = Ractive.extend({\n  template: `\n    \ndiv class=\nchild-component\n{{\ncontent}}\n/div\n\n  `\n})\n\nconst ractive = Ractive({\n  el: 'body',\n  data: {\n    message: 'Hello World!'\n  },\n  template: `\n    \ndiv class=\nractive\n\n      \nChildComponent message=\nLorem Ipsum\n\n        \n!-- Prints \nLorem Ipsum\n --\n\n        \ndiv class=\ninner-content\n{{ message }}\n/div\n\n      \n/ChildComponent\n\n    \n/div\n\n  `\n})\n\n\n\n\nPartials defined in the inner HTML can be used to override partials defined on the component.\n\n\nRactive.components.ChildComponent = Ractive.extend({\n  partials: {\n    messageWrapper: '\nstrong\n{{message}}\n/strong\n'\n  },\n  template: `\n    \ndiv class=\nchild-component\n{{\ncontent}}\n/div\n\n  `\n})\n\nconst ractive = Ractive({\n  el: 'body',\n  data: {\n    message: 'Hello World!'\n  },\n  template: `\n    \ndiv class=\nractive\n\n      \nChildComponent message=\nLorem Ipsum\n\n\n        \n!-- Override component's messageWrapper --\n\n        {{#partial messageWrapper}}\nem\n{{message}}\n/em\n{{/}}\n\n        \ndiv class=\ninner-content\n\n          \n!-- Renders emphasized instead of strong --\n\n          {{\n messageWrapper }}\n        \n/div\n\n\n      \n/ChildComponent\n\n    \n/div\n\n  `\n})\n\n\n\n\n{{yield}}\n\n\n{{yield}}\n renders the inner HTML in the context of the parent component. Partials, components, and any other valid template items can be used as inner HTML.\n\n\nRactive.components.ChildComponent = Ractive.extend({\n  template: `\n    \ndiv class=\nchild-component\n{{ yield }}\n/div\n\n  `\n})\n\nconst ractive = Ractive({\n  el: 'body',\n  data: {\n    message: 'Hello, World!'\n  },\n  template: `\n    \ndiv class=\nractive\n\n      \nChildComponent message=\nLorem Ipsum\n\n        \n!-- Prints \nHello, World!\n --\n\n        \ndiv class=\ninner-content\n{{ message }}\n/div\n\n      \n/ChildComponent\n\n    \n/div\n\n  `\n})\n\n\n\n\nYields can also be customized using named yields. A named yield will look for a partial of the same name in the inner HTML and render that partial instead.\n\n\nRactive.components.ChildComponent = Ractive.extend({\n  template: `\n    \ndiv class=\nchild-component\n\n      {{ yield }}\n      {{ yield italicYield }}\n      {{ yield boldYield }}\n    \n/div\n\n  `\n})\n\nconst ractive = Ractive({\n  el: 'body',\n  data: {\n    message: 'Hello World!'\n  },\n  template: `\n    \ndiv class=\nractive\n\n      \nChildComponent message=\nLorem Ipsum\n\n\n        \n!-- Printed by {{ yield italicYield }} --\n\n        {{#partial italicYield }}\nem\n{{message}}\n/em\n{{/}}\n\n        \n!-- Printed by {{ yield boldYield }} --\n\n        {{#partial boldYield }}\nstrong\n{{message}}\n/strong\n{{/}}\n\n        \n!-- Anything not a partial is printed by {{ yield }} --\n\n        {{message}}\n      \n/ChildComponent\n\n    \n/div\n\n  `\n})\n\n\n\n\nSince the yielded content exists entirely in the context of the container (as opposed to the component), there's no way for the yielded content to access data in the component that is yielding. To address that, yields may supply aliases that are made available to the yielded content:\n\n\nconst list = Ractive.extend({\n  template: `\n    \nul\n\n      {{#each items}}\n        \n!-- Expose item and index to yield context. --\n\n        \nli\n{{yield with . as item, @index as index}}\n/li\n\n      {{/each}}\n    \n/ul\n\n  `\n})\n\nconst ractive = Ractive({\n  el: 'body',\n  data: {\n    some: {\n      list: [ 1, 2, 3 ]\n    }\n  },\n  select(i) { console.log('you picked', i); },\n  template: `\n    \n!-- Pass in some.list as items into list. --\n\n    \nlist items=\n{{some.list}}\n\n\n      \n!-- Access item and index aliases. --\n\n      \na href=\n#\n on-click=\n@.select(item)\nItem {{index}}\n/a\n\n    \n/list\n\n  `,\n  components: { list }\n})\n\n\n\n\nWithout the given alises, iterating a list within the component to yield the content would be useless, because the content would not have access to the current iteration. You could get around that by using a normal partial rather than a yield, but at that point, the click event on the content would result in an error because the \nselect\n method does not exist on the \nlist\n component.\n\n\nYield aliases are also available for named yields.\n\n\nconst Pager = Ractive.extend({\n  template: `\n    \nul\n\n      \nli\n{{ yield prev }}\n/li\n\n      {{#each pages}}\n        \nli\n{{yield link with . as page}}\n/li\n\n      {{/each}}\n      \nli\n{{ yield next }}\n/li\n\n    \n/ul\n\n  `\n})\n\nconst ractive = Ractive({\n  components: { Pager },\n  el: 'body',\n  data: {\n    book: {\n      pages: [ 1, 2, 3 ]\n    }\n  },\n  template: `\n    \nPager pages=\n{{ book.pages }}\n\n      {{#partial prev}}\na href=\n#prev\nPrev\n/a\n{{/partial}}\n      {{#partial link}}\na href=\n#{{ page }}\n{{ page }}\n/a\n{{/partial}}\n      {{#partial next}}\na href=\n#next\nNext\n/a\n{{/partial}}\n    \n/Pager\n\n  `,\n})\n\n\n\n\nData binding\n\n\nText inputs\n\n\nData can be bound to text inputs via the \nvalue\n directive. This includes text-like inputs such as password, email, color, tel, date, etc.\n\n\nRactive({\n  template: `\n    \ninput type=\ntext\n value=\n{{ msg }}\n\n  `,\n  data: {\n    msg: 'Hello, World!'\n  }\n})\n\n\n\n\nNumber inputs\n\n\nNumeric data can be bound to number inputs via the \nvalue\n directive. This includes number-like inputs such as range. The value from the input will automatically be converted into a number. When the input is blank, the value returned is \nundefined\n.\n\n\nRactive({\n  template: `\n    \ninput type=\nnumber\n value=\n{{ daysWithoutSleep }}\n\n  `,\n  data: {\n    daysWithoutSleep: 2\n  }\n})\n\n\n\n\nFile inputs\n\n\nFile data can be bound to file inputs via the \nvalue\n directive. The value from the input is an instance of \nFileList\n.\n\n\nRactive({\n  template: `\n    \ninput type=\nfile\n value=\n{{ file }}\n\n  `,\n  data: {\n    file: /* FileList instance */\n  }\n})\n\n\n\n\nor by using events:\n\n\n\n\n\nRactive({\n  ...\n  template: `\n    {{#each foo}}\n    \np\n\n      {{.}} : \ninput on-change=\nhello\n type=\nfile\n /\n\n    \n/p\n\n    {{/each}}\n  `,\n  on:{\n    hello (ctx) {\n      files = ctx.node.files\n      keypath = ctx.resolve()\n      console.log('selected files:', files)\n      console.log('first file:', files[0])\n      console.log('current context: ', keypath)\n    }\n  },\n  data:{\n    foo: [1, 2, 3]\n  }\n})\n\n\n\n\nCheckboxes\n\n\nBoolean data can be bound to checkboxes via the \nchecked\n directive.\n\n\nRactive({\n  template: `\n    \ninput type=\ncheckbox\n checked=\n{{ isChecked }}\n\n  `,\n  data: {\n    isChecked: true\n  }\n})\n\n\n\n\nArray data can also be bound to checkboxes via the \nname\n directive.\n\n\nRactive({\n  template: `\n    \ninput type=\ncheckbox\n name=\n{{ selectedItems }}\n value=\n1\n\n    \ninput type=\ncheckbox\n name=\n{{ selectedItems }}\n value=\n2\n\n    \ninput type=\ncheckbox\n name=\n{{ selectedItems }}\n value=\n3\n\n  `,\n  data: {\n    selectedItems: ['1', '2']\n  }\n})\n\n\n\n\nWhen both \nchecked\n and \nname\n bindings are present, the binding to \nchecked\n will be honored and the binding to \nname\n will be treated as a regular interpolation.\n\n\nRadio buttons\n\n\nBoolean data can be bound to radio buttons via the \nchecked\n directive.\n\n\nRactive({\n  template: `\n    \ninput type=\nradio\n name=\noptions\n checked=\n{{ option1 }}\n\n    \ninput type=\nradio\n name=\noptions\n checked=\n{{ option2 }}\n\n    \ninput type=\nradio\n name=\noptions\n checked=\n{{ option3 }}\n\n  `,\n  data: {\n    option1: false,\n    option2: true,\n    option3: false\n  }\n})\n\n\n\n\nData can also be bound to radio buttons via the \nname\n directive.\n\n\nRactive({\n  template: `\n    \ninput type=\nradio\n name=\n{{ selectedOption }}\n value=\n1\n\n    \ninput type=\nradio\n name=\n{{ selectedOption }}\n value=\n2\n\n    \ninput type=\nradio\n name=\n{{ selectedOption }}\n value=\n3\n\n  `,\n  data: {\n    selectedOption: '1'\n  }\n})\n\n\n\n\nText areas\n\n\nData can be bound to text areas via the \nvalue\n directive.\n\n\nRactive({\n  template: `\n    \ntextarea value=\n{{ msg }}\n/textarea\n\n  `,\n  data: {\n    msg: 'Hello, World!'\n  }\n})\n\n\n\n\nData can also be bound to text areas via its contents.\n\n\nRactive({\n  template: `\n    \ntextarea\n{{ msg }}\n/textarea\n\n  `,\n  data: {\n    msg: 'Hello, World!'\n  }\n})\n\n\n\n\nSelect lists\n\n\nData can be bound to select lists via the \nvalue\n directive.\n\n\nRactive({\n  template: `\n    \nselect value=\n{{ selectedOption }}\n\n      \noption value=\n1\nRed\n/option\n\n      \noption value=\n2\nGreen\n/option\n\n      \noption value=\n3\nBlue\n/option\n\n    \n/select\n\n  `,\n  data: {\n    selectedOption: '2'\n  }\n})\n\n\n\n\nArray data can also be bound to select lists with the \nmultiple\n attribute via the \nvalue\n directive.\n\n\nRactive({\n  template: `\n    \nselect multiple value=\n{{ selectedItems }}\n\n      \noption value=\n1\nRed\n/option\n\n      \noption value=\n2\nGreen\n/option\n\n      \noption value=\n3\nBlue\n/option\n\n    \n/select\n\n  `,\n  data: {\n    selectedItems: [ '2', '3' ]\n  }\n})\n\n\n\n\ncontenteditable\n\n\nData can be bound to elements that have the \ncontenteditable\n attribute via the \nvalue\n directive.\n\n\nRactive({\n  template: `\n    \ndiv contenteditable=\ntrue\n value=\n{{ msg }}\n/div\n\n  `,\n  data: {\n    msg: 'Hello, World!'\n  }\n})\n\n// Rendered as:\n// \ndiv contenteditable=\ntrue\nHello, World!\n/div\n\n\n\n\n\nThere are a few caveats when binding to an element with \ncontenteditable\n:\n\n\n\n\nThe returned string may or may not always be HTML.\n\n\nThe returned string may be different from browser to browser.\n\n\nAny value set on the bound data will always be rendered as HTML.\n\n\n\n\nDirectives\n\n\ntwoway\n\n\nThe element-specific directive form of the \ntwoway\n initialization option.\n\n\n!-- By default, two-way is enabled. Editing the input updates foo. --\n\nTwo-way: \ninput type=\ntext\n value=\n{{ foo }}\n {{ foo }}\n\n\n!-- With twoway=\nfalse\n, editing the input will not update bar. --\n\nOne-way: \ninput type=\ntext\n value=\n{{ bar }}\n twoway=\nfalse\n {{ bar }}\n\n\n!-- Updating bar via the data will update the UI --\n\n\nbutton type=\nbutton\n on-click=\n@this.set('bar', 'baz')\nSet value to bar\n/button\n\n\n\n\n\nlazy\n\n\nThe element-specific directive form of the \nlazy\n initialization option.\n\n\n!-- Editing the input updates foo on keypress. --\n\nEager: \ninput type=\ntext\n value=\n{{ foo }}\n {{ foo }}\n\n\n!-- Editing the input updates bar only when focus moves away from the input. --\n\nLazy: \ninput type=\ntext\n value=\n{{ bar }}\n lazy=\ntrue\n {{ bar }}\n\n\n!-- Editing the input updates bar only five seconds after the change. --\n\nLazy: \ninput type=\ntext\n value=\n{{ bar }}\n lazy=\n5000\n {{ bar }}\n\n\n\n\nas-*\n\n\nas-*\n directives augment the element with decorators. It accepts optional, comma-separated expressions as arguments to the decorator function.\n\n\ndiv as-modal\nDiv appearing as modal\n/div\n\n\ndiv as-modal=\ntrue, true, true, false\nDiv appearing as modal\n/div\n\n\n\n\n\nclass-*\n\n\nclass-*\n directives toggle individual class names based on the truthiness of its value. The part of the directive name following \nclass-\n will be used as the class name. \nclass-*\n directive values are processed as expressions. If there is no expression, the implicit value is \ntrue\n, which is useful for applying multiple classes to an element using component \nextra-attributes\n.\n\n\ndiv class-foo=\nisFoo\nAdds \nfoo\n if isFoo is truthy\n/div\n\n\ndiv class-foo-bar=\nisFooBar\nAdds \nfoo-bar\n if isFooBar is truthy\n/div\n\n\ndiv class-fooBar=\nisFooBar\nAdds \nfooBar\n if isFooBar is truthy\n/div\n\n\ndiv class-baz\nAlways has \nbaz\n/div\n\n\n\n\n\non-*\n\n\non-*\n directives attach event handlers to DOM elements and components. \non-*\n can be used in two ways: proxy syntax or the expression syntax.\n\n\nRactive({\n  template: `\n    \nbutton type=\nbutton\n on-click=\nclickedproxy\nPush me!\n/button\n\n    \nbutton type=\nbutton\n on-click=\n['clickedArray', 'Hello, World!']\nPush me!\n/button\n\n    \nbutton type=\nbutton\n on-click=\n@this.clickedMethod('Hello, World!')\nPush me!\n/button\n\n  `,\n  on: {\n    clickedproxy (context) {\n      console.log('Hello, World!')\n    },\n    clickedArray (context, msg) {\n      console.log(msg)\n    }\n  },\n  clickedMethod(msg) {\n    console.log(msg)\n  }\n})\n\n\n\n\nMultiple events can also be tied to the same handler by appending event names to the directive, separating them by hyphens:\n\n\nRactive({\n  template: `\n    \nbutton type=\nbutton\n on-hover-click=\n@this.someMethod()\nPush me!\n/button\n\n  `,\n  someMethod () {\n    console.log('Fires on hover and on click!')\n  }\n})\n\n\n\n\n*-in, *-out, *-in-out\n\n\n*-in\n, \n*-out\n, and \n*-in-out\n directives apply transitions to the element. \n*-in\n specifies intro-only, \n*-out\n specifies outro-only, and \n*-in-out\n for both intro and outro. All three directives accept optional, comma-separated expressions as arguments to the transition function.\n\n\ndiv fade-in\nFades on render\n/div\n\n\ndiv fade-out\nFades before removal\n/div\n\n\ndiv fade-in-out\nFades on render and before removal\n/div\n\n\ndiv fade-in-out=\n{ duration: 500 }, someOtherArg\nFades with 500ms duration\n/div\n\n\n\n\n\nstyle-*\n\n\nstyle-*\n directives update individual \nstyle\n properties of the element. The part of the directive following \nstyle-\n will be used as the style property name. Style names can either be in kebab case or camel case, and will be normalized on application.\n\n\ndiv style-vertical-align=\nmiddle\nApplies style.verticalAlign\n/div\n\n\ndiv style-textAlign=\ncenter\nApplies style.textAlign\n/div\n\n\n\n\n\nstyle-*\n directive values are processed as strings. Mustaches can also be used to supply the values. When the values are updated, the appropriate style property on the element will update to the new value.\n\n\ndiv style-vertical-align=\n{{ vAlign }}\n style-textAlign=\n{{ tAlign }}\n...\n/div\n\n\n\n\n\nKeypath prefixes\n\n\nNormally, keypaths are resolved following a defined routine. But there are times where you want to skip the normal resolution routine and resolve a keypath relative to a specific data context. Keypath prefixes allow you to specify which data context a keypath resolves to, regardless if it resolves to something or not.\n\n\nCurrent context\n\n\nResolves the keypath relative to the current data context.\n\n\n\n\n\nRactive({\n  target: 'body',\n  data: {\n    spoon: 'SPOON',\n    matrix: {\n      agent: 'Smith'\n      // There is no spoon\n    }\n  },\n  template: `\n    \ndiv\nOutside the matrix, you have {{ spoon }}\n/div\n\n    {{# matrix }}\n      \ndiv\nInside the matrix, you think you have {{ spoon }}.\n/div\n\n      \ndiv\nIn reality, there is no {{ ./spoon }}\n/div\n\n    {{/}}\n  `\n})\n\n// Outside the matrix, you have SPOON\n// Inside the matrix, you think you have SPOON.\n// In reality, there is no\n\n\n\n\nParent keypath\n\n\nResolves the keypath relative to the parent data. This prefix can be used more than once to reference ancestors.\n\n\n\n\n\nRactive({\n  target: 'body',\n  data: {\n    id: 'reality',\n    dream: {\n      id: 'dream1',\n      dream: {\n        id: 'dream2',\n        dream: {\n          id: 'dream3',\n        }\n      }\n    }\n  },\n  template: `\n    \ndiv\nYou are in {{ id }}\n/div\n\n    {{# dream }}\n      \ndiv\nYou are in {{ id }}\n/div\n\n      {{# dream }}\n        \ndiv\nYou are in {{ id }}\n/div\n\n        {{# dream }}\n          \ndiv\nYou are in {{ id }}\n/div\n\n\n          \ndiv\nEscaping...\n/div\n\n          \ndiv\nYou are in {{ ../id }}\n/div\n\n          \ndiv\nYou are in {{ ../../id }}\n/div\n\n          \ndiv\nYou are in {{ ../../../id }}\n/div\n\n        {{/}}\n      {{/}}\n    {{/}}\n  `\n})\n\n// You are in reality\n// You are in dream1\n// You are in dream2\n// You are in dream3\n// Escaping...\n// You are in dream2\n// You are in dream1\n// You are in reality\n\n\n\n\nParent context\n\n\nWhile parent keypaths and parent contexts are often the same thing, there are some scenarios in which they are very, very different. For instance, in this horribly contrived example:\n\n\n\n\n\nRactive({\n  target: 'body',\n  data: {\n    homebase: {\n      building1: { name: 'Operations' }\n    },\n    bases: [\n      {\n        building1: { name: 'Mess Hall' }\n      },\n      {\n        building1: { name: 'Medical Tent' }\n      }\n    ]\n  },\n  template: `\n    {{#each bases}}\n      {{#with ~/homebase}}\n        \ndiv\nthe home base bulding1 is {{.building1.name}}\n/div\n\n        \ndiv\nthe current iteration base building1 is {{^^/.building1.name}}\n/div\n\n      {{/with}}\n    {{/each}}\n  `\n})\n\n// the home base bulding1 is Operations\n// the current iteration base building1 is Mess Hall\n// the home base bulding1 is Operations\n// the current iteration base building1 is Medical Tent\n\n\n\n\nInstance root context\n\n\nResolves the keypath relative to the instance's root data context.\n\n\n\n\n\nRactive({\n  target: 'body',\n  data: {\n    room: '1',\n    portal: {\n      room: '2',\n      portal: {\n        room: '3',\n        portal: {\n          room: '4',\n        }\n      }\n    }\n  },\n  template: `\n    {{# portal }}\n      {{# portal }}\n        {{# portal }}\n          \ndiv\nEntering...\n/div\n\n          \ndiv\nYou are in room {{ ~/room }}\n/div\n\n          \ndiv\nYou are in room {{ ~/portal.room }}\n/div\n\n          \ndiv\nYou are in room {{ ~/portal.portal.room }}\n/div\n\n          \ndiv\nYou are in room {{ ~/portal.portal.portal.room }}\n/div\n\n        {{/}}\n      {{/}}\n    {{/}}\n  `\n})\n\n// Entering...\n// You are in room 1\n// You are in room 2\n// You are in room 3\n// You are in room 4\n\n\n\n\nSpecial references\n\n\nSpecial references are template keywords that act like data references but do not actually exist in your data. These references provide metadata regarding the current instance, context, environment, operation and more.\n\n\nthis\n\n\nThe current data context.\n\n\n\n\n\nRactive({\n  el: 'body',\n  data: {\n    info: {\n      message: 'Hello World!',\n      info: {\n        message: 'The quick brown fox',\n        info: {\n          message: 'jumps over the lazy dog',\n          info: {\n            message: 'Thats all folks'\n          }\n        }\n      }\n    }\n  },\n  template: `\n    \ndiv\nroot: {{ JSON.stringify(this) }}\n/div\n\n    {{# info }}\n      \ndiv\ninfo 1: {{ JSON.stringify(this) }}\n/div\n\n      {{# info }}\n        \ndiv\ninfo 2: {{ JSON.stringify(this) }}\n/div\n\n        {{# info }}\n          \ndiv\ninfo 3: {{ JSON.stringify(this) }}\n/div\n\n          {{# info }}\n            \ndiv\ninfo 4: {{ JSON.stringify(this) }}\n/div\n\n          {{/}}\n        {{/}}\n      {{/}}\n    {{/}}\n  `,\n})\n\n// info 1: {\ninfo\n:{\nmessage\n:\nHello World!\n,\ninfo\n:{\nmessage\n:\nThe quick brown fox\n,\ninfo\n:{\nmessage\n:\njumps over the lazy dog\n,\ninfo\n:{\nmessage\n:\nThats all folks\n}}}}}\n// info 2: {\nmessage\n:\nHello World!\n,\ninfo\n:{\nmessage\n:\nThe quick brown fox\n,\ninfo\n:{\nmessage\n:\njumps over the lazy dog\n,\ninfo\n:{\nmessage\n:\nThats all folks\n}}}}\n// info 3: {\nmessage\n:\nThe quick brown fox\n,\ninfo\n:{\nmessage\n:\njumps over the lazy dog\n,\ninfo\n:{\nmessage\n:\nThats all folks\n}}}\n// info 4: {\nmessage\n:\njumps over the lazy dog\n,\ninfo\n:{\nmessage\n:\nThats all folks\n}}\n// info 5: {\nmessage\n:\nThats all folks\n}\n\n\n\n\n@this\n\n\nThe current Ractive instance.\n\n\n\n\n\nRactive({\n  el: 'body',\n  data: {\n    count: 1\n  },\n  template: `\n    \ndiv\nCount: {{ count }}\n/div\n\n    \nbutton type=\nbutton\n on-click=\n@this.add('count')\nIncrement\n/button\n\n    \nbutton type=\nbutton\n on-click=\n@this.myMethod()\nLog count\n/button\n\n  `,\n  myMethod () {\n    console.log(`current count is ${this.get('count')}`)\n  }\n})\n\n\n\n\n@this\n can also be referenced by using its shorthand \n@\n.\n\n\n\n\n\nRactive({\n  el: 'body',\n  data: {\n    count: 1\n  },\n  template: `\n    \ndiv\nCount: {{ count }}\n/div\n\n    \nbutton type=\nbutton\n on-click=\n@.add('count')\nIncrement\n/button\n\n    \nbutton type=\nbutton\n on-click=\n@.myMethod()\nLog count\n/button\n\n  `,\n  myMethod () {\n    console.log(`current count is ${this.get('count')}`)\n  }\n})\n\n\n\n\n@index\n\n\nThe current iteration index of the containing repeated section.\n\n\n\n\n\nRactive({\n  el: 'body',\n  data: {\n    users: [\n      { name: 'bob' },\n      { name: 'alice' },\n      { name: 'eve' },\n    ]\n  },\n  template: `\n    {{#each users}}\n      \ndiv\nUser #{{ @index }} says: Hi! I'm {{ name }}!\n/div\n\n    {{/each}}\n  `\n})\n\n// User #0 says: Hi! I'm bob!\n// User #1 says: Hi! I'm alice!\n// User #2 says: Hi! I'm eve!\n\n\n\n\nFor objects, \n@index\n is still the iteration index.\n\n\n\n\n\nRactive({\n  el: 'body',\n  data: {\n    users: {\n      bob: 'Hi! I am bob!',\n      alice: 'Hi! I am alice!',\n      eve: 'Hi! I am eve!'\n    }\n  },\n  template: `\n    {{#each users}}\n      \ndiv\nUser #{{ @index }} says: {{ this }}\n/div\n\n    {{/each}}\n  `\n})\n\n// User #0 says: Hi! I am bob!\n// User #1 says: Hi! I am alice!\n// User #2 says: Hi! I am eve!\n\n\n\n\n@key\n\n\nThe current key name of the containing object iteration section.\n\n\n\n\n\nRactive({\n  el: 'body',\n  data: {\n    users: {\n      bob: 'Hi! I am bob!',\n      alice: 'Hi! I am alice!',\n      eve: 'Hi! I am eve!'\n    }\n  },\n  template: `\n    {{#each users}}\n      \ndiv\nUser {{ @key }} says: {{ this }}\n/div\n\n    {{/each}}\n  `\n})\n\n// User bob says: Hi! I am bob!\n// User alice says: Hi! I am alice!\n// User eve says: Hi! I am eve!\n\n\n\n\nFor arrays, \n@key\n's value will be the iteration index.\n\n\n\n\n\nRactive({\n  el: 'body',\n  data: {\n    users: [\n      { name: 'bob' },\n      { name: 'alice' },\n      { name: 'eve' },\n    ]\n  },\n  template: `\n    {{#each users}}\n      \ndiv\nUser #{{ @key }} says: Hi! I'm {{ name }}!\n/div\n\n    {{/each}}\n  `\n})\n\n// User #0 says: Hi! I'm bob!\n// User #1 says: Hi! I'm alice!\n// User #2 says: Hi! I'm eve!\n\n\n\n\n@keypath\n\n\nThe keypath to the current data context relative to the instance's root data context.\n\n\n\n\n\nRactive({\n  el: 'body',\n  data: {\n    foo: {\n      bar: {\n        baz: {\n          message: 'hello world'\n        }\n      }\n    }\n  },\n  template: `\n    \ndiv\nKeypath: {{ @keypath }}\n/div\n\n    {{# foo }}\n      \ndiv\nKeypath: {{ @keypath }}\n/div\n\n      {{# bar }}\n        \ndiv\nKeypath: {{ @keypath }}\n/div\n\n        {{# baz }}\n          \ndiv\nKeypath: {{ @keypath }}\n/div\n\n        {{/}}\n      {{/}}\n    {{/}}\n  `\n})\n\n// Keypath:\n// Keypath: foo\n// Keypath: foo.bar\n// Keypath: foo.bar.baz\n\n\n\n\nIf the keypath is a mapping, the keypath will remain relative to the instance.\n\n\n\n\n\nRactive.components.Message = Ractive.extend({\n  data: () =\n ({\n    info : {},\n  }),\n  template: `\n    {{# info }}\n      \ndiv\nSender: {{ name }}\n/div\n\n      \ndiv\nMessage: {{ message }}\n/div\n\n      \ndiv\nKeypath: {{ @keypath }}\n/div\n\n    {{/}}\n  `\n})\n\nRactive({\n  el: 'body',\n  data: {\n    mail: {\n      inbox: {\n        messages: [{\n          name: 'bob',\n          message: 'Hi alice!'\n        },{\n          name: 'bob',\n          message: 'Hi eve!'\n        }]\n      }\n    }\n  },\n  template: `\n    {{# mail.inbox.messages }}\n      \nMessage info=\n{{ this }}\n /\n\n    {{/}}\n  `\n})\n\n// Sender: bob\n// Message: Hi alice!\n// Keypath: info\n// Sender: bob\n// Message: Hi eve!\n// Keypath: info\n\n\n\n\n@rootpath\n\n\nThe keypath to the current data context relative to the originating instance's root data context.\n\n\n\n\n\nRactive({\n  el: 'body',\n  data: {\n    foo: {\n      bar: {\n        baz: {\n          message: 'hello world'\n        }\n      }\n    }\n  },\n  template: `\n    \ndiv\nKeypath: {{ @rootpath }}\n/div\n\n    {{# foo }}\n      \ndiv\nKeypath: {{ @rootpath }}\n/div\n\n      {{# bar }}\n        \ndiv\nKeypath: {{ @rootpath }}\n/div\n\n        {{# baz }}\n          \ndiv\nKeypath: {{ @rootpath }}\n/div\n\n        {{/}}\n      {{/}}\n    {{/}}\n  `\n})\n\n// Keypath:\n// Keypath: foo\n// Keypath: foo.bar\n// Keypath: foo.bar.baz\n\n\n\n\nIf the keypath is a mapping, it will be adjusted relative to the originating instance's root data context. This is what primarily sets \n@rootpath\n apart from \n@keypath\n.\n\n\n\n\n\nRactive.components.Message = Ractive.extend({\n  data: () =\n ({\n    info : {},\n  }),\n  template: `\n    {{# info }}\n      \ndiv\nSender: {{ name }}\n/div\n\n      \ndiv\nMessage: {{ message }}\n/div\n\n      \ndiv\nKeypath: {{ @rootpath }}\n/div\n\n    {{/}}\n  `\n})\n\nRactive({\n  el: 'body',\n  data: {\n    mail: {\n      inbox: {\n        messages: [{\n          name: 'bob',\n          message: 'Hi alice!'\n        },{\n          name: 'bob',\n          message: 'Hi eve!'\n        }]\n      }\n    }\n  },\n  template: `\n    {{# mail.inbox.messages }}\n      \nMessage info=\n{{ this }}\n /\n\n    {{/}}\n  `\n})\n\n// Sender: bob\n// Message: Hi alice!\n// Keypath: mail.inbox.messages.0\n// Sender: bob\n// Message: Hi eve!\n// Keypath: mail.inbox.messages.1\n\n\n\n\n@global\n\n\nThe global object of the current environment. For browsers, it references the \nwindow\n object. For Node.js, it references the \nglobal\n object.\n\n\n\n\n\nwindow.message = 'Hello World!'\n\nRactive({\n  el: 'body',\n  template: `\n    {{ @global.message }}\n  `\n})\n\n// Hello World!\n\n\n\n\nRactive can automatically update properties on \n@global\n via two-way binding. However, for changes caused externally, \nractive.update()\n must be called to re-render the UI.\n\n\n\n\n\nwindow.message = 'Hello World!'\n\nRactive({\n  el: 'body',\n  template: `\n    {{ @global.message }}\n    \ninput type=\ntext\n value=\n{{ @global.message }}\n\n    \nbutton type=\nbutton\n on-click=\n@this.logReference()\nLog reference value\n/button\n\n    \nbutton type=\nbutton\n on-click=\n@this.logGlobal()\nLog global value\n/button\n\n    \nbutton type=\nbutton\n on-click=\n@this.setFooBarBaz()\nChange to \nfoo bar baz\n directly\n/button\n\n    \nbutton type=\nbutton\n on-click=\n@this.update('@global.message')\nClick to update\n/button\n\n\n    \nol\n\n      \nli\nClick \nLog reference value\n and look at the console\n/li\n\n      \nli\nClick \nLog global value\n and look at the console\n/li\n\n      \nli\nChange the input value and repeat steps 1 and 2\n/li\n\n      \nli\nClick \nChange to 'foo bar baz' directly\n/li\n\n      \nli\nRepeat steps 1 and 2 and notice that step 1 was not aware of the direct change\n/li\n\n      \nli\nClick \nClick to update\n/li\n\n      \nli\nRepeat steps 1 and 2 and notice that both steps are now aware\n/li\n\n    \n/ol\n\n  `,\n  logReference () {\n    console.log(this.get('@global.message'))\n  },\n  logGlobal () {\n    console.log(window.message)\n  },\n  setFooBarBaz () {\n    window.message = \nfoo bar baz\n\n  }\n})\n\n\n\n\n@shared\n\n\n@shared\n is a Ractive-global model similar to \n@global\n but not subject to interference from outside of Ractive.\n\n\n@context\n\n\nThe context object associated with the current context.\n\n\n@event\n\n\nThe DOM event that is triggering an event directive. This reference is only available to event directive expressions.\n\n\n@node\n\n\nThe DOM node associated with an event directive. This reference is only available to event directive expressions.\n\n\n@local\n\n\nSpecial context-local storage associated with the current context. This is intended more for library use with decorators and parser transforms.\n\n\n@style\n\n\nFrom\n \n0.9.4\n\n\nThe cssData associated with the current instance based on its constructor.\n\n\n$n\n\n\n$n\n is a reference available when handing events using the expression syntax that points to a specific argument passed by the event. Argument positions are denoted by the \nn\n which is a one-indexed integer.\n\n\nconst CustomButton = Ractive.extend({\n  template: `\n    \nbutton on-click=\n@this.fire('buttonevent', 'foo', 'bar')\nClick Me\n/button\n\n  `\n})\n\nRactive({\n  components: { CustomButton },\n  template: `\n    \n!-- Use with proxy expression syntax --\n\n    \nCustomButton on-buttonevent=\n['proxy', $1, $2]\n /\n\n\n    \n!-- Use with method call --\n\n    \nCustomButton on-buttonevent=\n@this.method($1, $2)\n /\n\n  `,\n  on: {\n    proxy (context, foo, bar) {\n      console.log(foo, bar)\n    }\n  },\n  method (foo,bar) {\n    console.log(foo, bar)\n  }\n})\n\n\n\n\narguments\n\n\narguments\n is a reference available when handling events using the expression syntax that points to an array of arguments passed by the event.\n\n\nconst CustomButton = Ractive.extend({\n  template: `\n    \nbutton on-click=\n@this.fire('buttonevent', 'foo', 'bar')\nClick Me\n/button\n\n  `\n})\n\nRactive({\n  components: { CustomButton },\n  template: `\n    \n!-- Use with proxy expression syntax --\n\n    \nCustomButton on-buttonevent=\n['proxy', arguments]\n /\n\n\n    \n!-- Use with method call --\n\n    \nCustomButton on-buttonevent=\n@this.method(arguments)\n /\n\n  `,\n  on: {\n    proxy (context, args) {\n      console.log(args)\n    }\n  },\n  method (foo,bar) {\n    console.log(args)\n  }\n})\n\n\n\n\narguments\n is a normal array instance and not the special \narguments\n JavaScript variable.\n\n\nInitialization Options\n\n\nThe following is an exhaustive list of initialisation options that you can pass to \nRactive()\n and \nRactive.extend()\n. Extra properties passed as options that are not initialization options are added as properties or methods of the instance.\n\n\nvar ractive = Ractive({\n  myMethod () {\n    alert( 'my method was called' )\n  }\n})\n\nractive.myMethod(); // triggers the alert\n\n\n\n\nadapt\n\n\n(Array\nstring|Object\n)\n\n\nAn array of adaptors to use. Values can either be names of registered adaptors or an adaptor definition.\n\n\nadapt: [ 'MyAdaptor', AdaptorDefinition ]\n\n\n\n\nadapt\n is not required if you registered adaptors via the \nadaptors\n initialization property. The adaptors registered via \nadaptors\n initialization property are automatically used as if they were set with \nadapt\n.\n\n\nconst instance = Ractive({\n  adaptors: { MyAdaptor: AdaptorDefinition }\n  // No need to use adapt\n})\n\nconst Component = Ractive.extend({\n  adaptors: { MyAdaptor: AdaptorDefinition }\n  // No need to use adapt\n})\n\nnew Component({\n  // No need to use adapt\n})\n\n\n\n\nadaptors\n\n\n(Object\nstring, Object\n)\n\n\nA map of adaptors where the key is the adaptor name and the value is an adaptor definition.\n\n\nadaptors: {\n  MyAdaptor: AdaptorDefinition\n}\n\n\n\n\nRegistering an adaptor via \nadaptors\n is not required if you directly specified the adaptor definition via \nadapt\n.\n\n\nconst Adaptor = { ... }\n\nconst instance = Ractive({\n  adapt: [ AdaptorDefinition ]\n  // No need to use adaptors\n})\n\n\n\n\nallowExpressions\n\n\n(boolean)\n\n\nIndicates whether or not Ractive should process expressions. Defaults to \ntrue\n.\n\n\nSetting this to \nfalse\n effectively avoids the use of the \nFunction\n constructor at the cost of not being able to use expressions such as those found in templates and computed properties.\n\n\nappend\n\n\n(boolean|string|HTMLElement|array-like)\n\n\nControls how the instance is attached to \nel\n. Defaults to \nfalse\n.\n\n\nfalse\n replaces the contents of \nel\n.\n\n\n!-- before --\n\n\ndiv id='container'\n\n  \np\nexisting content\n/p\n\n\n/div\n\n\n\n\n\nel: '#container',\nappend: false,\ntemplate: '\np\nnew content\n/p\n'\n\n\n\n\n!-- after --\n\n\ndiv id='container'\n\n  \np\nnew content\n/p\n\n\n/div\n\n\n\n\n\ntrue\n appends the instance to \nel\n.\n\n\n!-- before --\n\n\ndiv id='container'\n\n  \np\nexisting content\n/p\n\n\n/div\n\n\n\n\n\nel: '#container',\nappend: true,\ntemplate: '\np\nnew content\n/p\n'\n\n\n\n\n!-- after --\n\n\ndiv id='container'\n\n  \np\nexisting content\n/p\n\n  \np\nnew content\n/p\n\n\n/div\n\n\n\n\n\nAn \nid\n of the element, a CSS selector to an element, an HTML element, or an array-like object whose first item is an HTML element, which is a child of \nel\n will render the instance before that element.\n\n\n!-- before --\n\n\ndiv id='container'\n\n  \np\nred\n/p\n\n  \np\norange\n/p\n\n  \np\nyellow\n/p\n\n\n/div\n\n\n\n\n\nel: '#container',\nappend: document.querySelector('p:nth-child(2)'),\ntemplate: '\np\ngrey\n/p\n'\n\n\n\n\n!-- after --\n\n\ndiv id='container'\n\n  \np\nred\n/p\n\n  \np\ngrey\n/p\n\n  \np\norange\n/p\n\n  \np\nyellow\n/p\n\n\n/div\n\n\n\n\n\nattributes\n\n\n(Object\nstring, [string]|Object\nstring, [string]\n)\n\n\nAn array of optional attributes or a map of optional and required attributes. Defaults to \nundefined\n.\n\n\nYou can supply a list of optional attributes using an array. You can also supply an object with an \noptional\n array of attribute names and a \nrequired\n array of attribute names. At runtime, if a component is created missing a required attribute, Ractive will issue a warning about missing required attributes. Any attributes that are passed to the component that are \nnot\n included in either of the \noptional\n or \nrequired\n lists of attributes will be collected into a partial named \nextra-attributes\n so that they can be included on a top-level element in the component template or split apart to be used in a component \ninit\n event.\n\n\nconst Component = Ractive.extend({\n  template: `\ndiv class-component-wrapper {{yield extra-attributes}}\nFancy component doing something with list and type\n/div\n`,\n  attributes: {\n    required: [ 'list' ],\n    optional: [ 'type' ]\n  }\n})\n\n// \nComponent type=\nfoo\n /\n will issue a warning about missing list\n// \nComponent list=\n{{things}}\n style-color=\ngreen\n /\n will not warn, but will include the style-color=\ngreen\n on the wrapper div\n\n\n\n\nThe extra attributes passed to a component are not limited to simple attributes - they can also include directives, but any mustache sections will not have their contents checked. By default, the \nextra-attributes\n will \nnot\n be mapped, meaning that the values won't be available with \nget\n from the component, so the partial should be yielded. If you need the extra attributes to be mapped, include an additional setting in the attributes map \nmapAll: true\n.\n\n\ncomponents\n\n\n(Object\nstring, Function|Promise)\n\n\nA map of components available to the instance or component being configured. The key is the registered name of the component, which is used in the template.\n\n\nA component can be registered statically by assinging a component definition.\n\n\nconst MyStaticComponent = Ractive.extend({ ... })\n\nconst MyComponent = Ractive.extend({\n  components: { MyStaticComponent },\n  template: `\n    \nMyStaticComponent /\n\n  `\n})\n\n\n\n\nA component can be registered dynamically by assinging a function that returns either a component definition, or a name of a registered component. The function receives \ndata\n as first argument.\n\n\nRactive.components.GlobalComponent = Ractive.extend({ ... })\n\nconst NonGlobalComponent = Ractive.extend({ ... })\n\nconst MyComponent = Ractive.extend({\n  data: { isGlobal: false },\n  components: {\n    MyDynamicComponent: (data) =\n data.isGlobal ? 'GlobalComponent' : NonGlobalComponent\n  },\n  template: `\n    \nMyDynamicComponent /\n\n  `\n})\n\n\n\n\nA component can be loaded asynchronously by assingning a promise that resolves with a component definition.\n\n\n // Assuming MyAsyncComponent.js does `export default Ractive.extend({ ... })`\n\nconst MyComponent = Ractive.extend({\n  components: {\n    MyAsyncComponent: import('./path/to/MyAsyncComponent.js')\n  },\n  template: `\n    \nMyAsyncComponent /\n\n  `\n})\n\n\n\n\nA component can be loaded lazily by assinging a function that returns a promise that resolves with a component definition. Ractive only loads the component when it's being rendered.\n\n\n // Assuming MyAsyncComponent.js does `export default Ractive.extend({ ... })`\n\nconst MyComponent = Ractive.extend({\n  components: {\n    MyAsyncComponent: () =\n import('./path/to/MyAsyncComponent.js')\n  },\n  template: `\n    \nMyAsyncComponent /\n\n  `\n})\n\n\n\n\nIn both asynchronous cases, instances will be rendered immediately while the asynchronous components load. Once the asynchronous components are available, their placeholders will be re-rendered. Two reserved partial names, \nasync-loading\n and \nasync-loaded\n, can be used to define markup when the asynchronous component is loading and loaded, respectively. A special partial named \ncomponent\n is also available to render the component's contents inside \nasync-loaded\n.\n\n\n // Assuming MyAsyncComponent.js does `export default Ractive.extend({ ... })`\n\nconst MyComponent = Ractive.extend({\n  components: {\n    MyAsyncComponent: import('./path/to/MyAsyncComponent.js')\n  },\n  template: `\n    \nspan\nI'm rendered immediately. I don't wait for MyAsyncComponent\n/span\n\n    \nMyAsyncComponent\n\n      {{#partial async-loading}}I'm rendered when MyAsyncComponent is loading{{/partial}}\n      {{#partial async-loaded}}I'm rendered when MyAsyncComponent is loaded{{/partial}}\n      {{#partial async-loaded}}MyAsyncComponent contents: {{\ncomponent}}{{/partial}}\n    \n/MyAsyncComponent\n\n  `\n})\n\n\n\n\nDuring a \nractive.reset()\n, components registered using a function are re-evaluated. If the return value changes, the Ractive instance will be re-rendered.\n\n\ncomputed\n\n\n(Object\nstring, function|Object\n)\n\n\nA map of computed properties where the key is the name of the computed property and the value is either a computed property expression, a function that returns a value, or an object that has \nget\n and \nset\n functions.\n\n\n// Imagine a square...\ncomputed: {\n  // Computed property expression\n  diagonal: '${side} * Math.sqrt(2)',\n\n  // A function\n  perimeter () {\n    return 4 * this.get('side')\n  },\n\n  // An object with get and set functions\n  area: {\n    get () {\n      return Math.pow(this.get('side'), 2)\n    },\n    set (value) {\n      this.set('side', Math.sqrt(value))\n    }\n  },\n}\n\n\n\n\ncsp\n\n\n(boolean)\n\n\nWhether or not to add inline functions for expressions after parsing. Defaults to \nfalse\n.\n\n\nThis can effectively eliminate \neval\n caused by expressions in templates. It also makes the resulting template no longer JSON compatible, so the template will have to be served via \nscript\n tag.\n\n\ncss\n\n\n(string|function)\n\n\nScoped CSS for a component and its descendants.\n\n\ncss: `\n  .bold { font-weight: bold }\n`\n\n\n\n\nAt the moment, only applies to components.\n\n\n// This works\nconst Component = Ractive.extend({\n  css: '...'\n})\n\n// This will not work\nRactive({\n  css: '...'\n})\n\n\n\n\nFrom\n \n0.9.4\n, if \ncss\n is a function, the function will be called with a handle to the component's style data and is expected to return a string of CSS.\n\n\nconst Component = Ractive.extend({\n  css(data) {\n    // you can use Ractive.styleSet('colors.special', 'pink') or Component.styleSet('colors.special', 'pink')\n    // at any time to override the default here, which is green\n    return `\n      .super-special { color: ${data('colors.special') || 'green'}; }\n    `\n  }\n})\n\n\n\n\ncssData\n\n\nFrom\n \n0.9.4\n\n\n(object)\n\n\nLike \ncss\n, this also only applies to components. This is the default data for a component's style computation, if it has one. It is inherited from parent components all the way back to Ractive, and any changes that are made at any point in the hierarchy are automatically propagated down from that point. This means that if a component uses \nfoo\n in its style computation but does not define a value for it in its \ncssData\n, then calling \nRactive.styleSet('foo', ...)\n will cause the component style to recompute.\n\n\ncssId\n\n\n(string)\n\n\nThis value is used to scope CSS defined on a component's \ncss\n initialization option only to the instances of the component. By default, the value is a randomly generated UUID.\n\n\ndata\n\n\n(Object\nstring, any\n|Function)\n\n\nThe data for an instance, or default data for a component. Can either be an object or a function that returns an object.\n\n\n// Object form\ndata: {\n  foo: 'bar'\n}\n\n// Function form\ndata () {\n  return { foo: 'bar' }\n}\n\n// Function form using arrow function for less verbosity\ndata: () =\n ({\n  foo: 'bar'\n})\n\n\n\n\nWhen using the object form, the data is attached to the component's prototype. Standard prototype rules apply.\n\n\nconst Component = Ractive.extend({\n  data: {\n    foo: { bar: 42 }\n  }\n})\n\nvar component1 = Component()\nvar component2 = Component()\ncomponent1.set( 'foo.bar', 12 )\ncomponent2.get( 'foo.bar' ); // returns 12\n\n\n\n\nWhen using the function form, the function is executed to give each instance a copy of the data. Standard prototype rules apply.\n\n\nconst Component = Ractive.extend({\n  data () {\n    return {\n      foo: { bar: 42 }\n    }\n  }\n})\n\nvar component1 = Component()\nvar component2 = Component()\ncomponent1.set( 'foo.bar', 12 )\ncomponent2.get( 'foo.bar' ); // returns 42\n\n\n\n\nWhen extending from a constructor, data from the parent constructor will be shallow-copied over to the child data. Child data takes precedence in the event of collisions.\n\n\nconst Parent = Ractive.extend({\n  data: {\n    foo: 'Hello',\n    bar: 'World'\n  }\n})\n\nconst Child = Parent.extend({\n  data: {\n    foo: 'Goodbye'\n  }\n})\n\nParent().get(); // { foo: 'Hello', bar: 'World' }\nChild().get();  // { foo: 'Goodbye', bar: 'World' }\n\n\n\n\ndecorators\n\n\n(Object\nstring, Function\n)\n\n\nA map of decorators where the key is the decorator name and the value is a decorator definition.\n\n\ndecorators: {\n  MyDecorator: DecoratorDefinition\n}\n\n\n\n\ndelegate\n\n\n(boolean)\n\n\nWhether or not to enable automatic event delegation for iterative sections within an element. Defaults to \ntrue\n.\n\n\nWhen enabled, DOM events subscribed within iterative sections will not add a DOM event listener to each element. Instead, a single listener will be installed on the element containing the iterative section, and that listener will find appropriate event directives starting from the target element and working back to the containing element with the listener.\n\n\ndelimiters\n\n\n(Array[string])\n\n\nSets the template delimiters. Defaults to \n[ '{{', '}}' ]\n.\n\n\ndelimiters: [ '\n%=', '%\n' ],\ntemplate: 'hello \n%= world %\n',\ndata: { world: 'earth' }\n\n// result:\n// hello earth\n\n\n\n\neasing\n\n\n(Object\nstring, Function\n)\n\n\nA map of easing functions where the key is the easing function name and the value is the easing function.\n\n\neasing: {\n  MyEasing: EasingDefinition\n}\n\n\n\n\nel\n\n\n(string|HTMLElement|array-like)\n\n\nThe element to render an instance to. Can either be an \nid\n of the element, a CSS selector to an element, an HTML element, or an array-like object whose first item is an HTML element.\n\n\nel: 'container'\nel: '#container'\nel: document.getElementById('container')\nel: jQuery('#container')\n\n\n\n\nenhance\n\n\n(boolean)\n\n\nWhether or not to apply progressive enhancement by inspecting the contents of \nel\n and try to reuse as much of the existing tree as possible. Defaults to \nfalse\n.\n\n\nThere are a few limitations to this feature:\n\n\n\n\n\n\nThis option cannot be used with \nappend\n.\n\n\n\n\n\n\nUnescaped HTML mustaches (triples) don't play nicely with enhance because there's no easy way to match up the string content to the target DOM nodes.\n\n\n\n\n\n\nAll matching elements will be reused, except for a few cases regarding text nodes.\n\n\ndiv\nleft text {{#if foo}} middle text {{/if}} right text\n/div\n\n\nHTML does not have markup representation for adjacent text nodes. Rendering the snippet above from the server, regardless of \nfoo\n's value, the browser creates one contiguous text node. However, Ractive will need \nthree\n adjacent text nodes to represent it: One for \nouter text\n, another for \nright text\n and another for \nmiddle text\n when \nfoo\n becomes truthy.\n\n\nIt has been suggested that Ractive could deal with merged text nodes, but that would lead to extra complexity as there are certain scenarios where the text node would have to split and rejoin. When \nfoo\n is falsey, \nleft text\n and \nright text\n could be merged. But when \nfoo\n becomes truthy, that text node would have to split in order to accomodate \nmiddle text\n.\n\n\n\n\n\n\nevents\n\n\n(Object\nstring, Function\n)\n\n\nA map of events where the key is the event name and value is an event definition.\n\n\nevents: {\n  MyEvent: EventDefinition\n}\n\n\n\n\ninterpolators\n\n\n(Object\nstring, Function\n)\n\n\nA map of interpolators where the key is the interpolator name and the value is an interpolator definition.\n\n\ninterpolators: {\n  MyInterpolator: InterpolatorDefinition\n}\n\n\n\n\nisolated\n\n\n(boolean)\n\n\nControls whether the component will try to resolve data and plugins on its ancestors. Defaults to \ntrue\n.\n\n\nRelevant only to Components.\n\n\nlazy\n\n\n(boolean|number)\n\n\nWhether or not to update data using late-firing DOM events (i.e. \nchange\n, \nblur\n) instead of events that fire immediately on interaction (i.e. \nkeyup\n, \nkeydown\n). Defaults to \nfalse\n.\n\n\nvar ractive = Ractive({\n  lazy: true,\n  data: { foo: 'bar' },\n  template: `\n    \ninput value=\n{{foo}}\n\n\n    \n!-- Updates when the input loses focus --\n\n    {{ foo }}\n  `\n})\n\n\n\n\nlazy\n also accepts a number value, a millisecond value, that indicates the delay between the last UI interaction and Ractive updating the data. Losing element focus is not required for the update to kick in.\n\n\nvar ractive = Ractive({\n  lazy: 1000,\n  data: { foo: 'bar' },\n  template: `\n    \ninput value=\n{{foo}}\n\n\n    \n!-- Updates 1000ms after the last interaction on input --\n\n    {{ foo }}\n  `\n})\n\n\n\n\nlazy\n is only applicable if \ntwoway\n is \ntrue\n.\n\n\nnestedTransitions\n\n\n(boolean)\n\n\nWhether or not to allow transitions to fire if they are already downstream from a transitioning element. Defaults to \ntrue\n.\n\n\n{{#if outer}}\n  \ndiv fade-in='slow'\n\n    Outer text.\n    {{#if inner}}\n      \ndiv fly-in=\nfast\nInner text.\n/div\n\n    {{/if}}\n  \n/div\n\n{{/if}}\n\n\n\n\nIn this example, if \ninner\n is \ntrue\n when \nouter\n becomes \ntrue\n, then all of the \ndiv\ns will render at the same time. If \nnestedTransitions\n is disabled, then the \nfly\n transition on inner \ndiv\n will not be run, since the \nfade\n will already be running on the outer \ndiv\n.\n\n\nThis can also be controlled per transition using the \nnested\n boolean parameter for transitions:\n\n\ndiv fade-in=\n{ duration: 'slow', nested: false }\n...\n/div\n\n\n\n\n\nnoCssTransform\n\n\n(boolean)\n\n\nPrevents component CSS from being transformed with scoping guids. Defaults to \nfalse\n.\n\n\nnoIntro\n\n\n(boolean)\n\n\nWhether or not to skip intro transitions on initial render. Defaults to \nfalse\n.\n\n\nvar ractive = Ractive({\n  template: '\nul\n{{#items}}\nli fade-in\n{{.}}\n/li\n{{/items}}\n/ul\n',\n  data: { items: [ 'red', 'blue' ] },\n  transitions: {\n    fade ( t, params ) {...}\n  },\n  noIntro: true\n})\n// 'red' and 'blue' list items do not fade in\n\nractive.push( 'items', 'green' )\n// 'green' list item will fade in\n\n\n\n\nnoOutro\n\n\n(boolean)\n\n\nWhether or not to skip outro transitions during an instance unrender. Defaults to \nfalse\n.\n\n\nvar ractive = Ractive({\n  template: '\nul\n{{#items}}\nli fade-out\n{{.}}\n/li\n{{/items}}\n/ul\n',\n  data: { items: [ 'red', 'blue' ] },\n  transitions: {\n    fade ( t, params ) {...}\n  },\n  noOutro: true\n})\n\nractive.pop( 'items' )\n// 'blue' list item will fade out\n\nractive.unrender()\n// 'red' list item will not fade out\n\n\n\n\nobserve\n\n\n(Object\nstring, Function|Object\n)\n\n\nA hash of observers to subscribe during initialization and unsubscribe during teardown. Defaults to \nundefined\n.\n\n\nThe keys of the hash may be any string that is accepted by \nractive.observe()\n, and the values may be either callback functions, as would be passed to \nractive.observe()\n, or objects with a \nhandler\n property that is a callback function. The object form also takes other options that control the behavior of the observer.\n\n\nRactive({\n  // ..\n  observe: {\n    show ( value ) {\n      console.log( `show changed to '${value}'` )\n    },\n    'users.*.name people.*.name': {\n      handler ( value, old, path, idx ) {\n        console.log( `${path} changed to '${value}'` )\n      },\n      init: false,\n      strict: true\n    }\n  }\n})\n\n\n\n\nThe options that may be specified in the object form are (see the \nractive.observe()\n docs for more detailed option descriptions):\n\n\n\n\nhandler (Function)\n: The callback function for the observer.\n\n\nonce (boolean)\n: Use \nractive.observeOnce()\n rather than \nractive.observe()\n to install the observer, meaning the observer is implicitly \ninit: false\n, will only fire for the first change to the observed path, and will by removed after the first change.\n\n\nstrict (boolean)\n: Use strict equality when determining whether or not a value has changed.\n\n\narray (boolean)\n: Use an array observer rather than a plain observer.\n\n\ndefer (boolean)\n: Defer the observer until after the DOM is settled.\n\n\ninit (boolean)\n: Whether or not to fire an initial change event.\n\n\nlinks (boolean)\n: Whether or not to follow links.\n\n\ncontext (any)\n: Context for the callback function.\n\n\nold (Function)\n: Modifier function for the \nold\n value passed to the callback function.\n\n\n\n\nWhen a sublcass created with \nRactive.extend()\n is passed an \nobserve\n hash, then any further subclasses or instances created with an \nobserve\n hash will be combined. Any superclass observers are installed first following the inheritance hierarchy, and finally, any instance observers are installed.\n\n\non\n\n\n(Object\nstring, Function|Object\n)\n\n\nA hash of event listeners to subscribe during initialization and unsubscribe during teardown. Defaults to \nundefined\n.\n\n\nThe keys of the hash may be any string that is accepted by \nractive.on()\n, and the values may be either callback functions, as would be passed to \nractive.on()\n, or objects with a \nhandler\n property that is a callback function. The object form also takes other options that control the behavior of the event handler.\n\n\nRactive({\n  // ...\n  on: {\n    init () {\n      console.log('I will print during init')\n    },\n    '*.somethingHappened': {\n      handler ( ctx ) {\n        console.log('I will fire when this instance or any child component fires an instance event named \nsomethingHappened\n')\n      },\n      once: true\n    }\n  },\n  // ...\n})\n\n\n\n\nThe options that may be specified in the object form are:\n\n\n\n\nhandler (Function)\n: The callback function for the event.\n\n\nonce (boolean)\n: Use \nractive.once()\n rather than \nractive.on()\n to subscribe the listener, meaning that the handler will only be called the first time the event is fired and then it will be unsubscribed.\n\n\n\n\non\n event listeners may subscribe to any instance event, including lifecycle events. When a sublcass created with \nRactive.extend()\n is passed an \non\n hash, then any further subclasses or instances created with an \non\n hash will be combined. Any superclass event handlers are installed first following the inheritance hierarchy, and finally, any instance event handlers are installed.\n\n\noncomplete\n\n\n(Function)\n\n\nA lifecycle event that is called when the instance is rendered and all the transitions have completed.\n\n\nonconfig\n\n\n(Function)\n\n\nA lifecycle event that is called when an instance is constructed and all initialization options have been processed.\n\n\nonconstruct\n\n\n(Function)\n\n\nA lifecycle event that is called when an instance is constructed but before any initialization option has been processed.\n\n\nAccepts the instance's initialization options as argument.\n\n\nondestruct\n\n\n(Function)\n\n\nA lifecycle event that is called when an instance is torn down and any associated transitions are complete.\n\n\nondetach\n\n\n(Function)\n\n\nA lifecycle event that is called whenever \nractive.detach()\n is called.\n\n\nNote that \nractive.insert()\n implicitly calls \nractive.detach()\n if needed.\n\n\noninit\n\n\n(Function)\n\n\nA lifecycle event that is called when an instance is constructed and is ready to be rendered.\n\n\noninsert\n\n\n(Function)\n\n\nA lifecycle event that is called when \nractive.insert()\n is called.\n\n\nonrender\n\n\n(Function)\n\n\nA lifecycle event that is called when the instance is rendered but \nbefore\n transitions start.\n\n\nonteardown\n\n\n(Function)\n\n\nA lifecycle event that is called when the instance is being torn down.\n\n\nonunrender\n\n\n(Function)\n\n\nA lifecycle event that is called when the instance is being undrendered.\n\n\nonupdate\n\n\n(Function)\n\n\nA lifecycle event that is called when \nractive.update()\n is called.\n\n\npartials\n\n\n(Object\nstring, string|Object|Function\n)\n\n\nA map of partials where the key is the partial name and the value is either a template string, a parsed template object or a function that returns any of the previous options. The function form accepts processed \ndata\n and  Parse Object as arguments.\n\n\npartials: {\n  stringPartial: '\np\n{{greeting}} world!\n/p\n',\n  parsedPartial: {\nv\n:3,\nt\n:[{\nt\n:7,\ne\n:\np\n,\nf\n:[{\nt\n:2,\nr\n:\ngreeting\n},\n world!\n]}]},\n  functionPartial (data, p) {\n    return data.condition ? '\np\nhello world\n/p\n' : '\ndiv\nyes, we have no foo\n/div\n'\n  }\n}\n\n\n\n\nDuring a \nractive.reset()\n, function partials are re-evaluated. If the return value changes, the Ractive instance will be re-rendered.\n\n\npreserveWhitespace\n\n\n(boolean)\n\n\nWhether or not to preserve whitespace in templates when parsing. Defaults to \nfalse\n.\n\n\nWhitespace in \npre\n elements is always preserved. The browser will still deal with whitespace in the normal fashion.\n\n\nvar ractive = Ractive({\n  template: '\np\nhello\\n\\n  \\tworld   \n/p\n',\n  preserveWhitespace: false //default\n})\n\nconsole.log( ractive.toHTML() )\n// \np\nhello world\n/p\n\n\nvar ractive = Ractive({\n  template: '\np\nhello\\n\\n  \\tworld   \n/p\n',\n  preserveWhitespace: true\n})\n\nconsole.log( ractive.toHTML() )\n//\np\nhello\n//\n//  world   \n/p\n\n\n\n\n\nresolveInstanceMembers\n\n\n(boolean)\n\n\nWhether or not to include members of the Ractive instance at the end of the reference resolution process. Defaults to \ntrue\n.\n\n\nbutton on-click=\ntoggle('show')\nToggle\n/button\n\n\n\n\n\nIf there is no data member \ntoggle\n in the context of the template, with \nresolveInstanceMembers\n enabled, the reference will resolve to the \nractive.toggle()\n method of the instance.\n\n\nsanitize\n\n\n(boolean|Object)\n\n\nWhether or not certain elements will be stripped from the template during parsing.  Defaults to \nfalse\n.\n\n\ntrue\n strips out blacklisted elements and event attributes. See \nRactive.parse()\n for the default list of blacklisted elements.\n\n\ntemplate: `\n  \np\nsome content\n/p\n\n  \nframe\nAm I a bad element or just misunderstood?\n/frame\n\n`,\nsanitize: true\n\n// result:\n// \np\nsome content\n/p\n\n\n\n\n\nThe object form should have \nelements\n which is an array of blacklisted elements and \neventAttributes\n boolean which, when \ntrue\n, also strips out event attributes.\n\n\ntemplate: `\n  \np\nsome content\n/p\n\n  \ndiv onclick=\ndoEvil()\nthe good stuff\n/div\n\n`,\nsanitize: {\n  elements: [ 'p' ],\n  eventAttributes: true\n}\n\n// result:\n// \ndiv\nthe good stuff\n/div\n\n\n\n\n\nstaticDelimiters\n\n\n(Array[string])\n\n\nSets the static (one-time binding) delimiters. Defaults to \n[ '[[', ']]' ]\n.\n\n\nvar ractive = Ractive({\n  template: 'hello [[foo]]',\n  staticDelimiters: [ '[[', ']]' ], //default\n  data: { foo: 'world' }\n})\n// result: \nhello world\n\n\nractive.set( 'foo', 'mars' )\n// still is: \nhello world\n\n\n\n\n\nstaticTripleDelimiters\n\n\n(Array\nstring\n)\n\n\nSets the static (one-time binding) triple delimiters. Defaults to \n[ '[[[', ']]]' ]\n.\n\n\nvar ractive = Ractive({\n  template: 'hello [[[html]]]',\n  staticTripleDelimiters: [ '[[[', ']]]' ], //default\n  data: { html: '\nspan\nworld\n/span\n' }\n})\n// result: \nhello \nspan\nworld\n/span\n\n\nractive.set( 'html', '\nspan\nmars\n/span\n' )\n// still is: \nhello world\n\n\n\n\n\nstripComments\n\n\n(boolean)\n\n\nWhether or not to remove comments in templates when parsing. Defaults to \ntrue\n.\n\n\ntemplate: '\n!-- html comment --\nhello world',\nstripComments: false\n\n// result:\n// \n!-- html comment --\nhello world\n\n\n\n\nsyncComputedChildren\n\n\n(boolean)\n\n\nWhether or not to invalidate the dependencies of an expression when child keypaths of the expression are updated. Defaults to \nfalse\n. \nNote\n: setting this to \ntrue\n may cause performance issues for complex expressions involving large arrays.\n\n\ninput value=\n{{pattern}}\n /\n\n{{#each filter(users, pattern)}}\n  \ninput value=\n{{.name}}\n /\n\n{{/each}}\n\n\n\n\nIn this example, the \ninput\n inside the iteration is bound to a computation e.g. \nfilter(users, pattern).0.name\n that isn't actually an addressable model. With \nsyncComputedChildren\n enabled, when that virtual keypath is updated by a user changing the \ninput\n, the expression will invalidate its dependencies (\nfilter\n, \nusers\n, and \npattern\n), which will cause any other references to the \nuser\n that happens to coincide with result of the expression to also update.\n\n\ntarget\n\n\n(string|HTMLElement|array-like)\n\n\nAlias for \nel\n.\n\n\ntemplate\n\n\n(string|array|object|function)\n\n\nThe template to use. Must either be a CSS selector string pointing to an element on the page containing the template, an HTML string, an object resulting from \nRactive.parse()\n or a function that returns any of the previous options. The function form accepts processed \ndata\n and a Parse Object.\n\n\n// Selector\ntemplate: '#my-template',\n\n// HTML\ntemplate: '\np\n{{greeting}} world!\n/p\n',\n\n// Template AST\ntemplate: {\nv\n:3,\nt\n:[{\nt\n:7,\ne\n:\np\n,\nf\n:[{\nt\n:2,\nr\n:\ngreeting\n},\n world!\n]}]},\n\n// Function\ntemplate (data, p) {\n  return '\np\n{{greeting}} world!\n/p\n'\n},\n\n\n\n\nDuring a \nractive.reset()\n, templates provided using a function are re-evaluated. If the return value changes, the Ractive instance will be re-rendered.\n\n\ntransitions\n\n\n(Object\nstring, Function\n)\n\n\nA map of transitions where the key is the name of the transition and the value is a transition definition.\n\n\ntransitionsEnabled\n\n\n(boolean)\n\n\nWhether or not transitions are enabled. Defaults to \ntrue\n.\n\n\ntripleDelimiters\n\n\n(Array[string])\n\n\nSets the triple delimiters. Defaults to \n[ '{{{', '}}}' ]\n.\n\n\ntemplate: 'hello @html@',\ntripleDelimiters: [ '@', '@' ],\ndata: { html: '\nspan\nworld\n/span\n' }\n\n// result:\n// hello \nspan\nworld\n/span\n\n\n\n\n\ntwoway\n\n\n(boolean)\n\n\nWhether or not two-way binding is enabled. Defaults to \ntrue\n.\n\n\nvar ractive = Ractive({\n  template: '\ninput value=\n{{foo}}\n',\n  data: { foo: 'bar' },\n  twoway: false\n})\n\n// user types \nfizz\n into \ninput\n, but data value is not changed:\n\nconsole.log( ractive.get( 'foo' ) ); //logs \nbar\n\n\n// updates from the model are still pushed to the view\n\nractive.set( 'foo', 'fizz' )\n\n// input now displays \nfizz\n\n\n\n\n\nwarnAboutAmbiguity\n\n\n(boolean)\n\n\nWhether or not to warn about references that don't resolve to their immediate context. Defaults to \nfalse\n.\n\n\nAmbiguous references can be the cause of some strange behavior when your data changes structure slightly. With \nwarnAboutAmbiguity\n enabled, Ractive will warn you any time a reference isn't scoped and resolves in a context above the immediate context of the reference.\n\n\nStatic Properties\n\n\nRactive.adaptors\n\n\n(Object\nstring, Object\n)\n\n\nThe registry of globally available adaptors.\n\n\nRactive.components\n\n\n(Object\nstring, Function\n)\n\n\nThe registry of globally available component definitions.\n\n\nRactive.Context\n\n\nFrom\n \n0.9.4\n\n\n(Object)\n\n\nThe prototype for \nContext\n objects. This is provided so that you can extend context objects provided by Ractive with your own methods and properties.\n\n\nRactive.DEBUG\n\n\n(boolean)\n\n\nTells Ractive if it's in debug mode or not. When set to \ntrue\n, non-fatal errors are logged. When set to \nfalse\n, non-fatal errors are suppressed. By default, this is set to \ntrue\n.\n\n\nRactive.DEBUG_PROMISES\n\n\n(boolean)\n\n\nTells Ractive to log errors thrown inside promises. When set to \ntrue\n, errors thrown in promises are logged. When set to \nfalse\n, errors inside promises are suppressed. By default, this is set to \ntrue\n.\n\n\nRactive.decorators\n\n\n(Object\nstring, Function\n)\n\n\nThe registry of globally available decorators.\n\n\nRactive.defaults\n\n\n(Object\nstring, any\n)\n\n\nGlobal defaults for initialisation options with the exception of plugin registries.\n\n\n// Change the default mustache delimiters to [[ ]] globally\nRactive.defaults.delimiters = [ '[[', ']]' ]\n\n// Future instances now use [[ ]]\nractive1 = Ractive({\n    template: 'hello [[world]]'\n})\n\n\n\n\nDefaults can be specified for a subclass of Ractive, overriding global defaults.\n\n\nvar MyRactive = Ractive.extend()\n\nMyRactive.defaults.el = document.body\n\n\n\n\nConfiguration on the instance overrides subclass and global defaults.\n\n\nRactive.defaults.delimiters = [ '[[', ']]' ]\n\n// Uses the delimiters specified above\nRactive({\n  template: 'hello [[world]]'\n})\n\n// Uses the delimiters specified in the init options\nRactive({\n  template: 'hello //world\\\\',\n  delimiters: [ '//', '\\\\' ]\n})\n\n\n\n\nGlobal data attributes may be specified:\n\n\nRactive.defaults.data.people = [{id:4, name:'Fred'},{id:5, name:'Wilma'},...]\n\n//or alternatively:\nObject.assign(Ractive.defaults.data,{people : [{id:4, name:'Fred'},{id:5, name:'Wilma'},...],\n                                     title : 'Flintstones',\n                                     producer : 'Hanna-Barbera'})\n\n// (Object.assign is provided as a polyfill by Ractive if it's not supported by the browser)\n\n\n\n\nThe data attributes and values are then accessible in all components. Data attributes specified in this way, however, do \nnot\n trigger an automatic component update if the attribute value is changed after the component is instantiated.\n\n\nRactive.easing\n\n\n(Object\nstring, Function\n)\n\n\nThe global registry of easing functions.\n\n\nThe easing functions are used by the \nractive.animate\n method and by transitions. Four are included by default: \nlinear\n, \neaseIn\n, \neaseOut\n and \neaseInOut\n.\n\n\nRactive.events\n\n\n(Object\nstring, Function\n)\n\n\nThe global registry of custom event plugins.\n\n\nRactive.interpolators\n\n\n(Object\nstring, Function\n)\n\n\nA key-value hash of interpolators use by \nractive.animate()\n or non-CSS transitions.\n\n\n[Component].Parent\n\n\nFrom\n \n0.9.1\n\n\n(Ractive|Component constructor)\n\n\nThe parent constructor of a component.\n\n\nconst MyComponent = Ractive.extend()\nconst MySpecialComponent = MyComponent.extend()\n\nMyComponent.Parent === Ractive; // true\nMySpecialCompoennt.Parent === MyComponent; // true\n\n\n\n\nRactive.partials\n\n\n(Object\nstring, string|Object|Function\n)\n\n\nThe global registry of partial templates.\n\n\nLike templates, partials are parsed at the point of use. The parsed output is cached and utilized for future use.\n\n\n[Component].Ractive\n\n\nFrom\n \n0.9.1\n\n\n(Ractive)\n\n\nThe root Ractive constructor that is the first ancestor of this component.\n\n\nconst MyComponent = Ractive.extend()\nconst MySpecialComponent = MyComponent.extend()\n\nMyComponent.Ractive === Ractive; // true\nMySpecialCompoennt.Ractive === Ractive; // true\n\n\n\n\nRactive.svg\n\n\n(boolean)\n\n\nIndicates whether or not the browser supports SVG.\n\n\nRactive.transitions\n\n\n(Object\nstring, Function\n)\n\n\nThe global registry of transition functions.\n\n\nRactive.VERSION\n\n\n(string)\n\n\nThe version of the currently loaded Ractive.\n\n\nStatic Methods\n\n\nRactive.escapeKey()\n\n\nEscapes the given key so that it can be concatenated with a keypath string.\n\n\nSyntax\n\n\n\n\nRactive.escapeKey(key)\n\n\n\n\nArguments\n\n\n\n\nkey (string)\n: The key to escape.\n\n\n\n\nReturns\n\n\n\n\n(string)\n: The escaped key.\n\n\n\n\nExamples\n\n\nExample 1\n\n\nRactive.escapeKey('foo.bar'); // 'foo\\\\.bar'\n\n\n\n\nExample 2\n\n\n\n\n\nRactive({\n    ...\n  on:{\n    changeUrl () {\n      this.set('img.a\\\\.jpg.url', \n/my/new/path.jpg\n)\n    },\n    changeUrl2 () {\n      mykey = 'a.jpg'\n      this.set('img.' + Ractive.escapeKey(mykey) + '.url', \n/the/other/path.jpg\n)\n    }\n  },\n  data: {\n    img: {\n      'a.jpg': {\n        url: \n/path/to/a.jpg\n\n      }\n    }\n  }\n})\n\n\n\n\nRactive.extend()\n\n\nCreates a \"subclass\" of the Ractive constructor or a subclass constructor. See \nComponents\n for an in-depth discussion on the use of \nRactive.extend\n.\n\n\nSyntax\n\n\n\n\nRactive.extend([options[, ...optionsN]])\n\n\n\n\nArguments\n\n\n\n\noptions] (Object)\n: One or more objects that represent the defaults for instances of the subclass, with the latter objects' properties taking precedence over the former. See [Initialization Options for a list of possible options.\n\n\n\n\nReturns\n\n\n\n\n(Function)\n: The subclass constructor function.\n\n\n\n\nExamples\n\n\nconst SubClass = Ractive.extend({\n    template: '\ndiv\n{{message}}\n/div\n',\n    data: {\n        message: 'Hello World!'\n    }\n})\n\n// \ndiv\nHello World!\n/div\n\nconst instance1 = SubClass({\n    el: '.div1'\n})\n\n// \ndiv\nLorem Ipsum\n/div\n\nconst instance2 = SubClass({\n    el: '.div2',\n    data: {\n        message: 'Lorem Ipsum'\n    }\n})\n\n\n\n\nRactive.extendWith()\n\n\nCreates a \"subclass\" of the Ractive constructor or a subclass constructor using an existing constructor. The constructor will be augmented with static methods like \nextend\n, and it will also process the given initialization options.\n\n\nSyntax\n\n\n\n\nRactive.extendWith(constructor[, options])\n\n\n\n\nArguments\n\n\n\n\nconstructor (Function)\n: A class constructor - like an ES6 \nclass\n, a plain JavaScript function with a prototpye, or another similarly constructed function (TypeScript, CoffeeScript, etc).\n\n\noptions (Object)\n: An object with initialization options as properties. See initialization options for a list of possible options.\n\n\n\n\nReturns\n\n\n\n\n(Function)\n: The augmented constructor function.\n\n\n\n\nExamples\n\n\nclass Widget extends Ractive {\n  notify ( message ) {\n    this.push( 'messages', message )\n  }\n\n  show () {\n    this.set( 'visible', true )\n  }\n\n  hide () {\n    this.set( 'visible', false )\n  }\n}\n\nRactive.extendWith( Widget, {\n  template: '{{#if visible}}\nul\n{{#each messages}}\nli\n{{.}}\n/li\n{{/each}}\n/ul\n{{/if}}'\n})\n\n\n\n\nRactive.getCSS()\n\n\nReturns the scoped CSS from Ractive subclasses defined at the time of the call.\n\n\nIf used without arguments, it will return the scoped CSS of all subclasses. If provided an array of scoping IDs, it will return the scoped CSS of all subclasses whose scoping ID is included in the array.\n\n\nSyntax\n\n\n\n\nRactive.getCSS([key])\n\n\n\n\nArguments\n\n\n\n\n[key] (Array\nstring\n)\n: Subclass CSS scoping ID.\n\n\n\n\nReturns\n\n\n\n\n(string)\n: The scoped CSS.\n\n\n\n\nExamples\n\n\n// Assuming the generated ID for this subclass is 'xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx'.\nconst Subclass1 = Ractive.extend({\n    ...\n    css: 'div{ color: red }'\n    ...\n})\n\n// Assuming the generated ID for this subclass is 'yyyyyyyy-yyyy-yyyy-yyyy-yyyyyyyyyyyy'.\nconst Subclass2 = Ractive.extend({\n    ...\n    css: 'div{ color: green }'\n    ...\n})\n\n// CSS contains the scoped versions of div{ color: red } and div{ color: green }.\nconst css = Ractive.getCSS()\n\n// css contains the scoped version of div{ color: red } only.\nconst css = Ractive.getCSS([ 'xxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx' ])\n\n\n\n\n\nRactive.getContext()\n\n\nAccepts a node and returns a Context object containing details of the Ractive instance the node is associated to.\n\n\nSyntax\n\n\n\n\nRactive.getContext(node)\n\n\n\n\nArguments\n\n\n\n\nnode (string|Node)\n: The DOM node or a CSS selector of the DOM node for which you wish to retrieve the Ractive instance or view details.\n\n\n\n\nReturns\n\n\n\n\n(Context)\n: A context object.\n\n\n\n\nExamples\n\n\nconst info = Ractive.getContext(document.getElementById('some-node'))\n\nconst info = Ractive.getContext('#some-node')\n\n\n\n\nRactive.isInstance()\n\n\nFrom\n \n0.9.1\n\n\nDetermines whether or not the given object is an instance of the Ractive constructor. This is also extended to component constructors, where it will make sure that the given object is an instance of the particular constructor on which it is called.\n\n\nSyntax\n\n\n\n\nRactive.isInstance(obj)\n\n\n\n\nArguments\n\n\n\n\nobj (any)\n: The thing to check.\n\n\n\n\nReturns\n\n\n\n\nboolean\n\n\n\n\nExamples\n\n\nconst MyComponent = Ractive.extend()\nconst MySpecialComponent = MyComponent.extend()\nconst OtherComponent = Ractive.extend()\n\nconst r = new MySpecialCompoennt()\n\nMySpecialComponent.isInstance(r); // true\nMyComponent.isInstance(r); // true\nOtherComponent.isIstance(r); // false\n\nRactive.isInstance(r); //true\n\n\n\n\nRactive.joinKeys()\n\n\nJoins the given keys into a properly escaped keypath.\n\n\nSyntax\n\n\n\n\nRactive.joinKeys(key1 [, ...keyN])\n\n\n\n\nArguments\n\n\n\n\nkey (string)\n: One or more strings to join.\n\n\n\n\nReturns\n\n\n\n\n(string)\n: A properly joined and escaped keypath.\n\n\n\n\nExamples\n\n\nRactive.joinKeys( 'foo', 'bar.baz' ); // foo.bar\\.baz\n\n\n\n\nRactive.parse()\n\n\nParses the template into an abstract syntax tree that Ractive can work on.\n\n\nSyntax\n\n\n\n\nRactive.parse(template[, options])\n\n\n\n\nArguments\n\n\n\n\ntemplate (string)\n: A Ractive-compliant HTML template.\n\n\n[options] (Object)\n: Parser options.\n\n\n[delimiters] ([string])\n: Start and end delimiters for normal mustaches. Defaults to \n['{{', '}}']\n.\n\n\n[tripleDelimiters] ([string])\n: Start and end delimiters for triple mustaches. Defaults to \n['{{{', '}}}']\n.\n\n\n[staticDelimiters] ([string])\n: Start and end delimiters for static mustaches. Defaults to \n['[[', ']]']\n.\n\n\n[staticTripleDelimiters] ([string])\n: Start and end delimiters for static triple mustaches. Defaults to \n['[[[', ']]]']\n.\n\n\n[contextLines] (integer)\n: Additional lines above and below a line with a parse error to include in the error output. Defaults to \n0\n.\n\n\n[interpolate] (Object\nstring, boolean\n)\n: Map of elements that indicates whether or not to read mustaches within the element. Defaults to \n{ script: false, textarea: true, template: false, style: false }\n.\n\n\n[csp] (boolean)\n: When \ntrue\n includes pre-compiled expression functions in the template output so that \neval\n is not needed at runtime. Defaults to \ntrue\n.\n\n\n[preserveWhitespace] (boolean)\n: When \ntrue\n, preserves whitespace in templates. Whitespace inside the \npre\n element is preserved regardless of the value of this option. Defaults to \nfalse\n.\n\n\n[stripComments] (boolean)\n: When \nfalse\n will leave comments in the parsed template. Defaults to \ntrue\n.\n\n\n[sanitize] (boolean|Object)\n: When \ntrue\n, strips inline event attributes and certain elements from the markup. Defaults to \nfalse\n.\n\n\n[elements] (Array\nstring\n)\n: An array of element names to blacklist.\n\n\n[eventAttributes] (boolean)\n: When \ntrue\n, strips off inline event attributes.\n\n\n\n\n\n\n[includeLinePositions] (boolean)\n: When \ntrue\n will include line positions on each node of the parser output. Defaults to \nfalse\n.\n\n\n[textOnlyMode] (boolean)\n: When \ntrue\n parses elements as text rather than elements. This is useful for generating raw HTML from a template, more like a plain text templating processor. Defaults to \nfalse\n.\n\n\n[transforms|parserTransforms] ([Function])`: An array of post-parsing transforms to apply to the output parser AST.\n\n\n\n\n\n\n\n\nWhen \nsanitize\n is \ntrue\n, the following elements are stripped:\n\n\n\n\napplet\n\n\nbase\n\n\nbasefont\n\n\nbody\n\n\nframe\n\n\nframeset\n\n\nhead\n\n\nhtml\n\n\nisindex\n\n\nlink\n\n\nmeta\n\n\nnoframes\n\n\nnoscript\n\n\nobject\n\n\nparam\n\n\nscript\n\n\nstyle\n\n\ntitle\n\n\n\n\nReturns\n\n\n\n\n(Object)\n - The object representation of the provided markup.\n\n\n\n\nExamples\n\n\nAssume the following markup.\n\n\ndiv class='gallery'\n\n  {{#each items}}\n    \n!-- comments get stripped out of the template --\n\n    \nfigure on-tap='select' staggered-in\n\n      \nimg class='thumbnail' src='assets/images/{{id}}.jpg'\n\n      \nfigcaption\n{{( @index+1 )}}: {{description}}\n/figcaption\n\n    \n/figure\n\n  {{/each}}\n\n/div\n\n\n\n\n\nRactive.parse( template );\n will yield the following output:\n\n\n{\nv\n:4,\nt\n:[{\nt\n:7,\ne\n:\ndiv\n,\nm\n:[{\nn\n:\nclass\n,\nf\n:\ngallery\n,\nt\n:13}],\nf\n:[{\nt\n:4,\nf\n:[\n \n,{\nt\n:7,\ne\n:\nfigure\n,\nm\n:[{\nn\n:[\ntap\n],\nt\n:70,\nf\n:\nselect\n},{\nn\n:\nstaggered\n,\nt\n:72,\nv\n:\nt1\n}],\nf\n:[{\nt\n:7,\ne\n:\nimg\n,\nm\n:[{\nn\n:\nclass\n,\nf\n:\nthumbnail\n,\nt\n:13},{\nn\n:\nsrc\n,\nf\n:[\nassets/images/\n,{\nt\n:2,\nr\n:\nid\n},\n.jpg\n],\nt\n:13}]},\n \n,{\nt\n:7,\ne\n:\nfigcaption\n,\nf\n:[{\nt\n:2,\nx\n:{\nr\n:[\n@index\n],\ns\n:\n_0+1\n}},\n: \n,{\nt\n:2,\nr\n:\ndescription\n}]}]}],\nn\n:52,\nr\n:\nitems\n}]}],\ne\n:{'_0+1': function(_0) { return _0+1; }}}\n\n\n\n\nRactive.splitKeypath()\n\n\nSplits the given keypath into an array of unescaped keys.\n\n\nSyntax\n\n\n\n\nRactive.splitKeypath(keypath)\n\n\n\n\nArguments\n\n\n\n\nkeypath (string)\n: The keypath to split into keys.\n\n\n\n\nReturns\n\n\n\n\n(Array)\n: Returns an array of unescaped keys.\n\n\n\n\nExamples\n\n\nRactive.splitKeypath( 'foo.bar\\\\.baz' ); // [ 'foo', 'bar.baz' ]\n\n\n\n\nRactive.sharedSet()\n\n\nFrom\n \n0.9.4\n\n\nSets data in the \n@shared\n object without requiring access to a Ractive instance.\n\n\nSyntax\n\n\n\n\nRactive.sharedSet(keypath, value, options)\n\n\nRactive.sharedSet(hash, options)\n\n\n\n\nArguments\n\n\nArguments are the same as would be supplied to \nractive.set\n.\n\n\nReturns\n\n\n\n\n(Promise)\n: Returns a promise that resolves when any transitions associated with the change have completed.\n\n\n\n\nExamples\n\n\nRactive.sharedSet( '_', lodash )\n\n\n\n\nRactive.styleSet()\n\n\nFrom\n \n0.9.4\n\n\nSets data in the \n@style\n object of Ractive or the component constructor on which it is called. When an applied style that is affected by a change from \nstyleSet\n updates, Ractive will update its manaaged style tag so that the changes show up in the browser immediately.\n\n\nThis function is also available to components created with \nRactive.extend\n. When called on a component constructor, \nstyleSet\n will set the value in the component's \ncssData\n, and any extensions of the component will also be notified that the parent data changed.\n\n\nSyntax\n\n\n\n\nRactive.styleSet(keypath, value, options)\n\n\nRactive.styleSet(hash, options)\n\n\n\n\nArguments\n\n\nArguments are the same as would be supplied to \nractive.set\n with an addition to the \noptions\n hash:\n\n\n\n\napply (boolean)\n: Whether or not to apply any affected styles now. Defaults to \ntrue\n.\n\n\n\n\nReturns\n\n\n\n\n(Promise)\n: Returns a promise that resolves when any transitions associated with the change have completed.\n\n\n\n\nExamples\n\n\nRactive.styleSet( 'colors.fg', '#000' )\n\n\n\n\nRactive.unescapeKey()\n\n\nUnescapes the given key e.g. \nfoo\\\\.bar\n =\n \nfoo.bar\n.\n\n\nSyntax\n\n\n\n\nRactive.unescapeKey(key)\n\n\n\n\nArguments\n\n\n\n\nkey (string)\n: The key to unescape.\n\n\n\n\nReturns\n\n\n\n\n(string)\n: The unescaped key.\n\n\n\n\nExamples\n\n\nRactive.unescapeKey('foo\\\\.bar'); // foo.bar\n\n\n\n\nInstance Properties\n\n\nractive.adaptors\n\n\n(Object\nstring, Object\n)\n\n\nThe instance-only registry of adaptors.\n\n\nractive.components\n\n\n(Object\nstring, Function\n)\n\n\nThe instance-only registry of components.\n\n\nractive.container\n\n\n(Ractive)\n\n\nEach component instance that is in a yielded fragment has a container instance that is accessible using \nthis.container\n.\n\n\nfoo\n\n  \nbar\n\n    \nbaz /\n\n  \n/bar\n\n\n/foo\n\n\n\n\n\nIf \nbar\n \n{{yield}}\ns, then \nbaz\n's container will be the \nfoo\n instance.\n\n\nractive.decorators\n\n\n(Object\nstring, Function\n)\n\n\nThe instance-only registry of decorators.\n\n\nractive.easing\n\n\n(Object\nstring, Function\n)\n\n\nThe instance-only registry of easing functions.\n\n\nractive.events\n\n\n(Object\nstring, Function\n)\n\n\nThe instance-only registry of custom event plugins.\n\n\nractive.interpolators\n\n\n(Object\nstring, Function\n)\n\n\nA key-value hash of interpolators use by \nractive.animate()\n or non-CSS transitions.\n\n\nractive.parent\n\n\n(Ractive)\n\n\nEach component instance can access its parent using \nthis.parent\n.\n\n\nfoo\n\n  \nbar\n\n    \nbaz /\n\n  \n/bar\n\n\n/foo\n\n\n\n\n\nbaz\n's parent is the \nbar\n instance, and \nbar\n's parent is the \nfoo\n instance.\n\n\nractive.partials\n\n\n(Object\nstring, string|Object|Function\n)\n\n\nThe instance-only registry of partials.\n\n\nractive.root\n\n\n(Ractive)\n\n\nEach component instance can access its root Ractive instance using \nthis.root\n.\n\n\nfoo\n\n  \nbar\n\n    \nbaz /\n\n  \n/bar\n\n\n/foo\n\n\n\n\n\nfoo\n, \nbar\n, and \nbaz\n will all have the Ractive instance with this template as their \nroot\n.\n\n\nractive.transitions\n\n\n(Object\nstring, Function\n)\n\n\nThe instance-only registry of transitions.\n\n\nInstance Methods\n\n\nractive._super()\n\n\nCalls the parent method from a child method of the same name.\n\n\nractive._super()\n is not always available. Only when Ractive detects its use does it make this reference to the parent method.\n\n\nSyntax\n\n\n\n\nractive._super([arg[, ...argN]])\n\n\n\n\nArguments\n\n\n\n\n[arg] (any)\n: One or more arguments to pass to the function.\n\n\n\n\nReturns\n\n\n\n\n(any)\n: Depends on the method called.\n\n\n\n\nExamples\n\n\n\n\n\nvar Component = Ractive.extend({\n  oninit () {\n    console.log('super init')\n  }\n})\n\nvar SubComponent = Component.extend({\n  oninit () {\n    this._super()\n    console.log('sub init')\n  }\n})\n\nnew SubComponent()\n\n\n\n\nractive.add()\n\n\nIncrements the selected keypath.\n\n\nSyntax\n\n\n\n\nractive.add(keypath[, number])\n\n\n\n\nArguments\n\n\n\n\nkeypath (string)\n: The keypath of the number we're incrementing.\n\n\n[number] (number)\n: The number to increment by. Defaults to \n1\n.\n\n\n\n\nReturns\n\n\n\n\n(Promise)\n: A promise that resolves when any transitions associated with the operation complete.\n\n\n\n\nExamples\n\n\n\n\n\nvar r = Ractive({\n  el: '#main',\n  template: '#tpl',\n  data: {\n    counter: 0\n  }\n})\n\nsetTimeout(() =\n {\n  r.add('counter')\n  console.log(r.get('counter'))\n}, 1000)\n\nsetTimeout(() =\n {\n  r.add('counter', 10)\n  console.log(r.get('counter'))\n}, 2000)\n\n\n\n\nractive.animate()\n\n\nSimilar to \nractive.set()\n, this will update the data and re-render any affected mustaches and notify observers.\n\n\nAll animations are handled by a global timer that is shared between Ractive instances (and which only runs if there are one or more animations still in progress), so you can trigger as many separate animations as you like without worrying about timer congestion. Where possible, \nrequestAnimationFrame\n is used rather than \nsetTimeout\n.\n\n\nNumeric values and strings that can be parsed as numeric values can be interpolated. Objects and arrays containing numeric values (or other objects and arrays which themselves contain numeric values, and so on recursively) are also interpolated.\n\n\nNote that there is currently no mechanism for detecting cyclical structures! Animating to a value that indirectly references itself will cause an infinite loop.\n\n\nFuture versions of Ractive may include string interpolators - e.g. for SVG paths, colours, transformations and so on, a la D3 - and the ability to pass in your own interpolator.\n\n\nIf an animation is started on a keypath which is \nalready\n being animated, the first animation is cancelled. (Currently, there is no mechanism in place to prevent collisions between e.g. \nractive.animate('foo', { bar: 1 })\n and \nractive.animate('foo.bar', 0)\n.)\n\n\nSyntax\n\n\n\n\nractive.animate(keypath, value[, options])\n\n\n\n\nArguments\n\n\n\n\nkeypath (string)\n: The keypath to animate.\n\n\nvalue (number|string|Object|Array)\n: The value to animate to.\n\n\n[options] (Object)\n:\n\n\n[duration] (number)\n: How many milliseconds the animation should run for. Defaults to \n400\n.\n\n\n[easing] (string|Function)\n: The name of an easing function or the easing function itself. Defaults to \nlinear\n.\n\n\n[interpolator] (string)\n: The name of an interpolator function. Defaults to the built-in number interpolator if the value is numeric, or \nnull\n if none is applicable.\n\n\n[step] (Function)\n: A function called on each step of the animation.\n\n\nt (number)\n: The animation progress between \n0\n and \n1\n with easing function already applied.\n\n\nvalue (number)\n: The value at \nt\n with interpolator function already applied.\n\n\n\n\n\n\n[complete] (Function)\n: A function to be called when the animation completes, with the \nvalue\n passed to \nanimate\n.\n\n\n\n\n\n\n\n\nReturns\n\n\n\n\n(Promise)\n: Returns a Promise which resolves with the target \nvalue\n and has an additional \nstop\n method, which cancels the animation.\n\n\n\n\nExamples\n\n\n\n\n\nvar r = Ractive({\n  el: '#main',\n  template: '#tpl',\n  data: {\n    counter: 0\n  }\n})\n\nsetTimeout(() =\n {\n  r.animate('counter', 20, { duration: 2000 })\n}, 1000)\n\n\n\n\nractive.attachChild()\n\n\nCreates a parent-child relationship between two Ractive instances. The child may be an instance of a component defined by \nRactive.extend()\n, but that is not a requirement, as children may be a plain Ractive instance created with \nRactive()\n.\n\n\nSyntax\n\n\nractive.attachChild( child )\nractive.attachChild( child, options )\n\n\n\n\nArguments\n\n\n\n\nchild (Ractive instance)\n: The child instance to attach.\n\n\n[options] (Object)\n:\n\n\ntarget] (string)\n: An anchor name at which to render the instance. See [\nComponents\n. If the instance is already rendered, it will be unrendered and re-rendered at an appropriate anchor.\n\n\n[append] (boolean)\n: Default \ntrue\n - add the instance to the end of the list for the targeted anchor.\n\n\n[prepend] (boolean)\n: Add the instance to the beginning of the list for the targeted anchor.\n\n\n[insertAt] (number)\n: Index at which to add the instance in the list for the targeted anchor.\n\n\n\n\n\n\n\n\nWhen a child is attached to a parent, the child's \nparent\n property is updated in an observable way, so any references to \n@this.parent\n in the child will be notified of the change.\n\n\nA child may be targeted to a \nComponents\n when it is attached. If a child has no specified target, then it is responsible for managing its own render cycle. If a child does have a specified target, then the parent will manage rendering and unrendering the child as appropriate in the same way that a regular component has a managed render cycle.\n\n\nWhen a child is attached targeting an anchor, only anchors that belong directly to the parent are considered as hosts. However, any element or component queries on the parent instance, including live queries, will consider the child when trying to match both elements and components. There is also an option on the query methods that allows querying remote, unmanaged instances, so that non-anchored children can also be queried for elements and components.\n\n\nReturns\n\n\n\n\n(Promise)\n: A \nPromise\n that resolves with the child instance when any transitions are complete.\n\n\n\n\nChildren can be detached using \nractive.detachChild()\n.\n\n\nExamples\n\n\nExample 1\n: See the example for \nAnchors\n\n\nractive.detach()\n\n\nDetaches the instance from the DOM, returning a document fragment. You can reinsert it, possibly in a different place, with \nractive.insert()\n (note that if you are reinserting it immediately you don't need to detach it first - it will happen automatically).\n\n\nSyntax\n\n\n\n\nractive.detach()\n\n\n\n\nArguments\n\n\n\n\nNone\n\n\n\n\nReturns\n\n\n\n\n(DocumentFragment)\n: A document fragment.\n\n\n\n\nExamples\n\n\n\n\n\nvar r = Ractive({\n  el: '#main',\n  template: '#tpl',\n  data: {\n    counter: 0\n  }\n})\n\nsetTimeout(() =\n {\n  var div = document.createElement('div')\n  div.appendChild(r.detach())\n  console.log(div.innerHTML)\n}, 1000)\n\n\n\n\nractive.detachChild()\n\n\nDetaches a child from an instance when it was previously attached with \nractive.attachChild()\n.\n\n\nWhen a child instance that was attached targeting an anchor is detached, its instance is spliced out of the \n@this.children.byName.anchorName\n array so that subsequent children move forward to fill the void.\n\n\nSyntax\n\n\n\n\nractive.detachChild( child )\n\n\n\n\nReturns\n\n\n\n\n(Promise)\n: A \nPromise\n that resolves with the child instance when any transitions are complete.\n\n\n\n\nExamples\n\n\nExample 1\n: See the example for \nAnchors\n\n\nractive.find()\n\n\nReturns the first element inside a given Ractive instance matching a CSS selector. This is similar to doing \nthis.el.querySelector(selector)\n (though it doesn't actually use \nquerySelector()\n).\n\n\nSyntax\n\n\n\n\nractive.find(selector[, options])\n\n\n\n\nArguments\n\n\n\n\nselector (string)\n: A CSS selector representing the element to find.\n\n\n[options] (Object)\n:\n\n\nremote (boolean}\n: Include attached children that are not rendered in anchors when looking for matching elements. Defaults to \nfalse\n.\n\n\n\n\n\n\n\n\nReturns\n\n\n\n\n(Node)\n: A Node.\n\n\n\n\nExamples\n\n\n\n\n\nvar r = Ractive({\n  el: '#main',\n  template: '#tpl'\n})\n\nsetTimeout(() =\n {\n  var p = r.find('p.target')\n  console.log(p.outerHTML)\n}, 1000)\n\n\n\n\nractive.findAll()\n\n\nThis method is similar to [\nractive.find()\n]ractivefind), with an important difference - it returns a list of elements matching the selector, rather than a single node.\n\n\nSyntax\n\n\n\n\nractive.findAll(selector[, options])\n\n\n\n\nArguments\n\n\n\n\nselector (string)\n: A CSS selector representing the elements to find.\n\n\n[options] (Object)\n:\n\n\nremote (boolean)\n: Include attached children that are not rendered in anchors when searching for elements. Defaults to \nfalse\n.\n\n\n\n\n\n\n\n\nReturns\n\n\n\n\n(Array\nNode\n)\n: An array of nodes.\n\n\n\n\nExamples\n\n\n\n\n\nvar r = Ractive({\n  el: '#main',\n  template: '#tpl'\n})\n\nsetTimeout(() =\n {\n  var ps = r.findAll('p')\n  ps.forEach(function(p) {\n    console.log(p.outerHTML)\n  })\n}, 1000)\n\n\n\n\nractive.findAllComponents()\n\n\nReturns all components inside a given Ractive instance with the given \nname\n (or all components of any kind if no name is given).\n\n\nSyntax\n\n\n\n\nractive.findAllComponents([name[, options]])\n\n\n\n\nArguments\n\n\n\n\n[name] (string)\n: The name of the component to find.\n\n\n[options] (Object)\n:\n\n\nremote (boolean)\n: Include attached children that are not rendered in anchors when searching components. Defaults to \nfalse\n.\n\n\n\n\n\n\n\n\nReturns\n\n\n\n\n(Array\nractive\n)\n: An array of ractive instances.\n\n\n\n\nExamples\n\n\n\n\n\nvar Component = Ractive.extend({\n  template: 'Component {{number}}'\n})\n\nvar r = Ractive({\n  el: '#main',\n  template: '#tpl',\n  components: {\n    Component: Component\n  }\n})\n\nsetTimeout(() =\n {\n  var cs = r.findAllComponents('Component')\n  cs.forEach(function(c) {\n    console.log(c.toHTML())\n  })\n}, 1000)\n\n\n\n\nractive.findComponent()\n\n\nReturns the first component inside a given Ractive instance with the given \nname\n (or the first component of any kind if no name is given).\n\n\nSyntax\n\n\n\n\nractive.findComponent([name[, options]])\n\n\n\n\nArguments\n\n\n\n\n[name] (string)\n: The name of the component to find.\n\n\n[options] (Object)\n:\n\n\nremote (boolean)\n: Include attached children that are not rendered in anchors when searching components. Defaults to \nfalse\n.\n\n\n\n\n\n\n\n\nReturns\n\n\n\n\n(Ractive)\n: A ractive instance.\n\n\n\n\nExamples\n\n\n\n\n\nvar Component = Ractive.extend({\n  template: 'Component {{number}}'\n})\n\nvar r = Ractive({\n  el: '#main',\n  template: '#tpl',\n  components: {\n    Component: Component\n  }\n})\n\nsetTimeout(() =\n {\n  var c = r.findComponent('Component')\n  console.log(c.toHTML())\n}, 1000)\n\n\n\n\nractive.findContainer()\n\n\nReturns the first container of this component instance with the given \nname\n.\n\n\nSyntax\n\n\n\n\nractive.findContainer(name)\n\n\n\n\nArguments\n\n\n\n\nname (string)\n: The name of the container to find.\n\n\n\n\nReturns\n\n\n\n\n(Ractive)\n: Returns the first container of this component with the given \nname\n.\n\n\n\n\nExamples\n\n\n// TODO\n\n\n\n\nractive.findParent()\n\n\nReturns the first parent of this component instance with the given \nname\n.\n\n\nSyntax\n\n\n\n\nractive.findParent(name)\n\n\n\n\nArguments\n\n\n\n\nname (string)\n: The name of the parent to find.\n\n\n\n\nReturns\n\n\n\n\n(Ractive)\n: Returns the first parent of this component with the given \nname\n.\n\n\n\n\nExamples\n\n\n// TODO\n\n\n\n\nractive.fire()\n\n\nFires an event, which will be received by handlers that were bound using \nractive.on\n. In practical terms, you would mostly likely use this with \nRactive.extend()\n, to allow applications to hook into your subclass.\n\n\nSyntax\n\n\n\n\nractive.fire(eventName[, context [, arg1[, ...argN]]])\n\n\n\n\nArguments\n\n\n\n\nname (string)\n: The name of the event.\n\n\n[context] (context|object)\n: A context object to use for the event or an object with properties to assign to a new context object. If you need to pass arguments but don't need to provide context, pass an empty object (\n{}\n) before the additional arguments. \nFrom\n \n0.9.4\n, if you want to reuse a context exactly as it exists, it should have a \nrefire\n property that is \n=== true\n.\n\n\n[arg] (any)\n: The arguments that event handlers will be called with.\n\n\n\n\nReturns\n\n\n\n\n(boolean)\n\n\n\n\nExamples\n\n\n\n\n\nvar r = Ractive()\n\nr.on('foo', () =\n {\n  console.log('foo fired')\n})\n\nr.fire('foo')\n\n\n\n\nractive.get()\n\n\nReturns the value at \nkeypath\n.\n\n\nSyntax\n\n\n\n\nractive.get([keypath][, options])\n\n\n\n\nArguments\n\n\n\n\n[keypath] (string)\n: The keypath of the data to retrieve. If omitted, returns a shallow copy of the instance's data.\n\n\n[options] (Object)\n: An options hash that may contain:\n\n\nvirtual (boolean)\n: When set to \nfalse\n, excludes virtual keypaths (computations, links, mappings, etc.). Defaults to \ntrue\n for the root keypath and \nfalse\n for keypaths other than the root.\n\n\nunwrap (boolean)\n: When set to \nfalse\n, returns the adapted value of the data if an adaptor was applied. Defaults to \ntrue\n.\n\n\n\n\n\n\n\n\nReturns\n\n\n\n\n(any)\n: Returns the data that exists at the given keypath, or the root data if no keypath is given.\n\n\n\n\nExamples\n\n\n\n\n\nvar r = Ractive({\n  data: {\n    foo: {\n      bar: [ 'baz' ]\n    }\n  }\n})\n\nconsole.log(r.get('foo.bar.0'))\n\n\n\n\n\n\n\nvar r = new Ractive({\n  data : {\n    name : \nHerbert\n\n  },\n  computed : {\n    foo  () {\n      return 55\n    }\n  }\n})\n\nconsole.log(r.get()) // =\n {name : \nHerbert\n, foo : 55}\n\nconsole.log(r.get({virtual : false})) // =\n {name : \nHerbert\n}\n\n\n\n\nractive.getContext()\n\n\nThis is an instance specific version of \nRactive.getContext()\n that will only search the local instance DOM for a matching node when a selector is given. If the given value is not a string, then it is passed directly through to the static version of this method.\n\n\nSyntax\n\n\n\n\nractive.getContext(node)\n\n\n\n\nArguments\n\n\n\n\nnode (string|Node)\n: The DOM node or a CSS selector of a target node for which you wish to retrieve the Ractive instance or view details.\n\n\n\n\nReturns\n\n\n\n\n(Context)\n: Returns an Context object with helper methods to interact with the Ractive instance and context associated with the given node.\n\n\n\n\nExamples\n\n\n// TODO\n\n\n\n\nractive.insert()\n\n\nInserts the instance to a different location. If the instance is currently in the DOM, it will be detached first. See also \nractive.detach()\n.\n\n\nSyntax\n\n\n\n\nractive.insert(target[, anchor])\n\n\n\n\nArguments\n\n\n\n\ntarget (string|Node|array-like)\n: The new parent element.\n\n\n[anchor] (string|Node|array-like)\n: The sibling element to insert the instance before. If omitted, the instance will be inserted as the last child of the parent.\n\n\n\n\nReturns\n\n\n\n\n(undefined)\n\n\n\n\nExamples\n\n\n\n\n\nRactive.components.aaa = Ractive.extend({\n    template: \nbutton\n{{yield}}\n/button\n\n})\n\nRactive({\n    ...\n    template: `\n        \nbutton on-click=\nmove\nteleport\n/button\n\n        \nbutton on-click=\nrestore\nrestore\n/button\n\n\n        \ndiv id=\ncontainer1\n style=\nborder: 2px solid yellow; min-height: 50px\n\n            \naaa\nhello\n/aaa\n\n        \n/div\n\n\n        \ndiv id=\ncontainer2\n style=\nborder: 1px solid red; min-height: 50px\n\n\n        \n/div\n\n    `,\n    on: {\n        move () {\n          const aaa = this.findComponent('aaa')\n          const target = this.find('#container2')\n          aaa.insert(target)\n        },\n        restore () {\n          const aaa = this.findComponent('aaa')\n          const target = this.find('#container1')\n          aaa.insert(target)\n        }\n    }\n})\n\n\n\n\nractive.link()\n\n\nCreates a link between two keypaths that keeps them in sync. Since Ractive can't always watch the contents of objects, copying an object to two different keypaths in your data usually leads to one or both of them getting out of sync. \nlink\n creates a sort of symlink between the two paths so that Ractive knows they are actually the same object. This is particularly useful for master/detail scenarios where you have a complex list of data and you want to be able to select an item to edit in a detail form.\n\n\nSyntax\n\n\n\n\nractive.link(source, destination, options)\n\n\n\n\nArguments\n\n\n\n\nsource (string)\n: The keypath of the source item.\n\n\ndestination (string)\n: The keypath to use as the destination - or where you'd like the data 'copied'.\n\n\noptions (hash)\n:\n\n\ninstance\n or \nractive\n: The Ractive instance in which to find the source keyapth. This allows cross-instance linking much like mapped paths between components.\n\n\nkeypath\n: \nfrom\n \n0.9.4\n - The keypath to register as the source of the link. This is an advanced option that allows you to specify how the link should shuffle. For instance \nitems.0.name\n will never shuffle, but if the keypath is specified as \n.name\n, then it will shuffle when \nitems.0\n shuffles.\n\n\n\n\nReturns\n\n\n\n\n(Promise)\n: Returns a promise.\n\n\n\n\nExamples\n\n\nractive.link( 'some.nested.0.list.25.item', 'current' )\nractive.set( 'current.name', 'Rich' ); // some.nested.0.list.25.item.name is also updated to be 'Rich'\n\n\n\n\nThis can be used to great effect with method events and the \n@keypath\n special ref:\n\n\n{{#each some.nested}}\n  {{#each list}}\n    {{#with item}}\n      {{.name}}\n      \nbutton on-click=\nevent.link('.', 'current')\nSelect\n/button\n\n    {{/with}}\n  {{/each}}\n{{/each}}\n\nName: \ninput value=\n{{~/current.name}}\n /\n\n\n\n\n\nLinks can be removed using \nractive.unlink()\n.\n\n\nractive.observe()\n\n\nObserves the data at a particular keypath. Unless specified otherwise, the callback will be fired immediately, with \nundefined\n as \noldValue\n. Thereafter it will be called whenever the \nobserved keypath\n changes.\n\n\nSyntax\n\n\n\n\nractive.observe(keypath, callback[, options])\n\n\nractive.observe(map[, options])\n\n\n\n\nArguments\n\n\n\n\n\n\nkeypath (String)\n: The keypath to observe, or a group of space-separated keypaths. Any of the keys can be a \n*\n character, which is treated as a wildcard. A \n**\n means recursive.\n\n\nThe difference between \n*\n and \n**\n is that \n*\n provides your callback function \nvalue\n and \nkeypath\n arguments containing the path of the what actually changed, at any level of the keypath. So instead of getting the same parent value on every change, you get the changed value from whatever arbitrarily deep keypath changed.\n\n\n\n\n\n\ncallback (Function)\n: The function that will be called, with \nnewValue\n, \noldValue\n and \nkeypath\n as arguments (see Observers for more nuance regarding these arguments), whenever the observed keypath changes value. By default the function will be called with \nractive\n as \nthis\n. Any wildcards in the keypath will have their matches passed to the callback at the end of the arguments list as well.\n\n\n\n\nmap (Object)\n: A map of keypath-observer pairs.\n\n\n[options] (Object)\n:\n\n\n[init] (boolean)\n: Defaults to \ntrue\n. Whether or not to initialise the observer, i.e. call the function with the current value of \nkeypath\n as the first argument and \nundefined\n as the second.\n\n\n[defer] (boolean)\n: Defaults to \nfalse\n, in which case observers will fire before any DOM changes take place. If \ntrue\n, the observer will fire once the DOM has been updated.\n\n\nlinks] (boolean)\n: Defaults to \nfalse\n.  Whether or not the observer should \"follow through\" any links created with [\nractive.link()\n.\n\n\n[strict] (boolean)\n: Defaults to \nfalse\n. \nstrict\n uses object identity to determine if there was a change, meaning that unless the primary object changed, it won't trigger the observer. For example with \n{ data: { foo: { bar: 'baz' } } }\n, \nractive.observe('foo', ..., { strict: true })\n will not fire on \nractive.set('foo.bar', 'bat')\n but will on \nractive.set('foo', { bar: 'bip' })\n.\n\n\n[context] (any)\n: Defaults to \nractive\n. The context the observer is called in (i.e. the value of \nthis\n)\n\n\n[array] (boolean)\n: Defaults to \nfalse\n. Whether or not to observe the keypath as an array, meaning that change events will fire with a object containing two lists, \ninserted\n containing added elements, and \ndeleted\n containing removed elements. There is also a \nstart\n integer property indicating the index at which the replacements begin.\n\n\n[old] (function)\n: Defaults to \nundefined\n. A function that can be used to modify the \nold\n value passed to the observer callback. This can be used to freeze the old value, create a deep clone of it for future firings, etc.\n\n\n\n\n\n\n\n\nReturns\n\n\n\n\n(Object)\n: A handle object for controlling any observers created by the call to \nobserve\n\n\ncancel\n: Permanently stops observers controlled by the handle.\n\n\nisSilenced\n: Returns \ntrue\n if this handle is currently silenced.\n\n\nsilence\n: Stop calling callbacks associated with this handle. The observers are still processed by Ractive, so the old value will still be updated. This means that setting a new value on an observer while it is silenced, resuming the observer, and then setting the same value again will \nnot\n result in the callback being fired if it would not be fired by the same sequence without silencing.\n\n\nresume\n: Resume calling callbacks associated with this handle.\n\n\n\n\n\n\n\n\nExamples\n\n\n// TODO\n\n\n\n\nNote that you can observe keypath \npatterns\n...\n\n\nractive.observe( 'items.*.status', function ( newValue, oldValue, keypath) {\n  var index = /items.(\\d+).status/.exec( keypath )[1]\n  alert( 'item ' + index + ' status changed from ' + oldValue + ' to ' + newValue )\n})\n\n\n\n\n...or multiple space-separated keypaths simultaneously:\n\n\nractive.observe( 'foo bar baz', function ( newValue, oldValue, keypath ) {\n  alert( keypath ) + ' changed from ' + oldValue + ' to ' + newValue )\n})\n\n\n\n\nSee Observers for more detail.\n\n\nractive.observeOnce()\n\n\nObserves the data at a particular keypath until the first change. After the handler has been called, it will be unsubscribed from any future changes.\n\n\nSyntax\n\n\n\n\nractive.observeOnce(keypath, callback[, options])\n\n\n\n\nArguments\n\n\n\n\nkeypath (string)\n: The keypath to observe, or a group of space-separated keypaths. Any of the keys can be a `` character, which is treated as a wildcard.\n\n\ncallback (Function)\n: The function that will be called, with \nnewValue\n, \noldValue\n and \nkeypath\n as arguments (see Observers for more nuance regarding these arguments), whenever the observed keypath changes value. By default the function will be called with \nractive\n as \nthis\n. Any wildcards in the keypath will have their matches passed to the callback at the end of the arguments list as well.\n\n\n[options] (Object)\n:\n\n\n[defer] (boolean)\n: Defaults to \nfalse\n, in which case observers will fire before any DOM changes take place. If \ntrue\n, the observer will fire once the DOM has been updated.\n\n\n[context] (any)\n: Defaults to \nractive\n. The context the observer is called in (i.e. the value of \nthis\n)\n\n\n\n\n\n\n\n\nReturns\n\n\n\n\n(Object)\n: An object with a \ncancel\n method, for cancelling the observer.\n\n\n\n\nExamples\n\n\n// TODO\n\n\n\n\nNote that you can observe keypath \npatterns\n...\n\n\nractive.observeOnce( 'items.*.status', function ( newValue, oldValue, keypath ) {\n  var index = /items.(\\d+).status/.exec( keypath )[1]\n  alert( 'item ' + index + ' status changed from ' + oldValue + ' to ' + newValue )\n})\n\n\n\n\n...or multiple space-separated keypaths simultaneously:\n\n\nractive.observeOnce( 'foo bar baz', function ( newValue, oldValue, keypath ) {\n  alert( keypath + ' changed from ' + oldValue + ' to ' + newValue )\n})\n\n\n\n\nSee Observers for more detail.\n\n\nractive.off()\n\n\nRemoves an event handler, several event handlers, or all event handlers.\n\n\nTo remove a single handler, you must specify both the event name and the handler. If you only specify the event name, all handlers bound to that event name will be removed. If you specify neither event name nor handler, \nall\n event handlers will be removed.\n\n\nAn alternative way to remove event handlers is to use the \ncancel\n method of the return value of a call to \nractive.on()\n.\n\n\nSyntax\n\n\n\n\nractive.off([eventName[, handler]])\n\n\n\n\nArguments\n\n\n\n\neventName (string)\n: The event name to which this handler is currently bound.\n\n\nhandler (Function)\n: The handler to remove.\n\n\n\n\nReturns\n\n\n\n\n(Ractive)\n: Returns the \nractive\n instance to allow this call to be chainable.\n\n\n\n\nExamples\n\n\n// TODO\n\n\n\n\nractive.on()\n\n\nSubscribe to events.\n\n\nSyntax\n\n\n\n\nractive.on(eventName, handler)\n\n\nractive.on(obj)\n\n\n\n\nArguments\n\n\n\n\neventName (String)\n: The name of the event to subscribe to\n\n\nhandler (Function)\n: The function that will be called, with \nractive\n as \nthis\n. The arguments depend on the event, but the first argument is always a context object. Returning \nfalse\n from the handler will stop propagation and prevent default of DOM events and cancel event bubbling.\n\n\nobj (Object)\n: An object with keys named for each event to subscribe to. The value at each key is the handler function for that event.\n\n\n\n\nReturns\n\n\n\n\n(Object)\n: A handle object for controlling any listners created by the call to \non\n\n\ncancel\n: Permanently stops listeners controlled by the handle.\n\n\nisSilenced\n: Returns \ntrue\n if this handle is currently silenced.\n\n\nsilence\n: Stop calling callbacks associated with this handle.\n\n\nresume\n: Resume calling callbacks associated with this handle.\n\n\n\n\n\n\n\n\nExamples\n\n\n// single handler to function\nractive.on( 'activate', function () {...})\n\n// wildcard pattern matching\nractive.on( 'foo.*', function () {...} )\n\n// multiple handlers to one function\nractive.on( 'activate select', function () {...} )\n\n// map of handler/function pairs\nractive.on({\n  activate () {...},\n  select () {...}\n})\n\n// knock yourself out:\nractive.on({\n  activate () {...},\n  'bip bop boop' () {...},\n  'select foo.* bar' () {...}\n})\n\n\n\n\nractive.once()\n\n\nSubscribe to an event for a single firing. This is a convenience function on top of \nractive.on()\n.\n\n\nSyntax\n\n\n\n\nractive.once(eventName, handler)\n\n\n\n\nArguments\n\n\n\n\neventName (string)\n: The name of the event to subscribe to.\n\n\nhandler (Function)\n: The function that will be called, with \nractive\n as \nthis\n. The arguments depend on the event, but the first argument is always a context object. Returning \nfalse\n from the handler will stop propagation and prevent default of DOM events and cancel event bubbling.\n\n\n\n\nReturns\n\n\n\n\n(Object)\n: Returns an \nObject\n with a \ncancel\n method, which removes the handler.\n\n\n\n\nExamples\n\n\n// TODO\n\n\n\n\nractive.pop()\n\n\nThe Ractive equivalent to \nArray.pop\n that removes an element from the end of the array at the given keypath and triggers an update event.\n\n\nIf the given keypath does not exist (is \nundefined\n), an empty array will be supplied instead. Otherwise, if the given keypath does not resolve to an array, an error will be thrown.\n\n\nSyntax\n\n\n\n\nractive.pop(keypath)\n\n\n\n\nArguments\n\n\n\n\nkeypath (string)\n: The keypath of the array to change, e.g. \nlist\n or \norder.items\n.\n\n\n\n\nReturns\n\n\n\n\n(Promise)\n: Returns a promise that will resolve with the removed element after the update is complete.\n\n\n\n\nExamples\n\n\n// TODO\n\n\n\n\nractive.push()\n\n\nThe Ractive equivalent to \nArray.push\n that appends one or more elements to the array at the given keypath and triggers an update event.\n\n\nIf the given keypath does not exist (is \nundefined\n), an empty array will be supplied instead. Otherwise, if the given keypath does not resolve to an array, an error will be thrown.\n\n\nSyntax\n\n\n\n\nractive.push(keypath, value[, ...valueN])\n\n\n\n\nArguments\n\n\n\n\nkeypath (string)\n: The keypath of the array to change, e.g. \nlist\n or \norder.items\n.\n\n\nvalue (any)\n: The value to append to the end of the array. One or more values may be supplied.\n\n\n\n\nReturns\n\n\n\n\n(Promise)\n - Returns a Promise that will resolve after the update is complete.\n\n\n\n\nExamples\n\n\n// TODO\n\n\n\n\nractive.readLink()\n\n\nGets the source keypath and instance for a link.\n\n\nSyntax\n\n\n\n\nractive.readLink(link[, options])\n\n\n\n\nArguments\n\n\n\n\nlink (string)\n: The keypath for the link that you would like to read.\n\n\noptions (Object)\n:\n\n\n[canonical] (boolean)\n: Whether or not to read through any intermediate links too. Pass \ncanonical: true\n to read through links to links all the way to the canonical data keypath. Defaults to \nfalse\n.\n\n\n\n\n\n\n\n\nReturns\n\n\n\n\n(Object)\n:\n\n\nkeypath (string)\n: The source keypath to which the link points.\n\n\nractive (Ractive)\n: The source Ractive instance that contains the keypath to which the link points.\n\n\n\n\n\n\n\n\nExamples\n\n\nconst r = Ractive({\n  data: {\n    items: [\n      { name: 'Apple' },\n      { name: 'Banana' },\n      { name: 'Orange' }\n    ]\n  }\n})\n\nr.link( 'items.0', 'currentItem' )\n\nr.readLink( 'currentItem' )\n// returns { ractive: r, keypath: 'items.0' }\n\n\n\n\nractive.render()\n\n\nRenders the component into a DOM element.\n\n\nSyntax\n\n\n\n\nractive.render(target)\n\n\n\n\nArguments\n\n\n\n\ntarget (Node|String|array-like)\n: The DOM element to render to.\n\n\n\n\nReturns\n\n\n\n\n(Promise)\n: A promise that resolves when rendering completes or when the instance is already rendered.\n\n\n\n\nExamples\n\n\n// TODO\n\n\n\n\nractive.reset()\n\n\nResets the entire \nractive.data\n object and updates the DOM.\n\n\nSyntax\n\n\n\n\nractive.reset(data)\n\n\n\n\nArguments\n\n\n\n\ndata (Object)\n: The data to reset with. Defaults to \n{}\n.\n\n\n\n\nReturns\n\n\n\n\n(Promise)\n: A promise.\n\n\n\n\nExamples\n\n\nThis differs from \nractive.set()\n in the following way:\n\n\nractive = Ractive({\n  // ...,\n  data: { foo: 1 }\n})\n\nractive.set({ bar: 2 })\nconsole.log( ractive.get() ); // { foo: 1, bar: 2 }\n\nractive.reset({ bar: 2 })\nconsole.log( ractive.get() ); // { bar: 2 }\n\n\n\n\nractive.resetPartial()\n\n\nResets a partial and re-renders all of its use-sites, including in any components that have inherited it. If a component has a partial with a same name that is its own, that partial will not be affected.\n\n\nInline partials that don't belong directly to a Ractive instance aren't affected by \nresetPartial\n.\n\n\nSyntax\n\n\n\n\nractive.resetPartial(name, partial)\n\n\n\n\nArguments\n\n\n\n\nname (string)\n: The partial to reset.\n\n\npartial (string|Object|Function)\n: A template string, pre-parsed template or a function that returns either.\n\n\n\n\nReturns\n\n\n\n\n(Promise)\n: A promise.\n\n\n\n\nExamples\n\n\nractive = Ractive({\n  // ...,\n  partials: { foo: 'foo' }\n})\n\n// {{\nfoo}} will be replaced with 'foo'\n\nractive.resetPartial('foo', 'bar')\n\n// {{\nfoo}} will be replaced with 'bar'\n\n\n\n\nractive.resetTemplate()\n\n\nResets the template and re-renders the entire instance using the new template.\n\n\nSyntax\n\n\n\n\nractive.resetTemplate(template)\n\n\n\n\nArguments\n\n\n\n\ntemplate (string|Object)\n: The new template to use. If an object, the template should be the result of \nRactive.parse\n with both version and template array properties.\n\n\n\n\nReturns\n\n\n\n\n(Promise)\n: A promise that resolves once any transitions that are triggered during the re-render are completed.\n\n\n\n\nExamples\n\n\nconst ractive = new Ractive({\n  // ...,\n  template: 'replace me'\n});\n\nractive.resetTemplate('you have been replaced');\nractive.set('foo', 'world');\nractive.resetTemplate(Ractive.parse('Hello, {{foo}}'));\n\n\n\n\nractive.reverse()\n\n\nThe Ractive equivalent to \nArray.reverse\n reverses the array at the given keypath and triggers an update event.\n\n\nIf the given keypath does not resolve to an array, an error will be thrown.\n\n\nSyntax\n\n\n\n\nractive.reverse(keypath)\n\n\n\n\nArguments\n\n\n\n\nkeypath (String)\n: The keypath of the array to reverse, e.g. \nlist\n or \norder.items\n\n\n\n\nReturns\n\n\n\n\n(Promise)\n - A promise that will resolve after the update is complete.\n\n\n\n\nExamples\n\n\n// TODO\n\n\n\n\nractive.set()\n\n\nUpdates data and triggers a re-render of any mustaches that are affected (directly or indirectly) by the change. Any observers of affected keypaths will be notified.\n\n\nWhen setting an array value, ractive will reuse the existing DOM nodes for the new array, adding or removing nodes as necessary. This can impact nodes with transitions. Use the \nshuffle\n option for setting a new array value while retaining existing nodes corresponding to individual array item values.\n\n\nSyntax\n\n\n\n\nractive.set(keypath, value[, options])\n\n\nractive.set(map[, options])\n\n\n\n\nArguments\n\n\n\n\nkeypath (string)\n: The keypath of the data we're changing, e.g.\n\n\nuser\n\n\nuser.name\n\n\nuser.friends[1]\n or \nuser.friends.1\n\n\nusers.*.status\n\n\nimages.aaa\\\\.jpg.url\n.\n\n\n\n\n\n\nvalue (any)\n: The value we're changing it to. Can be a primitive or an object (or array), in which case dependants of \ndownstream keypaths\n will also be re-rendered (if they have changed).\n\n\nmap (Object)\n: A map of \nkeypath: value\n pairs, as above.\n\n\n[options] Object\n:\n\n\ndeep (boolean)\n: Whether or not to perform a deep set on with the data at the given keypath. A deep set recursively merges the given data into the data structure at the given keypath. Defaults to \nfalse\n.\n\n\nshuffle (boolean|string|Function)\n: Whether or not to add/move/remove DOM associated with elements rather than just re-using the existing DOM. Defaults to \nfalse\n.\n\n\ntrue\n: Add/move/remove existing items to their new index using a strict equality comparison.\n\n\nstring\n: Add/move/remove existing items to their new index using a property comparison where the property compared is named by the given string.\n\n\nFunction\n: Add/move/remove existing items to their new index using the value returned by the given function for comparison.\n\n\n\n\n\n\nkeep (boolean)\n: Whether or not to keep the virtual DOM that would be disposed by the \nset\n operation. This is useful for hiding components without completely tearing them down and recreating them. It's also a little bit faster, as the virtual DOM doesn't have to be recreated when it would reappear. When the virtual DOM is re-rendered, it will also us the progressive enhancement process to reuse the existing DOM nodes that were detached originalls. Defaults to \nfalse\n.\n\n\n\n\n\n\n\n\nReturns\n\n\n\n\n(Promise)\n: Returns a promise that will resolved after any transitions associated with the operation are complete.\n\n\n\n\nExamples\n\n\n// TODO\n\n\n\n\nThe \nkeypath\n can also contain wildcards pattern-observers. All matching keypaths will be set with the supplied values:\n\n\nractive.on('selectAll', function () {\n  ractive.set('items.*.selected', true)\n})\n\n\n\n\nSee Also\n\n\n\n\nRactive.escapeKey()\n\n\n\n\nractive.shift()\n\n\nThe Ractive equivalent to \nArray.shift\n that removes an element from the beginning of the array at the given keypath and triggers an update event.\n\n\nIf the given keypath does not exist (is \nundefined\n), an empty array will be supplied instead. Otherwise, if the given keypath does not resolve to an array, an error will be thrown.\n\n\nSyntax\n\n\n\n\nractive.shift(keypath)\n\n\n\n\nArguments\n\n\n\n\nkeypath (string)\n: The keypath of the array to change, e.g. \nlist\n or \norder.items\n.\n\n\n\n\nReturns\n\n\n\n\n(Promise)\n: A promise that will resolve with the removed element after the update is complete.\n\n\n\n\nExamples\n\n\n// TODO\n\n\n\n\nractive.sort()\n\n\nThe Ractive equivalent to \nArray.sort\n sorts the array at the given keypath and triggers an update event.\n\n\nIf the given keypath does not resolve to an array, an error will be thrown.\n\n\nSyntax\n\n\n\n\nractive.sort(keypath[, compareFunction])\n\n\n\n\nArguments\n\n\n\n\nkeypath (string)\n: The keypath of the array to sort, e.g. \nlist\n or \norder.items\n.\n\n\ncompareFunction (Function)\n: A function that defines the sort order.\n\n\n\n\nReturns\n\n\n\n\n(Promise)\n: Returns a promise that will resolve after the update is complete.\n\n\n\n\nExamples\n\n\n// TODO\n\n\n\n\nractive.splice()\n\n\nThe Ractive equivalent to \nArray.splice\n that can add new elements to the array while removing existing elements.\n\n\nIf the given keypath does not exist (is \nundefined\n), an empty array will be supplied instead. Otherwise, if the given keypath does not resolve to an array, an error will be thrown.\n\n\nSyntax\n\n\n\n\nractive.splice(keypath, index, [removeCount[, add]])\n\n\n\n\nArguments\n\n\n\n\nkeypath (string)\n: The keypath of the array to change, e.g. \nlist\n or \norder.items\n.\n\n\nindex (number)\n: The index at which to start the operation.\n\n\n[removeCount] (number)\n: The number of elements to remove starting with the element at *\nindex\n. This may be 0 if you don't want to remove any elements.\n\n\n[add] (any)\n: Any elements to insert into the array starting at *\nindex\n. There can be 0 or more elements passed to add to the array.\n\n\n\n\nReturns\n\n\n\n\n(Promise)\n: Returns a promise that will resolve with the removed elements after the update is complete.\n\n\n\n\nExamples\n\n\n// TODO\n\n\n\n\nractive.subtract()\n\n\nDecrements the selected keypath.\n\n\nSyntax\n\n\n\n\nractive.subtract(keypath[, number])\n\n\n\n\nArguments\n\n\n\n\nkeypath (string)\n: The keypath of the number we're decrementing.\n\n\n[number] (number)\n: Defaults to \n1\n. The number to decrement by.\n\n\n\n\nReturns\n\n\n\n\n(Promise)\n: Returns a promise.\n\n\n\n\nExamples\n\n\n// TODO\n\n\n\n\nractive.teardown()\n\n\nUnrenders this Ractive instance, removing any event handlers that were bound automatically by Ractive.\n\n\nCalling \nractive.teardown()\n causes a \nteardown\n event to be fired - this is most useful with \nRactive.extend()\n as it allows you to clean up anything else (event listeners and other bindings) that are part of the subclass.\n\n\nSyntax\n\n\n\n\nractive.teardown()\n\n\n\n\nArguments\n\n\n\n\nNone\n\n\n\n\nReturns\n\n\n\n\n(Promise)\n: A promise.\n\n\n\n\nExamples\n\n\n// TODO\n\n\n\n\nractive.toCSS()\n\n\nReturns the scoped CSS of the current instance and its descendants.\n\n\nAt the moment, this will not work on a direct instance of Ractive and will log a warning. You can only use this method on an instance of a subclass.\n\n\nSyntax\n\n\n\n\nractive.toCSS()\n\n\n\n\nArguments\n\n\n\n\nNone\n\n\n\n\nReturns\n\n\n\n\n(string)\n: The scoped CSS of the instance.\n\n\n\n\nExamples\n\n\nconst Subclass = Ractive.extend({\n    ...\n    css: 'div{ color: red }'\n    ...\n})\n\nconst subclassInstance = Subclass({...})\n\n// Contains the scoped version of div{ color: red }\nsubclassInstance.toCSS()\n\n\n\n\nractive.toHTML()\n\n\nReturns a chunk of HTML representing the current state of the instance. This is most useful when you're using Ractive in node.js, as it allows you to serve fully-rendered pages (good for SEO and initial pageload performance) to the client.\n\n\nSyntax\n\n\n\n\nractive.toHTML()\n\n\n\n\nArguments\n\n\n\n\nNone\n\n\n\n\nReturns\n\n\n\n\n(string)\n: The instance HTML.\n\n\n\n\nExamples\n\n\n// TODO\n\n\n\n\nractive.toggle()\n\n\nToggles the selected keypath. In other words, if \nfoo\n is truthy, then \nractive.toggle('foo')\n will make it \nfalse\n, and vice-versa.\n\n\nSyntax\n\n\n\n\nractive.toggle(keypath)\n\n\n\n\nArguments\n\n\n\n\nkeypath (string)\n: The keypath to toggle the value of. If \nkeypath\n is a pattern, then all matching keypaths will be toggled.\n\n\n\n\nReturns\n\n\n\n\n(Promise)\n: A promise.\n\n\n\n\nExamples\n\n\n// TODO\n\n\n\n\nractive.transition()\n\n\nTriggers a transition on a node managed by this Ractive instance.\n\n\nSyntax\n\n\n\n\nractive.transition(transition, node, options)\n\n\n\n\nArguments\n\n\n\n\ntransition (string|Function)\n: A transition function or a name of a transition function.\n\n\nnode (HTMLElement)\n: The node on which to start the transition - optional if called from within a Ractive event handler, as it will be retrieved from the event if not supplied.\n\n\noptions (Object)\n: Options supplied to the transition.\n\n\n\n\nReturns\n\n\n\n\n(Promise)\n: A promise that resolves when the transition completes.\n\n\n\n\nExamples\n\n\n// TODO\n\n\n\n\nractive.unlink()\n\n\nRemoves a link set up by \nractive.link()\n.\n\n\nSyntax\n\n\n\n\nractive.unlink(destination)\n\n\n\n\nArguments\n\n\n\n\ndestination (string)\n: The destination supplied to [\nractive.link()\n].\n\n\n\n\nReturns\n\n\n\n\n(Promise)\n: A promise.\n\n\n\n\nExamples\n\n\n// TODO\n\n\n\n\nractive.unrender()\n\n\nUnrenders this Ractive instance, throwing away any DOM nodes associated with this instance. This is the counterpart to \nractive.render()\n. The rest of the ractive instance is left intact, unlike \nractive.teardown()\n.\n\n\nNote that if the instance happens to be a component that is managed by another instance, the owning instance may veto the call to \nunrender\n. If you need more precise control over component rendering, you should probably use an anchor and \nractive.attachChild()\n instead.\n\n\nSyntax\n\n\n\n\nractive.unrender()\n\n\n\n\nArguments\n\n\n\n\nNone\n\n\n\n\nReturns\n\n\n\n\n(Promise)\n: A promise.\n\n\n\n\nExamples\n\n\n// TODO\n\n\n\n\nractive.unshift()\n\n\nThe Ractive equivalent to \nArray.unshift\n that prepends one or more elements to the array at the given keypath and triggers an update event.\n\n\nIf the given keypath does not exist (is \nundefined\n), an empty array will be supplied instead. Otherwise, if the given keypath does not resolve to an array, an error will be thrown.\n\n\nSyntax\n\n\n\n\nractive.unshift(keypath, value)\n\n\n\n\nArguments\n\n\n\n\nkeypath (string)\n: The keypath of the array to change, e.g. \nlist\n or \norder.items\n.\n\n\nvalue (any)\n: The value to prepend to the beginning of the array. One or more values may be supplied.\n\n\n\n\nReturns\n\n\n\n\n(Promise)\n: Returns a promise that will resolve after the update is complete.\n\n\n\n\nExamples\n\n\n// TODO\n\n\n\n\nractive.update()\n\n\n\"Dirty checks\" everything that depends directly or indirectly on the specified keypath. If no \nkeypath\n is specified, all keypaths will be checked. Keypaths that involve special references (i.e. \n@global\n) require the keypath to be supplied.\n\n\nThis is useful when manipulating the instance's data without using the built in setter methods (i.e. \nractive.set()\n, \nractive.animate()\n).\n\n\nSyntax\n\n\n\n\nractive.update([keypath][, options])\n\n\n\n\nArguments\n\n\n\n\n[keypath] (string)\n: The keypath to treat as 'dirty'.\n\n\n[options] (Object\nstring, any\n)\n:\n\n\nforce (boolean)\n: Force an update regardless of whether or not the internal change check determines that the keypath has \nactually\n changed. This is useful for forcing all expressions referencing a particular function to recompute.\n\n\n\n\n\n\n\n\nReturns\n\n\n\n\n(Promise)\n: A promise that resolves when any transitions associated with the operation complete.\n\n\n\n\nExamples\n\n\nractive.observe( 'foo', function ( foo ) {\n  alert( foo )\n})\n\nmodel.foo = 'changed';   // Does not cause the instance to update.\nractive.update( 'foo' ); // Informs the instance that foo was changed externally.\n\n\n\n\nractive.updateModel()\n\n\nIf you programmatically manipulate inputs and other elements that have two\u2010way binding set up, your model can get out of sync. In these cases, we need to force a resync with \nractive.updateModel()\n:\n\n\nSyntax\n\n\n\n\nractive.updateModel([keypath[, cascade]])\n\n\n\n\nArguments\n\n\n\n\nkeypath (string)\n: The keypath to treat as 'dirty'. Any two-way bindings linked to this keypath will be checked to see if the model is out of date\n\n\ncascade (boolean)\n: If true, bindings that are \ndownstream\n of \nkeypath\n will also be checked - e.g. \nractive.updateModel( 'items', true )\n would check \nitems.0.foo\n and \nitems.1.foo\n and so on. Defaults to \nfalse\n.\n\n\n\n\nReturns\n\n\n\n\n(Promise)\n: A promise. If a \nkeypath\n is not specified, all two-way bindings will be checked.\n\n\n\n\nExamples\n\n\nractive = Ractive({\n  el: 'container',\n  template: '\ninput value=\n{{name}}\n'\n  data: { name: 'Bob' }\n})\n\nractive.find( 'input' ).value = 'Jim'\nalert( ractive.get( 'name' ) ); // alerts 'Bob', not 'Jim'\n\nractive.updateModel()\nalert( ractive.get( 'name' ) ); // alerts 'Jim'\n\n\n\n\nContext Object\n\n\nThe context object is the type of object you receive when calling getContext(). This object contains various properties and methods that allow you to interact with and obtain information about the Ractive instance, the node associated with it and the context surrounding it.\n\n\nThe special \n@context\n reference is also a context object that is associated with the nearest VDOM item and element. It's frequently used with event directives to interact with the data associated with the immediate context.\n\n\nHelper methods that take a keypath will resolve relative to that node's context. Special references, template aliases, and key and index aliases are supported. If the method doesn't require a keypath, like \nget\n, then the keypath will implicitly be \n.\n rather than \n~/\n, as with regular instance methods.\n\n\ncontext.add()\n\n\nSee ractive.add().\n\n\ncontext.animate()\n\n\nSee ractive.animate().\n\n\ncontext.decorators\n\n\n(Object)\n\n\nA map of decorator name to decorator return object for all of the decorators on the node associated with the context.\n\n\ncontext.event\n\n\n(Event|undefined)\n\n\nThe original event for contexts supplied to event directives. This is \nundefined\n for contexts not associated with an event.\n\n\ncontext.get()\n\n\nSee ractive.get().\n\n\ncontext.getBinding()\n\n\nReturns the value of the binding if the node represented by this info object has a two-way binding.\n\n\nSyntax\n\n\n\n\ncontext.getBinding()\n\n\n\n\nArguments\n\n\n\n\nNone\n\n\n\n\nReturns\n\n\n\n\n(any)\n: The value of the binding.\n\n\n\n\nExamples\n\n\n{{#with foo.bar}}\ninput id=\nfindMe\n value=\n{{.baz}}\n /\n{{/with}}\n\n\n\n\nRactive.getContext('#findMe').getBinding(); // returns value of foo.bar.baz\n\n\n\n\ncontext.getBindingPath()\n\n\nReturns the keypath of the binding if the node represented by this info object has a two-way binding.\n\n\nSyntax\n\n\n\n\ncontext.getBindingPath([ractive])\n\n\n\n\nArguments\n\n\n\n\n[ractive] (Ractive)\n: The instance to resolve the keypath against.\n\n\n\n\nReturns\n\n\n\n\n(string)\n: The keypath of the node binding.\n\n\n\n\nExamples\n\n\n{{#with foo.bar}}\ninput id=\nfindMe\n value=\n{{.baz}}\n /\n{{/with}}\n\n\n\n\nRactive.getContext('#findMe').getBindingPath(); // Returns \nfoo.bar.baz\n\n\n\n\n\ncontext.getParent()\n\n\nFrom\n \n0.9.4\n\n\nGets the parent context of this context. This is finer grained than element access provided by \nRactive.getContext\n, as it can target sections that exist nested between elements.\n\n\nSyntax\n\n\n\n\ncontext.getParent(crossComponentBoundary)\n\n\n\n\nArguments\n\n\n\n\ncrossComponentBoundary (boolean)\n: Whether or not to cross into the context containing a component. Defaults to \nfalse\n.\n\n\n\n\nReturns\n\n\n\n\n(context)\n: The parent context object.\n\n\n\n\nExamples\n\n\ndiv\n{{#with foo.bar}}{{#with .baz}}\nspan /\n{{/with}}{{/with}}\n/div\n\n\n\n\n\nconst ctx = Ractive.getContext('span')\nctx.resolve(); // foo.bar.baz\nconst parent = ctx.getParent()\nparent.resolve(); // foo.bar\n\n\n\n\ncontext.hasListener()\n\n\nReturns \ntrue\n if the element associated with the context has a Ractive-managed event listener for a given event name. The target event does not have to be an actual DOM event, so this method can be used conveniently in conjunction with \ncontext.raise\n.\n\n\nSyntax\n\n\n\n\ncontext.hasListener(event[, bubble])\n\n\n\n\nArguments\n\n\n\n\nevent (string)\n: The name of the event for which to check for listeners.\n\n\nbubble (boolean)\n: Whether or not to check parent elements for the event name as well, should the target element not have a listener. Defaults to \nfalse\n.\n\n\n\n\nReturns\n\n\n\n\n(boolean)\n: \ntrue\n if a listener was found or \nfalse\n otherwise.\n\n\n\n\nExamples\n\n\nsection on-other=\nothered\n\n  \narticle on-thing=\nthinged\nSome text...\n/article\n\n\n/section\n\n\n\n\n\nconst ctx = ractive.getContext('article');\nctx.hasListener('thing'); // true\nctx.hasListener('other'); // false\nctx.hasListener('other', true); // true\n\n\n\n\ncontext.isBound()\n\n\nReturns \ntrue\n if the node represented by this info object has a two-way binding.\n\n\nSyntax\n\n\n\n\ncontext.isBound()\n\n\n\n\nArguments\n\n\n\n\nNone\n\n\n\n\nReturns\n\n\n\n\n(boolean)\n: \ntrue\n if the node represented has a two-way binding.\n\n\n\n\nExamples\n\n\n{{#with foo.bar}}\n  \ninput id=\nfoo\n value=\n{{.baz}}\n /\n\n  \ninput id=\nbar\n value=\n /\n\n{{/with}}\n\n\n\n\nRactive.getContext('#foo').isBound(); // Returns true\nRactive.getContext('#bar').isBound(); // Returns false\n\n\n\n\ncontext.link()\n\n\nSee ractive.link().\n\n\ncontext.listen()\n\n\nSubscribes an event listener either directly on the node associated with the context or as a delegate if appropriate. This is not like the \non\n method, but is instead basically an \naddEventListener\n helper that is delegation-aware.\n\n\nSyntax\n\n\ncontext.listen( event, callback )\n\n\nArguments\n\n\n\n\nevent (string)\n: The name of the event to subscribe.\n\n\ncallback (function)\n: The callback function to be called when the event fires.\n\n\n\n\nReturns\n\n\n\n\n(Object)\n: An object with a \ncancel\n method to unlisten the event.\n\n\n\n\ncontext.node\n\n\n(Node|undefined)\n\n\nThe node associated with the context. Note that it is possible to get a context that is not associated with an element, which will leave the node \nundefined\n.\n\n\ncontext.observe()\n\n\nSee ractive.observe().\n\n\ncontext.observeOnce()\n\n\nSee ractive.observeOnce().\n\n\ncontext.original\n\n\n(Event|undefined)\n\n\nThe original DOM event object. Normally present when the event is a Ractive DOM event. May be \nundefined\n on custom events or events from event plugins.\n\n\ncontext.pop()\n\n\nSee ractive.pop().\n\n\ncontext.push()\n\n\nSee ractive.push().\n\n\ncontext.ractive\n\n\n(Ractive)\n\n\nThis property holds a reference to the Ractive instance that controls the node represented by this info object.\n\n\ncontext.raise()\n\n\nTriggers the nearest matching event directive relative to the context. This is useful for decorators and other library constructs that want to be able to raise their own events that aren't necessarily tied to a DOM event. Raised events do not bubble.\n\n\nSyntax\n\n\n\n\ncontext.raise(eventName[, event[, ...args]])\n\n\n\n\nArguments\n\n\n\n\neventName (string)\n: The name of the event to raise. For \ndiv on-something=\"...\"\n, the event name would be \n'something'\n.\n\n\n[event] (context|object)\n: The context for the event or an object of properties to assign to the context for the event. Defaults to \n{}\n.\n\n\n[args] (...any)\n: Additional arguments to supply to the event handler.\n\n\n\n\nExamples\n\n\n// TODO\n\n\n\n\ncontext.readLink()\n\n\nSee ractive.readLink().\n\n\ncontext.resolve()\n\n\nResolves the given keypath to a full keypath. If a Ractive instance is supplied, the resolved path will also account for any mappings defined for the instance.\n\n\nSyntax\n\n\n\n\ncontext.resolve([keypath[, ractive]])\n\n\n\n\nArguments\n\n\n\n\n[keypath] (string)\n: The keypath to resolve.\n\n\n[ractive] (Ractive)\n: The instance to resolve the keypath against.\n\n\n\n\nReturns\n\n\n\n\n(string)\n: The resolved keypath.\n\n\n\n\nExamples\n\n\n// TODO\n\n\n\n\ncontext.reverse()\n\n\nSee ractive.reverse().\n\n\ncontext.set()\n\n\nSee ractive.set().\n\n\ncontext.setBinding()\n\n\nSets the binding of the node represented by this info object to the specified value.\n\n\nSyntax\n\n\n\n\ncontext.setBinding(value)\n\n\n\n\nArguments\n\n\n\n\nvalue (any)\n. The value to set.\n\n\n\n\nReturns\n\n\n\n\n(Promise)\n\n\n\n\nExamples\n\n\n// TODO\n\n\n\n\ncontext.shift()\n\n\nSee ractive.shift().\n\n\ncontext.splice()\n\n\nSee ractive.splice().\n\n\ncontext.sort()\n\n\nSee ractive.sort().\n\n\ncontext.subtract()\n\n\nSee ractive.subtract().\n\n\ncontext.toggle()\n\n\nSee ractive.toggle().\n\n\ncontext.unlink()\n\n\nSee ractive.unlink().\n\n\ncontext.unlisten()\n\n\nUnsubscribe an event listener that was subscribed with \nlisten\n. This is basically a \nremoveEventListener\n helper that is delegation-aware.\n\n\nSyntax\n\n\ncontext.unlisten( event, callback )\n\n\nArguments\n\n\n\n\nevent (string)\n: The name of the event to unsubscribe.\n\n\ncallback (function)\n: The callback that was previously subscribed.\n\n\n\n\ncontext.unshift()\n\n\nSee ractive.unshift().\n\n\ncontext.update()\n\n\nSee ractive.update().\n\n\ncontext.updateModel()\n\n\nSee ractive.updateModel().\n\n\nParse Object\n\n\nThe parse object is an object you receive as the second argument in function templates. This helper object provides you with essential functions to dissect markup before turning over the template for use.\n\n\np.fromId()\n\n\nRetrieves the template from the DOM \nscript\n tag specified by \nid\n. Make sure to set \ntype='text/ractive'\n on the \nscript\n tag to prevent the browser from running the template as a script.\n\n\nSyntax\n\n\n\n\np.fromId(id)\n\n\n\n\nArguments\n\n\n\n\nid (string)\n: The id of the \nscript\n tag containing the template. The leading \n#\n is optional.\n\n\n\n\nReturns\n\n\n\n\n(string)\n: The template inside the specified element.\n\n\n\n\nExamples\n\n\n// TODO\n\n\n\n\np.isParsed()\n\n\nTest whether the supplied template is already parsed and is in its object form.\n\n\nSyntax\n\n\n\n\np.isParsed(template)\n\n\n\n\nArguments\n\n\n\n\ntemplate (string|Object)\n: The template, either in its string form or object form.\n\n\n\n\nReturns\n\n\n\n\n(boolean)\n: Returns \ntrue\n if the template is already parsed, \nfalse\n if otherwise.\n\n\n\n\nExamples\n\n\n// TODO\n\n\n\n\np.parse()\n\n\nParses the template using Ractive.parse(). Full Ractive runtime must be loaded.\n\n\nSyntax\n\n\n\n\np.parse(template[, parseOptions])\n\n\n\n\nArguments\n\n\n\n\ntemplate (string|Object)\n: The template in its string form or object form.\n\n\nparseOptions] (Object)\n: Template parser options. See [Ractive.parse() for all available options. If \nparseOptions\n is not specified, it defaults to those of the current instance.\n\n\n\n\nReturns\n\n\n\n\n(Object)\n: The parsed template.\n\n\n\n\nExamples\n\n\n// TODO\n\n\n\n\nTransition Object\n\n\nThe transition object is an object you receive when writing transitions. It has a few properties and methods designed to make creating transitions easier.\n\n\nt.animateStyle()\n\n\nAnimates CSS properties to a certain value.\n\n\nSyntax\n\n\n\n\nt.animateStyle(prop, value, options[, complete])\n\n\nt.animateStyle(props, options[, complete])\n\n\n\n\nArguments\n\n\n\n\nprops (Object)\n: A map of animation properties and values.\n\n\nprop (string)\n: The style to animate.\n\n\nvalue (any)\n: The value to animate it to.\n\n\noptions (Object)\n: Animation options.\n\n\nduration (number)\n: The duration of the animation.\n\n\neasing (string)\n: The easing function of the animation.\n\n\ndelay (number)\n: The number of milliseconds before the animation starts.\n\n\n[complete] (Function)\n: A function that is executed when the animation completes, or immediately if no changes were made.\n\n\n\n\nReturns\n\n\n\n\n(Promise)\n: A promise that resolves when the animation completes.\n\n\n\n\nExamples\n\n\n// TODO\n\n\n\n\nt.complete()\n\n\nSignals Ractive that the transition is complete.\n\n\nSyntax\n\n\n\n\nt.complete[noReset])\n\n\n\n\nArguments\n\n\n\n\nnoReset] (boolean)\n: If \ntrue\n, [\nt.resetStyle()\n is not called. Defaults to \nfalse\n.\n\n\n\n\nReturns\n\n\n\n\n(undefined)\n\n\n\n\nExamples\n\n\n// TODO\n\n\n\n\nt.getStyle()\n\n\nRetrieve a CSS property value from \nt.node\n.\n\n\nSyntax\n\n\n\n\nt.getStyle(prop)\n\n\n\n\nArguments\n\n\n\n\nprop (string)\n: An unprefixed CSS property either in camelCase or kebab-case.\n\n\nprop (Array)\n: An array of CSS properties.\n\n\n\n\nReturns\n\n\n\n\n(string)\n: The value of the specified style property.\n\n\n(Object)\n: A key-value pair of properties and their respective values.\n\n\n\n\nExamples\n\n\n// TODO\n\n\n\n\nt.isIntro\n\n\n(boolean)\n\n\nShould be self-explanatory...\n\n\nt.name\n\n\n(string)\n\n\nThe name of the transition.\n\n\nt.node\n\n\n(Node)\n\n\nThe node that's entering or leaving the DOM\n\n\nt.processParams()\n\n\nBuilds a map of parameters whose values are taken from the provided arguments. When used with a single number or string argument, serves as a shorthand for creating a map with a \nduration\n property.\n\n\nSyntax\n\n\n\n\nt.processParams(params[, defaults])\n\n\n\n\nArguments\n\n\n\n\nparams (number)\n: Numeric shorthand for the \nduration\n parameter. Expressed in milliseconds.\n\n\nparams (string)\n: String shorthand for the \nduration\n parameter. Valid values are:\n\n\n\"fast\" - 200ms\n\n\n\"slow\" - 600ms\n\n\nAny other string - 400ms\n\n\n\n\n\n\nparams (Object)\n: A map of parameters and their values.\n\n\n[defaults] (Object)\n: A map of parameters and their default values.\n\n\n\n\nReturns\n\n\n\n\n(Object)\n: A map of parameters and their values.\n\n\n\n\nExamples\n\n\n// TODO\n\n\n\n\nt.setStyle()\n\n\nSets a CSS property on \nt.node\n to a value.\n\n\nSyntax\n\n\n\n\nt.setStyle(prop, value)\n\n\nt.setStyle(props)\n\n\n\n\nArguments\n\n\n\n\nprop (string)\n: An unprefixed CSS property either in camelCase or kebab-case.\n\n\nprops (Object)\n: A key-value pair of CSS properties and their respective values.\n\n\nvalue (string)\n: A valid value for the specified CSS property.\n\n\n\n\nReturns\n\n\n\n\n(undefined)\n\n\n\n\nExamples\n\n\n// TODO\n\n\n\n\nComponent files\n\n\nRemember the good old days? When all CSS went in \nstyle\n elements in \nhead\n? When all JS went in \nscript\n elements just before \n/body\n? When all HTML was written in Mustache inside inert \nscript\n elements? When it felt good when everything just worked after a page refresh? Ractive remembers, and it's bringing those good times back with component files.\n\n\nRactive component files are simply self-contained HTML files that define a component and contains all the markup, data, styles and logic it needs. It's also designed with dependency management in mind, allowing it to declare library and component dependencies. Best of all, component files are written in the same way regardless of the development process involved, build step or none.\n\n\nExample component file\n\n\n!-- Example component file --\n\n\n\n!-- Import a component named Foo from the file foo.html. --\n\n\nlink rel='ractive' href='foo.html' name='foo'\n\n\n\n!-- Define the markup for this component. --\n\n\nh1\n{{ title }}\n/h1\n\n\n\n!-- Use imported foo component --\n\n\np\nThis is an imported 'foo' component: \nfoo/\n/p\n\n\n\n!-- Define the styles for this component. --\n\n\nstyle\n\n  p { color: red; }\n\n/style\n\n\n\n!-- Define the behavior for this component. --\n\n\nscript\n\nconst $ = require( 'jquery' )\n\ncomponent.exports = {\n  onrender () {\n    $('\np /\n').text('component rendered').insertAfter($this.find('p'))\n  },\n  data: {\n    title: 'Hello World!'\n  }\n}\n\n/script\n\n\n\n\n\nThe above component file roughly translates to the following in vanilla JS:\n\n\nimport Ractive from 'ractive'\nimport $ from 'jquery'\nimport foo from './foo.html'\n\nexport default Ractive.extend({\n  components: { foo },\n  onrender () {\n    $('\np /\n').text('component rendered').insertAfter($this.find('p'))\n  },\n  data: {\n    title: 'Hello World!'\n  },\n  template: `\n    \nh1\n{{ title }}\n/h1\n\n    \np\nThis is an imported 'foo' component: \nfoo/\n/p\n\n  `,\n  css: `\n    p { color: red; }\n  `\n})\n\n\n\n\nWriting\n\n\nlink rel=\"ractive\"\n\n\nTop-level \nlink rel=\"ractive\"\n elements define dependencies on other components. It accepts two attributes:\n\n\n\n\n\n\nhref\n - The path to the required component file. Paths that start with \n./\n or \n../\n are resolved relative to the importing component file. Otherwise, resolution is loader-specific.\n\n\n\n\n\n\nname\n (optional) - The registered name of the component. This corresponds to the key used in the \ncomponents\n initialization option. When not defined, the filename of the dependency will be used as the name.\n\n\n\n\n\n\nThe names and the loaded dependency will be assigned to the component's \ncomponents\n initialization option.\n\n\nstyle\n\n\nTop-level \nstyle\n elements define the styles for the component. If more than one \nstyle\n element is found on the component file, their contents are concatenated in the order of appearance of the \nstyle\n elements. Contents of these elements will be concatenated and assigned to the component's \ncss\n initialization option.\n\n\nscript\n\n\nA top-level \nscript\n defines the component's initialization. The script's scope has a \ncomponent\n object that is similar to Node's \nmodule\n object. Initialization options for the component is expected via \ncomponent.exports\n. It also has a special \nrequire\n function that fetches script dependencies. \nrequire\n's behavior depends on the loader used. Refer to the specific loader's documentation to know more.\n\n\nThere can only ever be one \nscript\n in a component file. Defining more than one will result in the loader throwing an error.\n\n\nTemplate\n\n\nAfter yanking out top-level \nlink rel=\"ractive\"\n, \nstyle\n or \nscript\n from the component file, anything that's left becomes a part of the template. The remaining markup will be assigned to the component's \ntemplate\n initialization option.\n\n\nUsing\n\n\nIn order to use component files, you will have to use \nloaders\n, Head over to \nthe loaders page\n to learn more about loaders and help you choose a loader that suits your needs.", 
            "title": "API"
        }, 
        {
            "location": "/legacy/0.9/api/#mustaches", 
            "text": "", 
            "title": "Mustaches"
        }, 
        {
            "location": "/legacy/0.9/api/#variables", 
            "text": "{{ }} ,  {{  }}  and  {{{ }}}  render a reference. They are also used for binding when used on directives.  {{ }}  escapes the reference while  {{  }}  and  {{{ }}}  do not.  Ractive({\n  data: {\n    name:  Chris ,\n    company:  b GitHub /b \n  },\n  template: `\n    {{name}}       !-- Chris -- \n    {{age}}        !--  -- \n    {{company}}    !--  lt;b gt;GitHub lt;/b gt; -- \n    {{ company}}   !--  b GitHub /b  -- \n    {{{company}}}  !--  b GitHub /b  -- \n  `\n})", 
            "title": "Variables"
        }, 
        {
            "location": "/legacy/0.9/api/#sections", 
            "text": "Sections render a block of markup depending on the value referenced.  If the reference is an array, it renders the block of markup for each item in the array. The context of the section is the value of the currently iterated item. The iteration index is made available by adding a  :  after the array reference followed by the index reference.  Ractive({\n  data: {\n    people: [{name: 'Alice'},{name: 'Bob'},{name: 'Eve'}]\n  },\n  template: `\n    {{#people}} {{name}} {{/people}}\n    {{#people:i}} {{i}} {{name}} {{/people}}\n  `\n})  If the reference is an object  and the key reference is provided , the section iterates through the object properties. The context of the section is the value of the currently iterated property. The iteration key is made available by adding a  :  after the object reference followed by the key reference.  Ractive({\n  data: {\n    places: { loc1: 'server room', loc2: 'networking lab', loc3: 'pantry'}\n  },\n  template: `\n    {{#places:key}}\n      {{ key }} {{ this }}\n    {{/places}}\n  `\n})  If the reference is some other truthy value or an object but not providing the iteration key reference, it renders the block of markup using the reference as context.  Ractive({\n  data: {\n    isAdmin: true,\n    foo: {\n      bar: {\n        baz: {\n          qux: 'Hello, World!'\n        }\n      }\n    }\n  },\n  template: `\n    {{#isAdmin}} Hello Admin! {{/isAdmin}}\n\n    {{#foo.bar.baz}} {{qux}} {{/foo.bar.baz}}\n  `\n})", 
            "title": "Sections"
        }, 
        {
            "location": "/legacy/0.9/api/#inverted-sections", 
            "text": "{{^ }}  renders a block of markup if the reference is falsy or is an empty iterable.  Ractive({\n  data: {\n    real: false,\n    people: []\n  },\n  template: `\n    {{^real}} Nope, not real {{/real}}\n\n    {{^people}} There's no people {{/people}}\n  `\n})", 
            "title": "Inverted Sections"
        }, 
        {
            "location": "/legacy/0.9/api/#optional-section-closing-text", 
            "text": "Regular ( {{# }} ) and inverted ( {{^ }} ) sections can be closed with optional closing text. If the closing text is provided and the section is opened with a reference, the closing text must match the opening text. Otherwise, a warning will be issued for the mismatch. If the section is opened with an expression, the closing text will always be ignored.  Ractive({\n  data: {\n    items: [1,2,3]\n  },\n  template: `\n    {{#items}}\n      {{this}}\n    {{/items}}\n\n    {{#items}}\n      {{this}}\n    {{/}}\n\n    {{# a.concat(b) }}\n      {{this}}\n    {{/ I'm actually ignored but should be something meaningful like a.concat(b) }}\n  `\n})", 
            "title": "Optional section closing text"
        }, 
        {
            "location": "/legacy/0.9/api/#if-sections", 
            "text": "{{#if }}  renders a block of markup if the reference is truthy or a non-empty iterable.  {{else}}  and  {{elseif}}  are supported and render if the previous condition failed.  Ractive({\n  data: {\n    foo: false,\n    bar: false\n  },\n  template: `\n    {{#if foo}}\n      foo\n    {{elseif bar}}\n      bar\n    {{else}}\n      baz\n    {{/if}}\n  `\n})", 
            "title": "If sections"
        }, 
        {
            "location": "/legacy/0.9/api/#unless-sections", 
            "text": "{{#unless }}  renders a block of markup if the reference is falsy or is an empty iterable. Unlike  {{#if }} , the  {{#unless }}  section does not support  {{else}}  nor  {{elseif}} .  Ractive({\n  data: {\n    real: false,\n  },\n  template: `\n    {{#unless real}} Fake {{/unless}}\n  `\n})", 
            "title": "Unless sections"
        }, 
        {
            "location": "/legacy/0.9/api/#each-sections", 
            "text": "{{#each }}  renders the block of markup for each item in the iterable. The context of the section is the value of the currently iterated item.  {{else}}  and  {{elseif}}  are supported and render if the iterable is empty.  Ractive({\n  data: {\n    people: [{name: 'Alice'},{name: 'Bob'},{name: 'Eve'}]\n  },\n  template: `\n    {{#each people}}\n      Hi! I'm {{name}}!\n    {{else}}\n      There's nobody here\n    {{/each}}\n  `\n})", 
            "title": "Each sections"
        }, 
        {
            "location": "/legacy/0.9/api/#with-sections", 
            "text": "{{#with }}  alters the current section's context by sticking a reference in front of the resolution order. This causes everything within the section to resolve to that reference's context and data hierarchy first before the original section's.  Ractive({\n  el: 'body',\n  append: true,\n  data: {\n    foo: {\n      qux: 2,\n      bar: {\n        baz: 1\n      }\n    },\n    fee: {\n      baz: 'a'\n    }\n  },\n  template: `\n     !-- context becomes foo -- \n    {{#foo}}\n\n       !-- context becomes foo.bar -- \n      {{#bar}}\n\n         !-- resolution order: [foo.bar.baz], foo.baz, baz -- \n        {{baz}}\n\n         !-- resolution order: foo.bar.qux, [foo.qux], baz -- \n        {{qux}}\n\n         !-- sticks fee in front of foo.bar on the resolution order -- \n        {{#with ~/fee}}\n\n           !-- resolution order: [fee.baz], foo.bar.baz, foo.baz, baz -- \n          {{baz}}\n\n           !-- resolution order: fee.qux, foo.bar.qux, [foo.qux], qux -- \n          {{qux}}\n        {{/with}}\n\n      {{/}}\n    {{/}}\n  `\n})  {{else}}  and  {{elseif}}  are supported and render when the context reference does not exist.  Ractive({\n  data: {},\n  template: `\n    {{#with people}}\n      {{joe}}\n    {{/else}}\n      Context missing\n    {{/with}}\n  `\n})  {{#with }}  also allows aliasing of references, including special references. Aliasing is in the form of  reference as alias  pairs. Multiple alias pairs can be done by separating each with a comma. In this mode, the context within the block is not altered.  Ractive({\n  el: 'body',\n  append: true,\n  data: {\n    foo: 1,\n    bar: {\n      foo: 2,\n      baz: 3\n    }\n  },\n  template: `\n    {{foo}}  !-- 1 -- \n\n    {{#with foo as qux, @global as world}}\n      {{#bar}}\n        {{qux}}  !-- 1 -- \n        {{foo}}  !-- 2 -- \n        {{baz}}  !-- 3 -- \n      {{/}}\n    {{/with}}\n  `\n})", 
            "title": "With sections"
        }, 
        {
            "location": "/legacy/0.9/api/#in-template-partials", 
            "text": "{{#partial }}  defines a partial that is scoped to the nearest enclosing element or the containing component if defined at the top level of the template.  Ractive({\n  data: {\n    people: [{name: 'Alice'},{name: 'Bob'},{name: 'Eve'}],\n    places: [{name: 'server room'},{name: 'networking lab'},{name: 'pantry'}]\n  },\n  template: `\n    {{#partial item}}\n       li class= item {{this}}! /li \n    {{/partial}}\n\n     ul \n      {{#each people}}\n        {{  item }}\n      {{/each}}\n     /ul \n\n     ul \n      {{#each places}}\n        {{  item }}\n      {{/each}}\n     /ul \n\n     div \n      {{#partial scopedPartial}}\n         li class= item {{this}}! /li \n      {{/partial}}\n\n       ul \n        {{#each things}}\n          {{  scopedPartial }}\n        {{/each}}\n       /ul \n     /div \n  `\n})", 
            "title": "In-template partials"
        }, 
        {
            "location": "/legacy/0.9/api/#static-mustaches", 
            "text": "[[ ]] ,  [[  ]]  and  [[[ ]]]  render the reference only during the initial render. After the initial render, any changes to the referece will not update the UI, nor does any change on bound UI elements cause the reference to change. They are the one-time render counterparts of  {{ }} ,  {{  }}  and  {{{ }}} , respectively.  const instance = Ractive({\n  data: {\n    msg: 'Hello, World!',\n    admin: false\n  },\n  template: `\n    Will change when updated: {{ msg }}      !-- changes to  Me, Hungry!  after the change -- \n    Will not change when updated: [[ msg ]]  !-- remains  Hello, World!  after the change -- \n\n    [[# if admin ]]\n      Hello, admin\n    [[else]]\n      Hello, normal user\n    [[/if]]\n  `\n})\n\ninstance.set({ msg: 'Me, Hungry!' })\ninstance.set('admin', true) // rendering remains 'Hello, normal user'", 
            "title": "Static mustaches"
        }, 
        {
            "location": "/legacy/0.9/api/#expressions", 
            "text": "Expressions in mustaches are evaluated, and its result is used as the referenced value. Any changes to the expression's dependencies will re-evaluate the expression and update the rendered value. References to variables are taken from the current context and follow the regular reference resolution routine.  Ractive({\n  data: {\n    num1: 2,\n    num2: 3,\n    a: [1,2,3],\n    b: [4,5,6],\n    fn: () =  true\n  },\n  template: `\n    {{ num1 + num2 }}\n\n    {{# a.concat(b) }} {{this}} {{/}}\n    {{#each a.concat(b) }} {{this}} {{/each}}\n\n    {{# fn() }} Yasss!!! {{/}}\n    {{#if fn() }} Yasss!!! {{/if}}\n  `\n})  Almost any valid JavaScript expression can be used, with a few exceptions:   No assignment operators (i.e.  a = b ,  a += 1 ,  a--  and so on).  No  new ,  delete , or  void  operators.  No function literals (i.e. anything that involves the  function  keyword).   Expressions support only a subset of globals:   Array  Date  JSON  Math  NaN  RegExp  decodeURI  decodeURIComponent  encodeURI  encodeURIComponent  isFinite  isNaN  null  parseFloat  parseInt  undefined", 
            "title": "Expressions"
        }, 
        {
            "location": "/legacy/0.9/api/#comments", 
            "text": "{{! }}  defines a template comment. Comments are ignored by the parser and never make it to the AST.  Ractive({\n  template: `\n     h1 Today{{! ignore me }}. /h1 \n  `\n})  Note:   {{!foo}}  is also a valid expression, and expressions have a higher precedence in the parser than comments. To ensure that your comments are always treated as such, you can add a  #  after the  !  e.g.  {{!# comment }}  because  #  is never valid in an expression.", 
            "title": "Comments"
        }, 
        {
            "location": "/legacy/0.9/api/#custom-delimiters", 
            "text": "{{= =}}  defines custom delimiters. Custom delimiters should not contain whitespace or the equals sign.  Ractive({\n  data: {\n    msg: 'Hello, World!'\n  },\n  template: `\n    {{ msg }}\n\n    {{= % % =}}\n     % msg % \n  `\n})", 
            "title": "Custom delimiters"
        }, 
        {
            "location": "/legacy/0.9/api/#escaping-mustaches", 
            "text": "\\  prepended on a mustache interprets the mustache as literal text.  {{ ref }} \\{{ ref }}  !-- value {{ ref }} --   For multi-mustache structures,  \\  must be prepended on all involved mustaches.  \\{{#if foo }} \\{{ bar }} \\{{/if}}  !-- {{#if foo }} {{ bar }} {{/if}} --   To interpret a  \\  as a literal slash before a mustache, simply prepend another  \\ . Any further  \\  prepended will be treated in this manner.  Ractive({\n  data: {\n    msg: 'Hello, World!'\n  },\n  template: `\n    \\\\{{ msg }}    !-- \\Hello, World! -- \n    \\\\\\{{ msg }}   !-- \\\\Hello, World! -- \n    \\\\\\\\{{ msg }}  !-- \\\\\\Hello, World! -- \n  `\n})", 
            "title": "Escaping mustaches"
        }, 
        {
            "location": "/legacy/0.9/api/#anchors", 
            "text": "# /  define anchors which are mounting points where instances can be mounted to dynamically during runtime.  Examples  Example 1   const MyComponent = Ractive.extend({\n  template: `\n     div {{ message }} /div \n  `\n})\n\nRactive({\n  target: 'body',\n  data: {\n    msg: 'Hello, World!'\n  },\n  template: `\n     # mountpoint7 / \n  `,\n  oninit () {\n    // Create new instance\n    const myComponent = MyComponent()\n\n    // Link msg of parent to message of instance\n    myComponent.link('msg', 'message', { ractive: this })\n\n    // It's mount'in time!\n    this.attachChild(myComponent, { target: 'mountpoint7'})\n  }\n})  Example 2 : Attaching, detaching, firing events, creating two-way bindings within the template   MyComponent = Ractive.extend({\n    template: ...\n})\n\nRactive({\n    ...\n    template: `\n         button on-click= move move it /button \n         # mountpoint-one on-click= hello  message= {{msg}}  / \n         # mountpoint-two on-click= hello  message= {{ msg + ' + ' + msg }}  / \n         input value= {{msg}}  / \n    `,\n    onrender () {\n        // Create new instance\n        myInstance = MyComponent()\n        this.attachChild(myInstance, { target: 'mountpoint-one'})\n        this.on({\n            move () {\n                this.detachChild(myInstance)\n                this.attachChild(myInstance, { target: 'mountpoint-two'})\n            },\n            hello(ctx) {\n                // fire an event as you would do with a regular component\n            }\n        })\n    }\n})", 
            "title": "Anchors"
        }, 
        {
            "location": "/legacy/0.9/api/#content", 
            "text": "{{ content}}  renders the inner HTML in the context of the component. Partials, components, and any other valid template items can be used as inner HTML.  Ractive.components.ChildComponent = Ractive.extend({\n  template: `\n     div class= child-component {{ content}} /div \n  `\n})\n\nconst ractive = Ractive({\n  el: 'body',\n  data: {\n    message: 'Hello World!'\n  },\n  template: `\n     div class= ractive \n       ChildComponent message= Lorem Ipsum \n         !-- Prints  Lorem Ipsum  -- \n         div class= inner-content {{ message }} /div \n       /ChildComponent \n     /div \n  `\n})  Partials defined in the inner HTML can be used to override partials defined on the component.  Ractive.components.ChildComponent = Ractive.extend({\n  partials: {\n    messageWrapper: ' strong {{message}} /strong '\n  },\n  template: `\n     div class= child-component {{ content}} /div \n  `\n})\n\nconst ractive = Ractive({\n  el: 'body',\n  data: {\n    message: 'Hello World!'\n  },\n  template: `\n     div class= ractive \n       ChildComponent message= Lorem Ipsum \n\n         !-- Override component's messageWrapper -- \n        {{#partial messageWrapper}} em {{message}} /em {{/}}\n\n         div class= inner-content \n           !-- Renders emphasized instead of strong -- \n          {{  messageWrapper }}\n         /div \n\n       /ChildComponent \n     /div \n  `\n})", 
            "title": "{{&gt;content}}"
        }, 
        {
            "location": "/legacy/0.9/api/#yield", 
            "text": "{{yield}}  renders the inner HTML in the context of the parent component. Partials, components, and any other valid template items can be used as inner HTML.  Ractive.components.ChildComponent = Ractive.extend({\n  template: `\n     div class= child-component {{ yield }} /div \n  `\n})\n\nconst ractive = Ractive({\n  el: 'body',\n  data: {\n    message: 'Hello, World!'\n  },\n  template: `\n     div class= ractive \n       ChildComponent message= Lorem Ipsum \n         !-- Prints  Hello, World!  -- \n         div class= inner-content {{ message }} /div \n       /ChildComponent \n     /div \n  `\n})  Yields can also be customized using named yields. A named yield will look for a partial of the same name in the inner HTML and render that partial instead.  Ractive.components.ChildComponent = Ractive.extend({\n  template: `\n     div class= child-component \n      {{ yield }}\n      {{ yield italicYield }}\n      {{ yield boldYield }}\n     /div \n  `\n})\n\nconst ractive = Ractive({\n  el: 'body',\n  data: {\n    message: 'Hello World!'\n  },\n  template: `\n     div class= ractive \n       ChildComponent message= Lorem Ipsum \n\n         !-- Printed by {{ yield italicYield }} -- \n        {{#partial italicYield }} em {{message}} /em {{/}}\n\n         !-- Printed by {{ yield boldYield }} -- \n        {{#partial boldYield }} strong {{message}} /strong {{/}}\n\n         !-- Anything not a partial is printed by {{ yield }} -- \n        {{message}}\n       /ChildComponent \n     /div \n  `\n})  Since the yielded content exists entirely in the context of the container (as opposed to the component), there's no way for the yielded content to access data in the component that is yielding. To address that, yields may supply aliases that are made available to the yielded content:  const list = Ractive.extend({\n  template: `\n     ul \n      {{#each items}}\n         !-- Expose item and index to yield context. -- \n         li {{yield with . as item, @index as index}} /li \n      {{/each}}\n     /ul \n  `\n})\n\nconst ractive = Ractive({\n  el: 'body',\n  data: {\n    some: {\n      list: [ 1, 2, 3 ]\n    }\n  },\n  select(i) { console.log('you picked', i); },\n  template: `\n     !-- Pass in some.list as items into list. -- \n     list items= {{some.list}} \n\n       !-- Access item and index aliases. -- \n       a href= #  on-click= @.select(item) Item {{index}} /a \n     /list \n  `,\n  components: { list }\n})  Without the given alises, iterating a list within the component to yield the content would be useless, because the content would not have access to the current iteration. You could get around that by using a normal partial rather than a yield, but at that point, the click event on the content would result in an error because the  select  method does not exist on the  list  component.  Yield aliases are also available for named yields.  const Pager = Ractive.extend({\n  template: `\n     ul \n       li {{ yield prev }} /li \n      {{#each pages}}\n         li {{yield link with . as page}} /li \n      {{/each}}\n       li {{ yield next }} /li \n     /ul \n  `\n})\n\nconst ractive = Ractive({\n  components: { Pager },\n  el: 'body',\n  data: {\n    book: {\n      pages: [ 1, 2, 3 ]\n    }\n  },\n  template: `\n     Pager pages= {{ book.pages }} \n      {{#partial prev}} a href= #prev Prev /a {{/partial}}\n      {{#partial link}} a href= #{{ page }} {{ page }} /a {{/partial}}\n      {{#partial next}} a href= #next Next /a {{/partial}}\n     /Pager \n  `,\n})", 
            "title": "{{yield}}"
        }, 
        {
            "location": "/legacy/0.9/api/#data-binding", 
            "text": "", 
            "title": "Data binding"
        }, 
        {
            "location": "/legacy/0.9/api/#text-inputs", 
            "text": "Data can be bound to text inputs via the  value  directive. This includes text-like inputs such as password, email, color, tel, date, etc.  Ractive({\n  template: `\n     input type= text  value= {{ msg }} \n  `,\n  data: {\n    msg: 'Hello, World!'\n  }\n})", 
            "title": "Text inputs"
        }, 
        {
            "location": "/legacy/0.9/api/#number-inputs", 
            "text": "Numeric data can be bound to number inputs via the  value  directive. This includes number-like inputs such as range. The value from the input will automatically be converted into a number. When the input is blank, the value returned is  undefined .  Ractive({\n  template: `\n     input type= number  value= {{ daysWithoutSleep }} \n  `,\n  data: {\n    daysWithoutSleep: 2\n  }\n})", 
            "title": "Number inputs"
        }, 
        {
            "location": "/legacy/0.9/api/#file-inputs", 
            "text": "File data can be bound to file inputs via the  value  directive. The value from the input is an instance of  FileList .  Ractive({\n  template: `\n     input type= file  value= {{ file }} \n  `,\n  data: {\n    file: /* FileList instance */\n  }\n})  or by using events:   Ractive({\n  ...\n  template: `\n    {{#each foo}}\n     p \n      {{.}} :  input on-change= hello  type= file  / \n     /p \n    {{/each}}\n  `,\n  on:{\n    hello (ctx) {\n      files = ctx.node.files\n      keypath = ctx.resolve()\n      console.log('selected files:', files)\n      console.log('first file:', files[0])\n      console.log('current context: ', keypath)\n    }\n  },\n  data:{\n    foo: [1, 2, 3]\n  }\n})", 
            "title": "File inputs"
        }, 
        {
            "location": "/legacy/0.9/api/#checkboxes", 
            "text": "Boolean data can be bound to checkboxes via the  checked  directive.  Ractive({\n  template: `\n     input type= checkbox  checked= {{ isChecked }} \n  `,\n  data: {\n    isChecked: true\n  }\n})  Array data can also be bound to checkboxes via the  name  directive.  Ractive({\n  template: `\n     input type= checkbox  name= {{ selectedItems }}  value= 1 \n     input type= checkbox  name= {{ selectedItems }}  value= 2 \n     input type= checkbox  name= {{ selectedItems }}  value= 3 \n  `,\n  data: {\n    selectedItems: ['1', '2']\n  }\n})  When both  checked  and  name  bindings are present, the binding to  checked  will be honored and the binding to  name  will be treated as a regular interpolation.", 
            "title": "Checkboxes"
        }, 
        {
            "location": "/legacy/0.9/api/#radio-buttons", 
            "text": "Boolean data can be bound to radio buttons via the  checked  directive.  Ractive({\n  template: `\n     input type= radio  name= options  checked= {{ option1 }} \n     input type= radio  name= options  checked= {{ option2 }} \n     input type= radio  name= options  checked= {{ option3 }} \n  `,\n  data: {\n    option1: false,\n    option2: true,\n    option3: false\n  }\n})  Data can also be bound to radio buttons via the  name  directive.  Ractive({\n  template: `\n     input type= radio  name= {{ selectedOption }}  value= 1 \n     input type= radio  name= {{ selectedOption }}  value= 2 \n     input type= radio  name= {{ selectedOption }}  value= 3 \n  `,\n  data: {\n    selectedOption: '1'\n  }\n})", 
            "title": "Radio buttons"
        }, 
        {
            "location": "/legacy/0.9/api/#text-areas", 
            "text": "Data can be bound to text areas via the  value  directive.  Ractive({\n  template: `\n     textarea value= {{ msg }} /textarea \n  `,\n  data: {\n    msg: 'Hello, World!'\n  }\n})  Data can also be bound to text areas via its contents.  Ractive({\n  template: `\n     textarea {{ msg }} /textarea \n  `,\n  data: {\n    msg: 'Hello, World!'\n  }\n})", 
            "title": "Text areas"
        }, 
        {
            "location": "/legacy/0.9/api/#select-lists", 
            "text": "Data can be bound to select lists via the  value  directive.  Ractive({\n  template: `\n     select value= {{ selectedOption }} \n       option value= 1 Red /option \n       option value= 2 Green /option \n       option value= 3 Blue /option \n     /select \n  `,\n  data: {\n    selectedOption: '2'\n  }\n})  Array data can also be bound to select lists with the  multiple  attribute via the  value  directive.  Ractive({\n  template: `\n     select multiple value= {{ selectedItems }} \n       option value= 1 Red /option \n       option value= 2 Green /option \n       option value= 3 Blue /option \n     /select \n  `,\n  data: {\n    selectedItems: [ '2', '3' ]\n  }\n})", 
            "title": "Select lists"
        }, 
        {
            "location": "/legacy/0.9/api/#contenteditable", 
            "text": "Data can be bound to elements that have the  contenteditable  attribute via the  value  directive.  Ractive({\n  template: `\n     div contenteditable= true  value= {{ msg }} /div \n  `,\n  data: {\n    msg: 'Hello, World!'\n  }\n})\n\n// Rendered as:\n//  div contenteditable= true Hello, World! /div   There are a few caveats when binding to an element with  contenteditable :   The returned string may or may not always be HTML.  The returned string may be different from browser to browser.  Any value set on the bound data will always be rendered as HTML.", 
            "title": "contenteditable"
        }, 
        {
            "location": "/legacy/0.9/api/#directives", 
            "text": "", 
            "title": "Directives"
        }, 
        {
            "location": "/legacy/0.9/api/#twoway", 
            "text": "The element-specific directive form of the  twoway  initialization option.  !-- By default, two-way is enabled. Editing the input updates foo. -- \nTwo-way:  input type= text  value= {{ foo }}  {{ foo }} !-- With twoway= false , editing the input will not update bar. -- \nOne-way:  input type= text  value= {{ bar }}  twoway= false  {{ bar }} !-- Updating bar via the data will update the UI --  button type= button  on-click= @this.set('bar', 'baz') Set value to bar /button", 
            "title": "twoway"
        }, 
        {
            "location": "/legacy/0.9/api/#lazy", 
            "text": "The element-specific directive form of the  lazy  initialization option.  !-- Editing the input updates foo on keypress. -- \nEager:  input type= text  value= {{ foo }}  {{ foo }} !-- Editing the input updates bar only when focus moves away from the input. -- \nLazy:  input type= text  value= {{ bar }}  lazy= true  {{ bar }} !-- Editing the input updates bar only five seconds after the change. -- \nLazy:  input type= text  value= {{ bar }}  lazy= 5000  {{ bar }}", 
            "title": "lazy"
        }, 
        {
            "location": "/legacy/0.9/api/#as-42", 
            "text": "as-*  directives augment the element with decorators. It accepts optional, comma-separated expressions as arguments to the decorator function.  div as-modal Div appearing as modal /div  div as-modal= true, true, true, false Div appearing as modal /div", 
            "title": "as-*"
        }, 
        {
            "location": "/legacy/0.9/api/#class-42", 
            "text": "class-*  directives toggle individual class names based on the truthiness of its value. The part of the directive name following  class-  will be used as the class name.  class-*  directive values are processed as expressions. If there is no expression, the implicit value is  true , which is useful for applying multiple classes to an element using component  extra-attributes .  div class-foo= isFoo Adds  foo  if isFoo is truthy /div  div class-foo-bar= isFooBar Adds  foo-bar  if isFooBar is truthy /div  div class-fooBar= isFooBar Adds  fooBar  if isFooBar is truthy /div  div class-baz Always has  baz /div", 
            "title": "class-*"
        }, 
        {
            "location": "/legacy/0.9/api/#on-42", 
            "text": "on-*  directives attach event handlers to DOM elements and components.  on-*  can be used in two ways: proxy syntax or the expression syntax.  Ractive({\n  template: `\n     button type= button  on-click= clickedproxy Push me! /button \n     button type= button  on-click= ['clickedArray', 'Hello, World!'] Push me! /button \n     button type= button  on-click= @this.clickedMethod('Hello, World!') Push me! /button \n  `,\n  on: {\n    clickedproxy (context) {\n      console.log('Hello, World!')\n    },\n    clickedArray (context, msg) {\n      console.log(msg)\n    }\n  },\n  clickedMethod(msg) {\n    console.log(msg)\n  }\n})  Multiple events can also be tied to the same handler by appending event names to the directive, separating them by hyphens:  Ractive({\n  template: `\n     button type= button  on-hover-click= @this.someMethod() Push me! /button \n  `,\n  someMethod () {\n    console.log('Fires on hover and on click!')\n  }\n})", 
            "title": "on-*"
        }, 
        {
            "location": "/legacy/0.9/api/#42-in-42-out-42-in-out", 
            "text": "*-in ,  *-out , and  *-in-out  directives apply transitions to the element.  *-in  specifies intro-only,  *-out  specifies outro-only, and  *-in-out  for both intro and outro. All three directives accept optional, comma-separated expressions as arguments to the transition function.  div fade-in Fades on render /div  div fade-out Fades before removal /div  div fade-in-out Fades on render and before removal /div  div fade-in-out= { duration: 500 }, someOtherArg Fades with 500ms duration /div", 
            "title": "*-in, *-out, *-in-out"
        }, 
        {
            "location": "/legacy/0.9/api/#style-42", 
            "text": "style-*  directives update individual  style  properties of the element. The part of the directive following  style-  will be used as the style property name. Style names can either be in kebab case or camel case, and will be normalized on application.  div style-vertical-align= middle Applies style.verticalAlign /div  div style-textAlign= center Applies style.textAlign /div   style-*  directive values are processed as strings. Mustaches can also be used to supply the values. When the values are updated, the appropriate style property on the element will update to the new value.  div style-vertical-align= {{ vAlign }}  style-textAlign= {{ tAlign }} ... /div", 
            "title": "style-*"
        }, 
        {
            "location": "/legacy/0.9/api/#keypath-prefixes", 
            "text": "Normally, keypaths are resolved following a defined routine. But there are times where you want to skip the normal resolution routine and resolve a keypath relative to a specific data context. Keypath prefixes allow you to specify which data context a keypath resolves to, regardless if it resolves to something or not.", 
            "title": "Keypath prefixes"
        }, 
        {
            "location": "/legacy/0.9/api/#current-context", 
            "text": "Resolves the keypath relative to the current data context.   Ractive({\n  target: 'body',\n  data: {\n    spoon: 'SPOON',\n    matrix: {\n      agent: 'Smith'\n      // There is no spoon\n    }\n  },\n  template: `\n     div Outside the matrix, you have {{ spoon }} /div \n    {{# matrix }}\n       div Inside the matrix, you think you have {{ spoon }}. /div \n       div In reality, there is no {{ ./spoon }} /div \n    {{/}}\n  `\n})\n\n// Outside the matrix, you have SPOON\n// Inside the matrix, you think you have SPOON.\n// In reality, there is no", 
            "title": "Current context"
        }, 
        {
            "location": "/legacy/0.9/api/#parent-keypath", 
            "text": "Resolves the keypath relative to the parent data. This prefix can be used more than once to reference ancestors.   Ractive({\n  target: 'body',\n  data: {\n    id: 'reality',\n    dream: {\n      id: 'dream1',\n      dream: {\n        id: 'dream2',\n        dream: {\n          id: 'dream3',\n        }\n      }\n    }\n  },\n  template: `\n     div You are in {{ id }} /div \n    {{# dream }}\n       div You are in {{ id }} /div \n      {{# dream }}\n         div You are in {{ id }} /div \n        {{# dream }}\n           div You are in {{ id }} /div \n\n           div Escaping... /div \n           div You are in {{ ../id }} /div \n           div You are in {{ ../../id }} /div \n           div You are in {{ ../../../id }} /div \n        {{/}}\n      {{/}}\n    {{/}}\n  `\n})\n\n// You are in reality\n// You are in dream1\n// You are in dream2\n// You are in dream3\n// Escaping...\n// You are in dream2\n// You are in dream1\n// You are in reality", 
            "title": "Parent keypath"
        }, 
        {
            "location": "/legacy/0.9/api/#parent-context", 
            "text": "While parent keypaths and parent contexts are often the same thing, there are some scenarios in which they are very, very different. For instance, in this horribly contrived example:   Ractive({\n  target: 'body',\n  data: {\n    homebase: {\n      building1: { name: 'Operations' }\n    },\n    bases: [\n      {\n        building1: { name: 'Mess Hall' }\n      },\n      {\n        building1: { name: 'Medical Tent' }\n      }\n    ]\n  },\n  template: `\n    {{#each bases}}\n      {{#with ~/homebase}}\n         div the home base bulding1 is {{.building1.name}} /div \n         div the current iteration base building1 is {{^^/.building1.name}} /div \n      {{/with}}\n    {{/each}}\n  `\n})\n\n// the home base bulding1 is Operations\n// the current iteration base building1 is Mess Hall\n// the home base bulding1 is Operations\n// the current iteration base building1 is Medical Tent", 
            "title": "Parent context"
        }, 
        {
            "location": "/legacy/0.9/api/#instance-root-context", 
            "text": "Resolves the keypath relative to the instance's root data context.   Ractive({\n  target: 'body',\n  data: {\n    room: '1',\n    portal: {\n      room: '2',\n      portal: {\n        room: '3',\n        portal: {\n          room: '4',\n        }\n      }\n    }\n  },\n  template: `\n    {{# portal }}\n      {{# portal }}\n        {{# portal }}\n           div Entering... /div \n           div You are in room {{ ~/room }} /div \n           div You are in room {{ ~/portal.room }} /div \n           div You are in room {{ ~/portal.portal.room }} /div \n           div You are in room {{ ~/portal.portal.portal.room }} /div \n        {{/}}\n      {{/}}\n    {{/}}\n  `\n})\n\n// Entering...\n// You are in room 1\n// You are in room 2\n// You are in room 3\n// You are in room 4", 
            "title": "Instance root context"
        }, 
        {
            "location": "/legacy/0.9/api/#special-references", 
            "text": "Special references are template keywords that act like data references but do not actually exist in your data. These references provide metadata regarding the current instance, context, environment, operation and more.", 
            "title": "Special references"
        }, 
        {
            "location": "/legacy/0.9/api/#this", 
            "text": "The current data context.   Ractive({\n  el: 'body',\n  data: {\n    info: {\n      message: 'Hello World!',\n      info: {\n        message: 'The quick brown fox',\n        info: {\n          message: 'jumps over the lazy dog',\n          info: {\n            message: 'Thats all folks'\n          }\n        }\n      }\n    }\n  },\n  template: `\n     div root: {{ JSON.stringify(this) }} /div \n    {{# info }}\n       div info 1: {{ JSON.stringify(this) }} /div \n      {{# info }}\n         div info 2: {{ JSON.stringify(this) }} /div \n        {{# info }}\n           div info 3: {{ JSON.stringify(this) }} /div \n          {{# info }}\n             div info 4: {{ JSON.stringify(this) }} /div \n          {{/}}\n        {{/}}\n      {{/}}\n    {{/}}\n  `,\n})\n\n// info 1: { info :{ message : Hello World! , info :{ message : The quick brown fox , info :{ message : jumps over the lazy dog , info :{ message : Thats all folks }}}}}\n// info 2: { message : Hello World! , info :{ message : The quick brown fox , info :{ message : jumps over the lazy dog , info :{ message : Thats all folks }}}}\n// info 3: { message : The quick brown fox , info :{ message : jumps over the lazy dog , info :{ message : Thats all folks }}}\n// info 4: { message : jumps over the lazy dog , info :{ message : Thats all folks }}\n// info 5: { message : Thats all folks }", 
            "title": "this"
        }, 
        {
            "location": "/legacy/0.9/api/#this_1", 
            "text": "The current Ractive instance.   Ractive({\n  el: 'body',\n  data: {\n    count: 1\n  },\n  template: `\n     div Count: {{ count }} /div \n     button type= button  on-click= @this.add('count') Increment /button \n     button type= button  on-click= @this.myMethod() Log count /button \n  `,\n  myMethod () {\n    console.log(`current count is ${this.get('count')}`)\n  }\n})  @this  can also be referenced by using its shorthand  @ .   Ractive({\n  el: 'body',\n  data: {\n    count: 1\n  },\n  template: `\n     div Count: {{ count }} /div \n     button type= button  on-click= @.add('count') Increment /button \n     button type= button  on-click= @.myMethod() Log count /button \n  `,\n  myMethod () {\n    console.log(`current count is ${this.get('count')}`)\n  }\n})", 
            "title": "@this"
        }, 
        {
            "location": "/legacy/0.9/api/#index", 
            "text": "The current iteration index of the containing repeated section.   Ractive({\n  el: 'body',\n  data: {\n    users: [\n      { name: 'bob' },\n      { name: 'alice' },\n      { name: 'eve' },\n    ]\n  },\n  template: `\n    {{#each users}}\n       div User #{{ @index }} says: Hi! I'm {{ name }}! /div \n    {{/each}}\n  `\n})\n\n// User #0 says: Hi! I'm bob!\n// User #1 says: Hi! I'm alice!\n// User #2 says: Hi! I'm eve!  For objects,  @index  is still the iteration index.   Ractive({\n  el: 'body',\n  data: {\n    users: {\n      bob: 'Hi! I am bob!',\n      alice: 'Hi! I am alice!',\n      eve: 'Hi! I am eve!'\n    }\n  },\n  template: `\n    {{#each users}}\n       div User #{{ @index }} says: {{ this }} /div \n    {{/each}}\n  `\n})\n\n// User #0 says: Hi! I am bob!\n// User #1 says: Hi! I am alice!\n// User #2 says: Hi! I am eve!", 
            "title": "@index"
        }, 
        {
            "location": "/legacy/0.9/api/#key", 
            "text": "The current key name of the containing object iteration section.   Ractive({\n  el: 'body',\n  data: {\n    users: {\n      bob: 'Hi! I am bob!',\n      alice: 'Hi! I am alice!',\n      eve: 'Hi! I am eve!'\n    }\n  },\n  template: `\n    {{#each users}}\n       div User {{ @key }} says: {{ this }} /div \n    {{/each}}\n  `\n})\n\n// User bob says: Hi! I am bob!\n// User alice says: Hi! I am alice!\n// User eve says: Hi! I am eve!  For arrays,  @key 's value will be the iteration index.   Ractive({\n  el: 'body',\n  data: {\n    users: [\n      { name: 'bob' },\n      { name: 'alice' },\n      { name: 'eve' },\n    ]\n  },\n  template: `\n    {{#each users}}\n       div User #{{ @key }} says: Hi! I'm {{ name }}! /div \n    {{/each}}\n  `\n})\n\n// User #0 says: Hi! I'm bob!\n// User #1 says: Hi! I'm alice!\n// User #2 says: Hi! I'm eve!", 
            "title": "@key"
        }, 
        {
            "location": "/legacy/0.9/api/#keypath", 
            "text": "The keypath to the current data context relative to the instance's root data context.   Ractive({\n  el: 'body',\n  data: {\n    foo: {\n      bar: {\n        baz: {\n          message: 'hello world'\n        }\n      }\n    }\n  },\n  template: `\n     div Keypath: {{ @keypath }} /div \n    {{# foo }}\n       div Keypath: {{ @keypath }} /div \n      {{# bar }}\n         div Keypath: {{ @keypath }} /div \n        {{# baz }}\n           div Keypath: {{ @keypath }} /div \n        {{/}}\n      {{/}}\n    {{/}}\n  `\n})\n\n// Keypath:\n// Keypath: foo\n// Keypath: foo.bar\n// Keypath: foo.bar.baz  If the keypath is a mapping, the keypath will remain relative to the instance.   Ractive.components.Message = Ractive.extend({\n  data: () =  ({\n    info : {},\n  }),\n  template: `\n    {{# info }}\n       div Sender: {{ name }} /div \n       div Message: {{ message }} /div \n       div Keypath: {{ @keypath }} /div \n    {{/}}\n  `\n})\n\nRactive({\n  el: 'body',\n  data: {\n    mail: {\n      inbox: {\n        messages: [{\n          name: 'bob',\n          message: 'Hi alice!'\n        },{\n          name: 'bob',\n          message: 'Hi eve!'\n        }]\n      }\n    }\n  },\n  template: `\n    {{# mail.inbox.messages }}\n       Message info= {{ this }}  / \n    {{/}}\n  `\n})\n\n// Sender: bob\n// Message: Hi alice!\n// Keypath: info\n// Sender: bob\n// Message: Hi eve!\n// Keypath: info", 
            "title": "@keypath"
        }, 
        {
            "location": "/legacy/0.9/api/#rootpath", 
            "text": "The keypath to the current data context relative to the originating instance's root data context.   Ractive({\n  el: 'body',\n  data: {\n    foo: {\n      bar: {\n        baz: {\n          message: 'hello world'\n        }\n      }\n    }\n  },\n  template: `\n     div Keypath: {{ @rootpath }} /div \n    {{# foo }}\n       div Keypath: {{ @rootpath }} /div \n      {{# bar }}\n         div Keypath: {{ @rootpath }} /div \n        {{# baz }}\n           div Keypath: {{ @rootpath }} /div \n        {{/}}\n      {{/}}\n    {{/}}\n  `\n})\n\n// Keypath:\n// Keypath: foo\n// Keypath: foo.bar\n// Keypath: foo.bar.baz  If the keypath is a mapping, it will be adjusted relative to the originating instance's root data context. This is what primarily sets  @rootpath  apart from  @keypath .   Ractive.components.Message = Ractive.extend({\n  data: () =  ({\n    info : {},\n  }),\n  template: `\n    {{# info }}\n       div Sender: {{ name }} /div \n       div Message: {{ message }} /div \n       div Keypath: {{ @rootpath }} /div \n    {{/}}\n  `\n})\n\nRactive({\n  el: 'body',\n  data: {\n    mail: {\n      inbox: {\n        messages: [{\n          name: 'bob',\n          message: 'Hi alice!'\n        },{\n          name: 'bob',\n          message: 'Hi eve!'\n        }]\n      }\n    }\n  },\n  template: `\n    {{# mail.inbox.messages }}\n       Message info= {{ this }}  / \n    {{/}}\n  `\n})\n\n// Sender: bob\n// Message: Hi alice!\n// Keypath: mail.inbox.messages.0\n// Sender: bob\n// Message: Hi eve!\n// Keypath: mail.inbox.messages.1", 
            "title": "@rootpath"
        }, 
        {
            "location": "/legacy/0.9/api/#global", 
            "text": "The global object of the current environment. For browsers, it references the  window  object. For Node.js, it references the  global  object.   window.message = 'Hello World!'\n\nRactive({\n  el: 'body',\n  template: `\n    {{ @global.message }}\n  `\n})\n\n// Hello World!  Ractive can automatically update properties on  @global  via two-way binding. However, for changes caused externally,  ractive.update()  must be called to re-render the UI.   window.message = 'Hello World!'\n\nRactive({\n  el: 'body',\n  template: `\n    {{ @global.message }}\n     input type= text  value= {{ @global.message }} \n     button type= button  on-click= @this.logReference() Log reference value /button \n     button type= button  on-click= @this.logGlobal() Log global value /button \n     button type= button  on-click= @this.setFooBarBaz() Change to  foo bar baz  directly /button \n     button type= button  on-click= @this.update('@global.message') Click to update /button \n\n     ol \n       li Click  Log reference value  and look at the console /li \n       li Click  Log global value  and look at the console /li \n       li Change the input value and repeat steps 1 and 2 /li \n       li Click  Change to 'foo bar baz' directly /li \n       li Repeat steps 1 and 2 and notice that step 1 was not aware of the direct change /li \n       li Click  Click to update /li \n       li Repeat steps 1 and 2 and notice that both steps are now aware /li \n     /ol \n  `,\n  logReference () {\n    console.log(this.get('@global.message'))\n  },\n  logGlobal () {\n    console.log(window.message)\n  },\n  setFooBarBaz () {\n    window.message =  foo bar baz \n  }\n})", 
            "title": "@global"
        }, 
        {
            "location": "/legacy/0.9/api/#shared", 
            "text": "@shared  is a Ractive-global model similar to  @global  but not subject to interference from outside of Ractive.", 
            "title": "@shared"
        }, 
        {
            "location": "/legacy/0.9/api/#context", 
            "text": "The context object associated with the current context.", 
            "title": "@context"
        }, 
        {
            "location": "/legacy/0.9/api/#event", 
            "text": "The DOM event that is triggering an event directive. This reference is only available to event directive expressions.", 
            "title": "@event"
        }, 
        {
            "location": "/legacy/0.9/api/#node", 
            "text": "The DOM node associated with an event directive. This reference is only available to event directive expressions.", 
            "title": "@node"
        }, 
        {
            "location": "/legacy/0.9/api/#local", 
            "text": "Special context-local storage associated with the current context. This is intended more for library use with decorators and parser transforms.", 
            "title": "@local"
        }, 
        {
            "location": "/legacy/0.9/api/#style", 
            "text": "From   0.9.4  The cssData associated with the current instance based on its constructor.", 
            "title": "@style"
        }, 
        {
            "location": "/legacy/0.9/api/#n", 
            "text": "$n  is a reference available when handing events using the expression syntax that points to a specific argument passed by the event. Argument positions are denoted by the  n  which is a one-indexed integer.  const CustomButton = Ractive.extend({\n  template: `\n     button on-click= @this.fire('buttonevent', 'foo', 'bar') Click Me /button \n  `\n})\n\nRactive({\n  components: { CustomButton },\n  template: `\n     !-- Use with proxy expression syntax -- \n     CustomButton on-buttonevent= ['proxy', $1, $2]  / \n\n     !-- Use with method call -- \n     CustomButton on-buttonevent= @this.method($1, $2)  / \n  `,\n  on: {\n    proxy (context, foo, bar) {\n      console.log(foo, bar)\n    }\n  },\n  method (foo,bar) {\n    console.log(foo, bar)\n  }\n})", 
            "title": "$n"
        }, 
        {
            "location": "/legacy/0.9/api/#arguments", 
            "text": "arguments  is a reference available when handling events using the expression syntax that points to an array of arguments passed by the event.  const CustomButton = Ractive.extend({\n  template: `\n     button on-click= @this.fire('buttonevent', 'foo', 'bar') Click Me /button \n  `\n})\n\nRactive({\n  components: { CustomButton },\n  template: `\n     !-- Use with proxy expression syntax -- \n     CustomButton on-buttonevent= ['proxy', arguments]  / \n\n     !-- Use with method call -- \n     CustomButton on-buttonevent= @this.method(arguments)  / \n  `,\n  on: {\n    proxy (context, args) {\n      console.log(args)\n    }\n  },\n  method (foo,bar) {\n    console.log(args)\n  }\n})  arguments  is a normal array instance and not the special  arguments  JavaScript variable.", 
            "title": "arguments"
        }, 
        {
            "location": "/legacy/0.9/api/#initialization-options", 
            "text": "The following is an exhaustive list of initialisation options that you can pass to  Ractive()  and  Ractive.extend() . Extra properties passed as options that are not initialization options are added as properties or methods of the instance.  var ractive = Ractive({\n  myMethod () {\n    alert( 'my method was called' )\n  }\n})\n\nractive.myMethod(); // triggers the alert", 
            "title": "Initialization Options"
        }, 
        {
            "location": "/legacy/0.9/api/#adapt", 
            "text": "(Array string|Object )  An array of adaptors to use. Values can either be names of registered adaptors or an adaptor definition.  adapt: [ 'MyAdaptor', AdaptorDefinition ]  adapt  is not required if you registered adaptors via the  adaptors  initialization property. The adaptors registered via  adaptors  initialization property are automatically used as if they were set with  adapt .  const instance = Ractive({\n  adaptors: { MyAdaptor: AdaptorDefinition }\n  // No need to use adapt\n})\n\nconst Component = Ractive.extend({\n  adaptors: { MyAdaptor: AdaptorDefinition }\n  // No need to use adapt\n})\n\nnew Component({\n  // No need to use adapt\n})", 
            "title": "adapt"
        }, 
        {
            "location": "/legacy/0.9/api/#adaptors", 
            "text": "(Object string, Object )  A map of adaptors where the key is the adaptor name and the value is an adaptor definition.  adaptors: {\n  MyAdaptor: AdaptorDefinition\n}  Registering an adaptor via  adaptors  is not required if you directly specified the adaptor definition via  adapt .  const Adaptor = { ... }\n\nconst instance = Ractive({\n  adapt: [ AdaptorDefinition ]\n  // No need to use adaptors\n})", 
            "title": "adaptors"
        }, 
        {
            "location": "/legacy/0.9/api/#allowexpressions", 
            "text": "(boolean)  Indicates whether or not Ractive should process expressions. Defaults to  true .  Setting this to  false  effectively avoids the use of the  Function  constructor at the cost of not being able to use expressions such as those found in templates and computed properties.", 
            "title": "allowExpressions"
        }, 
        {
            "location": "/legacy/0.9/api/#append", 
            "text": "(boolean|string|HTMLElement|array-like)  Controls how the instance is attached to  el . Defaults to  false .  false  replaces the contents of  el .  !-- before --  div id='container' \n   p existing content /p  /div   el: '#container',\nappend: false,\ntemplate: ' p new content /p '  !-- after --  div id='container' \n   p new content /p  /div   true  appends the instance to  el .  !-- before --  div id='container' \n   p existing content /p  /div   el: '#container',\nappend: true,\ntemplate: ' p new content /p '  !-- after --  div id='container' \n   p existing content /p \n   p new content /p  /div   An  id  of the element, a CSS selector to an element, an HTML element, or an array-like object whose first item is an HTML element, which is a child of  el  will render the instance before that element.  !-- before --  div id='container' \n   p red /p \n   p orange /p \n   p yellow /p  /div   el: '#container',\nappend: document.querySelector('p:nth-child(2)'),\ntemplate: ' p grey /p '  !-- after --  div id='container' \n   p red /p \n   p grey /p \n   p orange /p \n   p yellow /p  /div", 
            "title": "append"
        }, 
        {
            "location": "/legacy/0.9/api/#attributes", 
            "text": "(Object string, [string]|Object string, [string] )  An array of optional attributes or a map of optional and required attributes. Defaults to  undefined .  You can supply a list of optional attributes using an array. You can also supply an object with an  optional  array of attribute names and a  required  array of attribute names. At runtime, if a component is created missing a required attribute, Ractive will issue a warning about missing required attributes. Any attributes that are passed to the component that are  not  included in either of the  optional  or  required  lists of attributes will be collected into a partial named  extra-attributes  so that they can be included on a top-level element in the component template or split apart to be used in a component  init  event.  const Component = Ractive.extend({\n  template: ` div class-component-wrapper {{yield extra-attributes}} Fancy component doing something with list and type /div `,\n  attributes: {\n    required: [ 'list' ],\n    optional: [ 'type' ]\n  }\n})\n\n//  Component type= foo  /  will issue a warning about missing list\n//  Component list= {{things}}  style-color= green  /  will not warn, but will include the style-color= green  on the wrapper div  The extra attributes passed to a component are not limited to simple attributes - they can also include directives, but any mustache sections will not have their contents checked. By default, the  extra-attributes  will  not  be mapped, meaning that the values won't be available with  get  from the component, so the partial should be yielded. If you need the extra attributes to be mapped, include an additional setting in the attributes map  mapAll: true .", 
            "title": "attributes"
        }, 
        {
            "location": "/legacy/0.9/api/#components", 
            "text": "(Object string, Function|Promise)  A map of components available to the instance or component being configured. The key is the registered name of the component, which is used in the template.  A component can be registered statically by assinging a component definition.  const MyStaticComponent = Ractive.extend({ ... })\n\nconst MyComponent = Ractive.extend({\n  components: { MyStaticComponent },\n  template: `\n     MyStaticComponent / \n  `\n})  A component can be registered dynamically by assinging a function that returns either a component definition, or a name of a registered component. The function receives  data  as first argument.  Ractive.components.GlobalComponent = Ractive.extend({ ... })\n\nconst NonGlobalComponent = Ractive.extend({ ... })\n\nconst MyComponent = Ractive.extend({\n  data: { isGlobal: false },\n  components: {\n    MyDynamicComponent: (data) =  data.isGlobal ? 'GlobalComponent' : NonGlobalComponent\n  },\n  template: `\n     MyDynamicComponent / \n  `\n})  A component can be loaded asynchronously by assingning a promise that resolves with a component definition.   // Assuming MyAsyncComponent.js does `export default Ractive.extend({ ... })`\n\nconst MyComponent = Ractive.extend({\n  components: {\n    MyAsyncComponent: import('./path/to/MyAsyncComponent.js')\n  },\n  template: `\n     MyAsyncComponent / \n  `\n})  A component can be loaded lazily by assinging a function that returns a promise that resolves with a component definition. Ractive only loads the component when it's being rendered.   // Assuming MyAsyncComponent.js does `export default Ractive.extend({ ... })`\n\nconst MyComponent = Ractive.extend({\n  components: {\n    MyAsyncComponent: () =  import('./path/to/MyAsyncComponent.js')\n  },\n  template: `\n     MyAsyncComponent / \n  `\n})  In both asynchronous cases, instances will be rendered immediately while the asynchronous components load. Once the asynchronous components are available, their placeholders will be re-rendered. Two reserved partial names,  async-loading  and  async-loaded , can be used to define markup when the asynchronous component is loading and loaded, respectively. A special partial named  component  is also available to render the component's contents inside  async-loaded .   // Assuming MyAsyncComponent.js does `export default Ractive.extend({ ... })`\n\nconst MyComponent = Ractive.extend({\n  components: {\n    MyAsyncComponent: import('./path/to/MyAsyncComponent.js')\n  },\n  template: `\n     span I'm rendered immediately. I don't wait for MyAsyncComponent /span \n     MyAsyncComponent \n      {{#partial async-loading}}I'm rendered when MyAsyncComponent is loading{{/partial}}\n      {{#partial async-loaded}}I'm rendered when MyAsyncComponent is loaded{{/partial}}\n      {{#partial async-loaded}}MyAsyncComponent contents: {{ component}}{{/partial}}\n     /MyAsyncComponent \n  `\n})  During a  ractive.reset() , components registered using a function are re-evaluated. If the return value changes, the Ractive instance will be re-rendered.", 
            "title": "components"
        }, 
        {
            "location": "/legacy/0.9/api/#computed", 
            "text": "(Object string, function|Object )  A map of computed properties where the key is the name of the computed property and the value is either a computed property expression, a function that returns a value, or an object that has  get  and  set  functions.  // Imagine a square...\ncomputed: {\n  // Computed property expression\n  diagonal: '${side} * Math.sqrt(2)',\n\n  // A function\n  perimeter () {\n    return 4 * this.get('side')\n  },\n\n  // An object with get and set functions\n  area: {\n    get () {\n      return Math.pow(this.get('side'), 2)\n    },\n    set (value) {\n      this.set('side', Math.sqrt(value))\n    }\n  },\n}", 
            "title": "computed"
        }, 
        {
            "location": "/legacy/0.9/api/#csp", 
            "text": "(boolean)  Whether or not to add inline functions for expressions after parsing. Defaults to  false .  This can effectively eliminate  eval  caused by expressions in templates. It also makes the resulting template no longer JSON compatible, so the template will have to be served via  script  tag.", 
            "title": "csp"
        }, 
        {
            "location": "/legacy/0.9/api/#css", 
            "text": "(string|function)  Scoped CSS for a component and its descendants.  css: `\n  .bold { font-weight: bold }\n`  At the moment, only applies to components.  // This works\nconst Component = Ractive.extend({\n  css: '...'\n})\n\n// This will not work\nRactive({\n  css: '...'\n})  From   0.9.4 , if  css  is a function, the function will be called with a handle to the component's style data and is expected to return a string of CSS.  const Component = Ractive.extend({\n  css(data) {\n    // you can use Ractive.styleSet('colors.special', 'pink') or Component.styleSet('colors.special', 'pink')\n    // at any time to override the default here, which is green\n    return `\n      .super-special { color: ${data('colors.special') || 'green'}; }\n    `\n  }\n})", 
            "title": "css"
        }, 
        {
            "location": "/legacy/0.9/api/#cssdata", 
            "text": "From   0.9.4  (object)  Like  css , this also only applies to components. This is the default data for a component's style computation, if it has one. It is inherited from parent components all the way back to Ractive, and any changes that are made at any point in the hierarchy are automatically propagated down from that point. This means that if a component uses  foo  in its style computation but does not define a value for it in its  cssData , then calling  Ractive.styleSet('foo', ...)  will cause the component style to recompute.", 
            "title": "cssData"
        }, 
        {
            "location": "/legacy/0.9/api/#cssid", 
            "text": "(string)  This value is used to scope CSS defined on a component's  css  initialization option only to the instances of the component. By default, the value is a randomly generated UUID.", 
            "title": "cssId"
        }, 
        {
            "location": "/legacy/0.9/api/#data", 
            "text": "(Object string, any |Function)  The data for an instance, or default data for a component. Can either be an object or a function that returns an object.  // Object form\ndata: {\n  foo: 'bar'\n}\n\n// Function form\ndata () {\n  return { foo: 'bar' }\n}\n\n// Function form using arrow function for less verbosity\ndata: () =  ({\n  foo: 'bar'\n})  When using the object form, the data is attached to the component's prototype. Standard prototype rules apply.  const Component = Ractive.extend({\n  data: {\n    foo: { bar: 42 }\n  }\n})\n\nvar component1 = Component()\nvar component2 = Component()\ncomponent1.set( 'foo.bar', 12 )\ncomponent2.get( 'foo.bar' ); // returns 12  When using the function form, the function is executed to give each instance a copy of the data. Standard prototype rules apply.  const Component = Ractive.extend({\n  data () {\n    return {\n      foo: { bar: 42 }\n    }\n  }\n})\n\nvar component1 = Component()\nvar component2 = Component()\ncomponent1.set( 'foo.bar', 12 )\ncomponent2.get( 'foo.bar' ); // returns 42  When extending from a constructor, data from the parent constructor will be shallow-copied over to the child data. Child data takes precedence in the event of collisions.  const Parent = Ractive.extend({\n  data: {\n    foo: 'Hello',\n    bar: 'World'\n  }\n})\n\nconst Child = Parent.extend({\n  data: {\n    foo: 'Goodbye'\n  }\n})\n\nParent().get(); // { foo: 'Hello', bar: 'World' }\nChild().get();  // { foo: 'Goodbye', bar: 'World' }", 
            "title": "data"
        }, 
        {
            "location": "/legacy/0.9/api/#decorators", 
            "text": "(Object string, Function )  A map of decorators where the key is the decorator name and the value is a decorator definition.  decorators: {\n  MyDecorator: DecoratorDefinition\n}", 
            "title": "decorators"
        }, 
        {
            "location": "/legacy/0.9/api/#delegate", 
            "text": "(boolean)  Whether or not to enable automatic event delegation for iterative sections within an element. Defaults to  true .  When enabled, DOM events subscribed within iterative sections will not add a DOM event listener to each element. Instead, a single listener will be installed on the element containing the iterative section, and that listener will find appropriate event directives starting from the target element and working back to the containing element with the listener.", 
            "title": "delegate"
        }, 
        {
            "location": "/legacy/0.9/api/#delimiters", 
            "text": "(Array[string])  Sets the template delimiters. Defaults to  [ '{{', '}}' ] .  delimiters: [ ' %=', '% ' ],\ntemplate: 'hello  %= world % ',\ndata: { world: 'earth' }\n\n// result:\n// hello earth", 
            "title": "delimiters"
        }, 
        {
            "location": "/legacy/0.9/api/#easing", 
            "text": "(Object string, Function )  A map of easing functions where the key is the easing function name and the value is the easing function.  easing: {\n  MyEasing: EasingDefinition\n}", 
            "title": "easing"
        }, 
        {
            "location": "/legacy/0.9/api/#el", 
            "text": "(string|HTMLElement|array-like)  The element to render an instance to. Can either be an  id  of the element, a CSS selector to an element, an HTML element, or an array-like object whose first item is an HTML element.  el: 'container'\nel: '#container'\nel: document.getElementById('container')\nel: jQuery('#container')", 
            "title": "el"
        }, 
        {
            "location": "/legacy/0.9/api/#enhance", 
            "text": "(boolean)  Whether or not to apply progressive enhancement by inspecting the contents of  el  and try to reuse as much of the existing tree as possible. Defaults to  false .  There are a few limitations to this feature:    This option cannot be used with  append .    Unescaped HTML mustaches (triples) don't play nicely with enhance because there's no easy way to match up the string content to the target DOM nodes.    All matching elements will be reused, except for a few cases regarding text nodes.  div left text {{#if foo}} middle text {{/if}} right text /div  HTML does not have markup representation for adjacent text nodes. Rendering the snippet above from the server, regardless of  foo 's value, the browser creates one contiguous text node. However, Ractive will need  three  adjacent text nodes to represent it: One for  outer text , another for  right text  and another for  middle text  when  foo  becomes truthy.  It has been suggested that Ractive could deal with merged text nodes, but that would lead to extra complexity as there are certain scenarios where the text node would have to split and rejoin. When  foo  is falsey,  left text  and  right text  could be merged. But when  foo  becomes truthy, that text node would have to split in order to accomodate  middle text .", 
            "title": "enhance"
        }, 
        {
            "location": "/legacy/0.9/api/#events", 
            "text": "(Object string, Function )  A map of events where the key is the event name and value is an event definition.  events: {\n  MyEvent: EventDefinition\n}", 
            "title": "events"
        }, 
        {
            "location": "/legacy/0.9/api/#interpolators", 
            "text": "(Object string, Function )  A map of interpolators where the key is the interpolator name and the value is an interpolator definition.  interpolators: {\n  MyInterpolator: InterpolatorDefinition\n}", 
            "title": "interpolators"
        }, 
        {
            "location": "/legacy/0.9/api/#isolated", 
            "text": "(boolean)  Controls whether the component will try to resolve data and plugins on its ancestors. Defaults to  true .  Relevant only to Components.", 
            "title": "isolated"
        }, 
        {
            "location": "/legacy/0.9/api/#lazy_1", 
            "text": "(boolean|number)  Whether or not to update data using late-firing DOM events (i.e.  change ,  blur ) instead of events that fire immediately on interaction (i.e.  keyup ,  keydown ). Defaults to  false .  var ractive = Ractive({\n  lazy: true,\n  data: { foo: 'bar' },\n  template: `\n     input value= {{foo}} \n\n     !-- Updates when the input loses focus -- \n    {{ foo }}\n  `\n})  lazy  also accepts a number value, a millisecond value, that indicates the delay between the last UI interaction and Ractive updating the data. Losing element focus is not required for the update to kick in.  var ractive = Ractive({\n  lazy: 1000,\n  data: { foo: 'bar' },\n  template: `\n     input value= {{foo}} \n\n     !-- Updates 1000ms after the last interaction on input -- \n    {{ foo }}\n  `\n})  lazy  is only applicable if  twoway  is  true .", 
            "title": "lazy"
        }, 
        {
            "location": "/legacy/0.9/api/#nestedtransitions", 
            "text": "(boolean)  Whether or not to allow transitions to fire if they are already downstream from a transitioning element. Defaults to  true .  {{#if outer}}\n   div fade-in='slow' \n    Outer text.\n    {{#if inner}}\n       div fly-in= fast Inner text. /div \n    {{/if}}\n   /div \n{{/if}}  In this example, if  inner  is  true  when  outer  becomes  true , then all of the  div s will render at the same time. If  nestedTransitions  is disabled, then the  fly  transition on inner  div  will not be run, since the  fade  will already be running on the outer  div .  This can also be controlled per transition using the  nested  boolean parameter for transitions:  div fade-in= { duration: 'slow', nested: false } ... /div", 
            "title": "nestedTransitions"
        }, 
        {
            "location": "/legacy/0.9/api/#nocsstransform", 
            "text": "(boolean)  Prevents component CSS from being transformed with scoping guids. Defaults to  false .", 
            "title": "noCssTransform"
        }, 
        {
            "location": "/legacy/0.9/api/#nointro", 
            "text": "(boolean)  Whether or not to skip intro transitions on initial render. Defaults to  false .  var ractive = Ractive({\n  template: ' ul {{#items}} li fade-in {{.}} /li {{/items}} /ul ',\n  data: { items: [ 'red', 'blue' ] },\n  transitions: {\n    fade ( t, params ) {...}\n  },\n  noIntro: true\n})\n// 'red' and 'blue' list items do not fade in\n\nractive.push( 'items', 'green' )\n// 'green' list item will fade in", 
            "title": "noIntro"
        }, 
        {
            "location": "/legacy/0.9/api/#nooutro", 
            "text": "(boolean)  Whether or not to skip outro transitions during an instance unrender. Defaults to  false .  var ractive = Ractive({\n  template: ' ul {{#items}} li fade-out {{.}} /li {{/items}} /ul ',\n  data: { items: [ 'red', 'blue' ] },\n  transitions: {\n    fade ( t, params ) {...}\n  },\n  noOutro: true\n})\n\nractive.pop( 'items' )\n// 'blue' list item will fade out\n\nractive.unrender()\n// 'red' list item will not fade out", 
            "title": "noOutro"
        }, 
        {
            "location": "/legacy/0.9/api/#observe", 
            "text": "(Object string, Function|Object )  A hash of observers to subscribe during initialization and unsubscribe during teardown. Defaults to  undefined .  The keys of the hash may be any string that is accepted by  ractive.observe() , and the values may be either callback functions, as would be passed to  ractive.observe() , or objects with a  handler  property that is a callback function. The object form also takes other options that control the behavior of the observer.  Ractive({\n  // ..\n  observe: {\n    show ( value ) {\n      console.log( `show changed to '${value}'` )\n    },\n    'users.*.name people.*.name': {\n      handler ( value, old, path, idx ) {\n        console.log( `${path} changed to '${value}'` )\n      },\n      init: false,\n      strict: true\n    }\n  }\n})  The options that may be specified in the object form are (see the  ractive.observe()  docs for more detailed option descriptions):   handler (Function) : The callback function for the observer.  once (boolean) : Use  ractive.observeOnce()  rather than  ractive.observe()  to install the observer, meaning the observer is implicitly  init: false , will only fire for the first change to the observed path, and will by removed after the first change.  strict (boolean) : Use strict equality when determining whether or not a value has changed.  array (boolean) : Use an array observer rather than a plain observer.  defer (boolean) : Defer the observer until after the DOM is settled.  init (boolean) : Whether or not to fire an initial change event.  links (boolean) : Whether or not to follow links.  context (any) : Context for the callback function.  old (Function) : Modifier function for the  old  value passed to the callback function.   When a sublcass created with  Ractive.extend()  is passed an  observe  hash, then any further subclasses or instances created with an  observe  hash will be combined. Any superclass observers are installed first following the inheritance hierarchy, and finally, any instance observers are installed.", 
            "title": "observe"
        }, 
        {
            "location": "/legacy/0.9/api/#on", 
            "text": "(Object string, Function|Object )  A hash of event listeners to subscribe during initialization and unsubscribe during teardown. Defaults to  undefined .  The keys of the hash may be any string that is accepted by  ractive.on() , and the values may be either callback functions, as would be passed to  ractive.on() , or objects with a  handler  property that is a callback function. The object form also takes other options that control the behavior of the event handler.  Ractive({\n  // ...\n  on: {\n    init () {\n      console.log('I will print during init')\n    },\n    '*.somethingHappened': {\n      handler ( ctx ) {\n        console.log('I will fire when this instance or any child component fires an instance event named  somethingHappened ')\n      },\n      once: true\n    }\n  },\n  // ...\n})  The options that may be specified in the object form are:   handler (Function) : The callback function for the event.  once (boolean) : Use  ractive.once()  rather than  ractive.on()  to subscribe the listener, meaning that the handler will only be called the first time the event is fired and then it will be unsubscribed.   on  event listeners may subscribe to any instance event, including lifecycle events. When a sublcass created with  Ractive.extend()  is passed an  on  hash, then any further subclasses or instances created with an  on  hash will be combined. Any superclass event handlers are installed first following the inheritance hierarchy, and finally, any instance event handlers are installed.", 
            "title": "on"
        }, 
        {
            "location": "/legacy/0.9/api/#oncomplete", 
            "text": "(Function)  A lifecycle event that is called when the instance is rendered and all the transitions have completed.", 
            "title": "oncomplete"
        }, 
        {
            "location": "/legacy/0.9/api/#onconfig", 
            "text": "(Function)  A lifecycle event that is called when an instance is constructed and all initialization options have been processed.", 
            "title": "onconfig"
        }, 
        {
            "location": "/legacy/0.9/api/#onconstruct", 
            "text": "(Function)  A lifecycle event that is called when an instance is constructed but before any initialization option has been processed.  Accepts the instance's initialization options as argument.", 
            "title": "onconstruct"
        }, 
        {
            "location": "/legacy/0.9/api/#ondestruct", 
            "text": "(Function)  A lifecycle event that is called when an instance is torn down and any associated transitions are complete.", 
            "title": "ondestruct"
        }, 
        {
            "location": "/legacy/0.9/api/#ondetach", 
            "text": "(Function)  A lifecycle event that is called whenever  ractive.detach()  is called.  Note that  ractive.insert()  implicitly calls  ractive.detach()  if needed.", 
            "title": "ondetach"
        }, 
        {
            "location": "/legacy/0.9/api/#oninit", 
            "text": "(Function)  A lifecycle event that is called when an instance is constructed and is ready to be rendered.", 
            "title": "oninit"
        }, 
        {
            "location": "/legacy/0.9/api/#oninsert", 
            "text": "(Function)  A lifecycle event that is called when  ractive.insert()  is called.", 
            "title": "oninsert"
        }, 
        {
            "location": "/legacy/0.9/api/#onrender", 
            "text": "(Function)  A lifecycle event that is called when the instance is rendered but  before  transitions start.", 
            "title": "onrender"
        }, 
        {
            "location": "/legacy/0.9/api/#onteardown", 
            "text": "(Function)  A lifecycle event that is called when the instance is being torn down.", 
            "title": "onteardown"
        }, 
        {
            "location": "/legacy/0.9/api/#onunrender", 
            "text": "(Function)  A lifecycle event that is called when the instance is being undrendered.", 
            "title": "onunrender"
        }, 
        {
            "location": "/legacy/0.9/api/#onupdate", 
            "text": "(Function)  A lifecycle event that is called when  ractive.update()  is called.", 
            "title": "onupdate"
        }, 
        {
            "location": "/legacy/0.9/api/#partials", 
            "text": "(Object string, string|Object|Function )  A map of partials where the key is the partial name and the value is either a template string, a parsed template object or a function that returns any of the previous options. The function form accepts processed  data  and  Parse Object as arguments.  partials: {\n  stringPartial: ' p {{greeting}} world! /p ',\n  parsedPartial: { v :3, t :[{ t :7, e : p , f :[{ t :2, r : greeting },  world! ]}]},\n  functionPartial (data, p) {\n    return data.condition ? ' p hello world /p ' : ' div yes, we have no foo /div '\n  }\n}  During a  ractive.reset() , function partials are re-evaluated. If the return value changes, the Ractive instance will be re-rendered.", 
            "title": "partials"
        }, 
        {
            "location": "/legacy/0.9/api/#preservewhitespace", 
            "text": "(boolean)  Whether or not to preserve whitespace in templates when parsing. Defaults to  false .  Whitespace in  pre  elements is always preserved. The browser will still deal with whitespace in the normal fashion.  var ractive = Ractive({\n  template: ' p hello\\n\\n  \\tworld    /p ',\n  preserveWhitespace: false //default\n})\n\nconsole.log( ractive.toHTML() )\n//  p hello world /p \n\nvar ractive = Ractive({\n  template: ' p hello\\n\\n  \\tworld    /p ',\n  preserveWhitespace: true\n})\n\nconsole.log( ractive.toHTML() )\n// p hello\n//\n//  world    /p", 
            "title": "preserveWhitespace"
        }, 
        {
            "location": "/legacy/0.9/api/#resolveinstancemembers", 
            "text": "(boolean)  Whether or not to include members of the Ractive instance at the end of the reference resolution process. Defaults to  true .  button on-click= toggle('show') Toggle /button   If there is no data member  toggle  in the context of the template, with  resolveInstanceMembers  enabled, the reference will resolve to the  ractive.toggle()  method of the instance.", 
            "title": "resolveInstanceMembers"
        }, 
        {
            "location": "/legacy/0.9/api/#sanitize", 
            "text": "(boolean|Object)  Whether or not certain elements will be stripped from the template during parsing.  Defaults to  false .  true  strips out blacklisted elements and event attributes. See  Ractive.parse()  for the default list of blacklisted elements.  template: `\n   p some content /p \n   frame Am I a bad element or just misunderstood? /frame \n`,\nsanitize: true\n\n// result:\n//  p some content /p   The object form should have  elements  which is an array of blacklisted elements and  eventAttributes  boolean which, when  true , also strips out event attributes.  template: `\n   p some content /p \n   div onclick= doEvil() the good stuff /div \n`,\nsanitize: {\n  elements: [ 'p' ],\n  eventAttributes: true\n}\n\n// result:\n//  div the good stuff /div", 
            "title": "sanitize"
        }, 
        {
            "location": "/legacy/0.9/api/#staticdelimiters", 
            "text": "(Array[string])  Sets the static (one-time binding) delimiters. Defaults to  [ '[[', ']]' ] .  var ractive = Ractive({\n  template: 'hello [[foo]]',\n  staticDelimiters: [ '[[', ']]' ], //default\n  data: { foo: 'world' }\n})\n// result:  hello world \n\nractive.set( 'foo', 'mars' )\n// still is:  hello world", 
            "title": "staticDelimiters"
        }, 
        {
            "location": "/legacy/0.9/api/#statictripledelimiters", 
            "text": "(Array string )  Sets the static (one-time binding) triple delimiters. Defaults to  [ '[[[', ']]]' ] .  var ractive = Ractive({\n  template: 'hello [[[html]]]',\n  staticTripleDelimiters: [ '[[[', ']]]' ], //default\n  data: { html: ' span world /span ' }\n})\n// result:  hello  span world /span \n\nractive.set( 'html', ' span mars /span ' )\n// still is:  hello world", 
            "title": "staticTripleDelimiters"
        }, 
        {
            "location": "/legacy/0.9/api/#stripcomments", 
            "text": "(boolean)  Whether or not to remove comments in templates when parsing. Defaults to  true .  template: ' !-- html comment -- hello world',\nstripComments: false\n\n// result:\n//  !-- html comment -- hello world", 
            "title": "stripComments"
        }, 
        {
            "location": "/legacy/0.9/api/#synccomputedchildren", 
            "text": "(boolean)  Whether or not to invalidate the dependencies of an expression when child keypaths of the expression are updated. Defaults to  false .  Note : setting this to  true  may cause performance issues for complex expressions involving large arrays.  input value= {{pattern}}  / \n{{#each filter(users, pattern)}}\n   input value= {{.name}}  / \n{{/each}}  In this example, the  input  inside the iteration is bound to a computation e.g.  filter(users, pattern).0.name  that isn't actually an addressable model. With  syncComputedChildren  enabled, when that virtual keypath is updated by a user changing the  input , the expression will invalidate its dependencies ( filter ,  users , and  pattern ), which will cause any other references to the  user  that happens to coincide with result of the expression to also update.", 
            "title": "syncComputedChildren"
        }, 
        {
            "location": "/legacy/0.9/api/#target", 
            "text": "(string|HTMLElement|array-like)  Alias for  el .", 
            "title": "target"
        }, 
        {
            "location": "/legacy/0.9/api/#template", 
            "text": "(string|array|object|function)  The template to use. Must either be a CSS selector string pointing to an element on the page containing the template, an HTML string, an object resulting from  Ractive.parse()  or a function that returns any of the previous options. The function form accepts processed  data  and a Parse Object.  // Selector\ntemplate: '#my-template',\n\n// HTML\ntemplate: ' p {{greeting}} world! /p ',\n\n// Template AST\ntemplate: { v :3, t :[{ t :7, e : p , f :[{ t :2, r : greeting },  world! ]}]},\n\n// Function\ntemplate (data, p) {\n  return ' p {{greeting}} world! /p '\n},  During a  ractive.reset() , templates provided using a function are re-evaluated. If the return value changes, the Ractive instance will be re-rendered.", 
            "title": "template"
        }, 
        {
            "location": "/legacy/0.9/api/#transitions", 
            "text": "(Object string, Function )  A map of transitions where the key is the name of the transition and the value is a transition definition.", 
            "title": "transitions"
        }, 
        {
            "location": "/legacy/0.9/api/#transitionsenabled", 
            "text": "(boolean)  Whether or not transitions are enabled. Defaults to  true .", 
            "title": "transitionsEnabled"
        }, 
        {
            "location": "/legacy/0.9/api/#tripledelimiters", 
            "text": "(Array[string])  Sets the triple delimiters. Defaults to  [ '{{{', '}}}' ] .  template: 'hello @html@',\ntripleDelimiters: [ '@', '@' ],\ndata: { html: ' span world /span ' }\n\n// result:\n// hello  span world /span", 
            "title": "tripleDelimiters"
        }, 
        {
            "location": "/legacy/0.9/api/#twoway_1", 
            "text": "(boolean)  Whether or not two-way binding is enabled. Defaults to  true .  var ractive = Ractive({\n  template: ' input value= {{foo}} ',\n  data: { foo: 'bar' },\n  twoway: false\n})\n\n// user types  fizz  into  input , but data value is not changed:\n\nconsole.log( ractive.get( 'foo' ) ); //logs  bar \n\n// updates from the model are still pushed to the view\n\nractive.set( 'foo', 'fizz' )\n\n// input now displays  fizz", 
            "title": "twoway"
        }, 
        {
            "location": "/legacy/0.9/api/#warnaboutambiguity", 
            "text": "(boolean)  Whether or not to warn about references that don't resolve to their immediate context. Defaults to  false .  Ambiguous references can be the cause of some strange behavior when your data changes structure slightly. With  warnAboutAmbiguity  enabled, Ractive will warn you any time a reference isn't scoped and resolves in a context above the immediate context of the reference.", 
            "title": "warnAboutAmbiguity"
        }, 
        {
            "location": "/legacy/0.9/api/#static-properties", 
            "text": "", 
            "title": "Static Properties"
        }, 
        {
            "location": "/legacy/0.9/api/#ractiveadaptors", 
            "text": "(Object string, Object )  The registry of globally available adaptors.", 
            "title": "Ractive.adaptors"
        }, 
        {
            "location": "/legacy/0.9/api/#ractivecomponents", 
            "text": "(Object string, Function )  The registry of globally available component definitions.", 
            "title": "Ractive.components"
        }, 
        {
            "location": "/legacy/0.9/api/#ractivecontext", 
            "text": "From   0.9.4  (Object)  The prototype for  Context  objects. This is provided so that you can extend context objects provided by Ractive with your own methods and properties.", 
            "title": "Ractive.Context"
        }, 
        {
            "location": "/legacy/0.9/api/#ractivedebug", 
            "text": "(boolean)  Tells Ractive if it's in debug mode or not. When set to  true , non-fatal errors are logged. When set to  false , non-fatal errors are suppressed. By default, this is set to  true .", 
            "title": "Ractive.DEBUG"
        }, 
        {
            "location": "/legacy/0.9/api/#ractivedebug_promises", 
            "text": "(boolean)  Tells Ractive to log errors thrown inside promises. When set to  true , errors thrown in promises are logged. When set to  false , errors inside promises are suppressed. By default, this is set to  true .", 
            "title": "Ractive.DEBUG_PROMISES"
        }, 
        {
            "location": "/legacy/0.9/api/#ractivedecorators", 
            "text": "(Object string, Function )  The registry of globally available decorators.", 
            "title": "Ractive.decorators"
        }, 
        {
            "location": "/legacy/0.9/api/#ractivedefaults", 
            "text": "(Object string, any )  Global defaults for initialisation options with the exception of plugin registries.  // Change the default mustache delimiters to [[ ]] globally\nRactive.defaults.delimiters = [ '[[', ']]' ]\n\n// Future instances now use [[ ]]\nractive1 = Ractive({\n    template: 'hello [[world]]'\n})  Defaults can be specified for a subclass of Ractive, overriding global defaults.  var MyRactive = Ractive.extend()\n\nMyRactive.defaults.el = document.body  Configuration on the instance overrides subclass and global defaults.  Ractive.defaults.delimiters = [ '[[', ']]' ]\n\n// Uses the delimiters specified above\nRactive({\n  template: 'hello [[world]]'\n})\n\n// Uses the delimiters specified in the init options\nRactive({\n  template: 'hello //world\\\\',\n  delimiters: [ '//', '\\\\' ]\n})  Global data attributes may be specified:  Ractive.defaults.data.people = [{id:4, name:'Fred'},{id:5, name:'Wilma'},...]\n\n//or alternatively:\nObject.assign(Ractive.defaults.data,{people : [{id:4, name:'Fred'},{id:5, name:'Wilma'},...],\n                                     title : 'Flintstones',\n                                     producer : 'Hanna-Barbera'})\n\n// (Object.assign is provided as a polyfill by Ractive if it's not supported by the browser)  The data attributes and values are then accessible in all components. Data attributes specified in this way, however, do  not  trigger an automatic component update if the attribute value is changed after the component is instantiated.", 
            "title": "Ractive.defaults"
        }, 
        {
            "location": "/legacy/0.9/api/#ractiveeasing", 
            "text": "(Object string, Function )  The global registry of easing functions.  The easing functions are used by the  ractive.animate  method and by transitions. Four are included by default:  linear ,  easeIn ,  easeOut  and  easeInOut .", 
            "title": "Ractive.easing"
        }, 
        {
            "location": "/legacy/0.9/api/#ractiveevents", 
            "text": "(Object string, Function )  The global registry of custom event plugins.", 
            "title": "Ractive.events"
        }, 
        {
            "location": "/legacy/0.9/api/#ractiveinterpolators", 
            "text": "(Object string, Function )  A key-value hash of interpolators use by  ractive.animate()  or non-CSS transitions.", 
            "title": "Ractive.interpolators"
        }, 
        {
            "location": "/legacy/0.9/api/#componentparent", 
            "text": "From   0.9.1  (Ractive|Component constructor)  The parent constructor of a component.  const MyComponent = Ractive.extend()\nconst MySpecialComponent = MyComponent.extend()\n\nMyComponent.Parent === Ractive; // true\nMySpecialCompoennt.Parent === MyComponent; // true", 
            "title": "[Component].Parent"
        }, 
        {
            "location": "/legacy/0.9/api/#ractivepartials", 
            "text": "(Object string, string|Object|Function )  The global registry of partial templates.  Like templates, partials are parsed at the point of use. The parsed output is cached and utilized for future use.", 
            "title": "Ractive.partials"
        }, 
        {
            "location": "/legacy/0.9/api/#componentractive", 
            "text": "From   0.9.1  (Ractive)  The root Ractive constructor that is the first ancestor of this component.  const MyComponent = Ractive.extend()\nconst MySpecialComponent = MyComponent.extend()\n\nMyComponent.Ractive === Ractive; // true\nMySpecialCompoennt.Ractive === Ractive; // true", 
            "title": "[Component].Ractive"
        }, 
        {
            "location": "/legacy/0.9/api/#ractivesvg", 
            "text": "(boolean)  Indicates whether or not the browser supports SVG.", 
            "title": "Ractive.svg"
        }, 
        {
            "location": "/legacy/0.9/api/#ractivetransitions", 
            "text": "(Object string, Function )  The global registry of transition functions.", 
            "title": "Ractive.transitions"
        }, 
        {
            "location": "/legacy/0.9/api/#ractiveversion", 
            "text": "(string)  The version of the currently loaded Ractive.", 
            "title": "Ractive.VERSION"
        }, 
        {
            "location": "/legacy/0.9/api/#static-methods", 
            "text": "", 
            "title": "Static Methods"
        }, 
        {
            "location": "/legacy/0.9/api/#ractiveescapekey", 
            "text": "Escapes the given key so that it can be concatenated with a keypath string.  Syntax   Ractive.escapeKey(key)   Arguments   key (string) : The key to escape.   Returns   (string) : The escaped key.   Examples  Example 1  Ractive.escapeKey('foo.bar'); // 'foo\\\\.bar'  Example 2   Ractive({\n    ...\n  on:{\n    changeUrl () {\n      this.set('img.a\\\\.jpg.url',  /my/new/path.jpg )\n    },\n    changeUrl2 () {\n      mykey = 'a.jpg'\n      this.set('img.' + Ractive.escapeKey(mykey) + '.url',  /the/other/path.jpg )\n    }\n  },\n  data: {\n    img: {\n      'a.jpg': {\n        url:  /path/to/a.jpg \n      }\n    }\n  }\n})", 
            "title": "Ractive.escapeKey()"
        }, 
        {
            "location": "/legacy/0.9/api/#ractiveextend", 
            "text": "Creates a \"subclass\" of the Ractive constructor or a subclass constructor. See  Components  for an in-depth discussion on the use of  Ractive.extend .  Syntax   Ractive.extend([options[, ...optionsN]])   Arguments   options] (Object) : One or more objects that represent the defaults for instances of the subclass, with the latter objects' properties taking precedence over the former. See [Initialization Options for a list of possible options.   Returns   (Function) : The subclass constructor function.   Examples  const SubClass = Ractive.extend({\n    template: ' div {{message}} /div ',\n    data: {\n        message: 'Hello World!'\n    }\n})\n\n//  div Hello World! /div \nconst instance1 = SubClass({\n    el: '.div1'\n})\n\n//  div Lorem Ipsum /div \nconst instance2 = SubClass({\n    el: '.div2',\n    data: {\n        message: 'Lorem Ipsum'\n    }\n})", 
            "title": "Ractive.extend()"
        }, 
        {
            "location": "/legacy/0.9/api/#ractiveextendwith", 
            "text": "Creates a \"subclass\" of the Ractive constructor or a subclass constructor using an existing constructor. The constructor will be augmented with static methods like  extend , and it will also process the given initialization options.  Syntax   Ractive.extendWith(constructor[, options])   Arguments   constructor (Function) : A class constructor - like an ES6  class , a plain JavaScript function with a prototpye, or another similarly constructed function (TypeScript, CoffeeScript, etc).  options (Object) : An object with initialization options as properties. See initialization options for a list of possible options.   Returns   (Function) : The augmented constructor function.   Examples  class Widget extends Ractive {\n  notify ( message ) {\n    this.push( 'messages', message )\n  }\n\n  show () {\n    this.set( 'visible', true )\n  }\n\n  hide () {\n    this.set( 'visible', false )\n  }\n}\n\nRactive.extendWith( Widget, {\n  template: '{{#if visible}} ul {{#each messages}} li {{.}} /li {{/each}} /ul {{/if}}'\n})", 
            "title": "Ractive.extendWith()"
        }, 
        {
            "location": "/legacy/0.9/api/#ractivegetcss", 
            "text": "Returns the scoped CSS from Ractive subclasses defined at the time of the call.  If used without arguments, it will return the scoped CSS of all subclasses. If provided an array of scoping IDs, it will return the scoped CSS of all subclasses whose scoping ID is included in the array.  Syntax   Ractive.getCSS([key])   Arguments   [key] (Array string ) : Subclass CSS scoping ID.   Returns   (string) : The scoped CSS.   Examples  // Assuming the generated ID for this subclass is 'xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx'.\nconst Subclass1 = Ractive.extend({\n    ...\n    css: 'div{ color: red }'\n    ...\n})\n\n// Assuming the generated ID for this subclass is 'yyyyyyyy-yyyy-yyyy-yyyy-yyyyyyyyyyyy'.\nconst Subclass2 = Ractive.extend({\n    ...\n    css: 'div{ color: green }'\n    ...\n})\n\n// CSS contains the scoped versions of div{ color: red } and div{ color: green }.\nconst css = Ractive.getCSS()\n\n// css contains the scoped version of div{ color: red } only.\nconst css = Ractive.getCSS([ 'xxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx' ])", 
            "title": "Ractive.getCSS()"
        }, 
        {
            "location": "/legacy/0.9/api/#ractivegetcontext", 
            "text": "Accepts a node and returns a Context object containing details of the Ractive instance the node is associated to.  Syntax   Ractive.getContext(node)   Arguments   node (string|Node) : The DOM node or a CSS selector of the DOM node for which you wish to retrieve the Ractive instance or view details.   Returns   (Context) : A context object.   Examples  const info = Ractive.getContext(document.getElementById('some-node'))\n\nconst info = Ractive.getContext('#some-node')", 
            "title": "Ractive.getContext()"
        }, 
        {
            "location": "/legacy/0.9/api/#ractiveisinstance", 
            "text": "From   0.9.1  Determines whether or not the given object is an instance of the Ractive constructor. This is also extended to component constructors, where it will make sure that the given object is an instance of the particular constructor on which it is called.  Syntax   Ractive.isInstance(obj)   Arguments   obj (any) : The thing to check.   Returns   boolean   Examples  const MyComponent = Ractive.extend()\nconst MySpecialComponent = MyComponent.extend()\nconst OtherComponent = Ractive.extend()\n\nconst r = new MySpecialCompoennt()\n\nMySpecialComponent.isInstance(r); // true\nMyComponent.isInstance(r); // true\nOtherComponent.isIstance(r); // false\n\nRactive.isInstance(r); //true", 
            "title": "Ractive.isInstance()"
        }, 
        {
            "location": "/legacy/0.9/api/#ractivejoinkeys", 
            "text": "Joins the given keys into a properly escaped keypath.  Syntax   Ractive.joinKeys(key1 [, ...keyN])   Arguments   key (string) : One or more strings to join.   Returns   (string) : A properly joined and escaped keypath.   Examples  Ractive.joinKeys( 'foo', 'bar.baz' ); // foo.bar\\.baz", 
            "title": "Ractive.joinKeys()"
        }, 
        {
            "location": "/legacy/0.9/api/#ractiveparse", 
            "text": "Parses the template into an abstract syntax tree that Ractive can work on.  Syntax   Ractive.parse(template[, options])   Arguments   template (string) : A Ractive-compliant HTML template.  [options] (Object) : Parser options.  [delimiters] ([string]) : Start and end delimiters for normal mustaches. Defaults to  ['{{', '}}'] .  [tripleDelimiters] ([string]) : Start and end delimiters for triple mustaches. Defaults to  ['{{{', '}}}'] .  [staticDelimiters] ([string]) : Start and end delimiters for static mustaches. Defaults to  ['[[', ']]'] .  [staticTripleDelimiters] ([string]) : Start and end delimiters for static triple mustaches. Defaults to  ['[[[', ']]]'] .  [contextLines] (integer) : Additional lines above and below a line with a parse error to include in the error output. Defaults to  0 .  [interpolate] (Object string, boolean ) : Map of elements that indicates whether or not to read mustaches within the element. Defaults to  { script: false, textarea: true, template: false, style: false } .  [csp] (boolean) : When  true  includes pre-compiled expression functions in the template output so that  eval  is not needed at runtime. Defaults to  true .  [preserveWhitespace] (boolean) : When  true , preserves whitespace in templates. Whitespace inside the  pre  element is preserved regardless of the value of this option. Defaults to  false .  [stripComments] (boolean) : When  false  will leave comments in the parsed template. Defaults to  true .  [sanitize] (boolean|Object) : When  true , strips inline event attributes and certain elements from the markup. Defaults to  false .  [elements] (Array string ) : An array of element names to blacklist.  [eventAttributes] (boolean) : When  true , strips off inline event attributes.    [includeLinePositions] (boolean) : When  true  will include line positions on each node of the parser output. Defaults to  false .  [textOnlyMode] (boolean) : When  true  parses elements as text rather than elements. This is useful for generating raw HTML from a template, more like a plain text templating processor. Defaults to  false .  [transforms|parserTransforms] ([Function])`: An array of post-parsing transforms to apply to the output parser AST.     When  sanitize  is  true , the following elements are stripped:   applet  base  basefont  body  frame  frameset  head  html  isindex  link  meta  noframes  noscript  object  param  script  style  title   Returns   (Object)  - The object representation of the provided markup.   Examples  Assume the following markup.  div class='gallery' \n  {{#each items}}\n     !-- comments get stripped out of the template -- \n     figure on-tap='select' staggered-in \n       img class='thumbnail' src='assets/images/{{id}}.jpg' \n       figcaption {{( @index+1 )}}: {{description}} /figcaption \n     /figure \n  {{/each}} /div   Ractive.parse( template );  will yield the following output:  { v :4, t :[{ t :7, e : div , m :[{ n : class , f : gallery , t :13}], f :[{ t :4, f :[   ,{ t :7, e : figure , m :[{ n :[ tap ], t :70, f : select },{ n : staggered , t :72, v : t1 }], f :[{ t :7, e : img , m :[{ n : class , f : thumbnail , t :13},{ n : src , f :[ assets/images/ ,{ t :2, r : id }, .jpg ], t :13}]},   ,{ t :7, e : figcaption , f :[{ t :2, x :{ r :[ @index ], s : _0+1 }}, :  ,{ t :2, r : description }]}]}], n :52, r : items }]}], e :{'_0+1': function(_0) { return _0+1; }}}", 
            "title": "Ractive.parse()"
        }, 
        {
            "location": "/legacy/0.9/api/#ractivesplitkeypath", 
            "text": "Splits the given keypath into an array of unescaped keys.  Syntax   Ractive.splitKeypath(keypath)   Arguments   keypath (string) : The keypath to split into keys.   Returns   (Array) : Returns an array of unescaped keys.   Examples  Ractive.splitKeypath( 'foo.bar\\\\.baz' ); // [ 'foo', 'bar.baz' ]", 
            "title": "Ractive.splitKeypath()"
        }, 
        {
            "location": "/legacy/0.9/api/#ractivesharedset", 
            "text": "From   0.9.4  Sets data in the  @shared  object without requiring access to a Ractive instance.  Syntax   Ractive.sharedSet(keypath, value, options)  Ractive.sharedSet(hash, options)   Arguments  Arguments are the same as would be supplied to  ractive.set .  Returns   (Promise) : Returns a promise that resolves when any transitions associated with the change have completed.   Examples  Ractive.sharedSet( '_', lodash )", 
            "title": "Ractive.sharedSet()"
        }, 
        {
            "location": "/legacy/0.9/api/#ractivestyleset", 
            "text": "From   0.9.4  Sets data in the  @style  object of Ractive or the component constructor on which it is called. When an applied style that is affected by a change from  styleSet  updates, Ractive will update its manaaged style tag so that the changes show up in the browser immediately.  This function is also available to components created with  Ractive.extend . When called on a component constructor,  styleSet  will set the value in the component's  cssData , and any extensions of the component will also be notified that the parent data changed.  Syntax   Ractive.styleSet(keypath, value, options)  Ractive.styleSet(hash, options)   Arguments  Arguments are the same as would be supplied to  ractive.set  with an addition to the  options  hash:   apply (boolean) : Whether or not to apply any affected styles now. Defaults to  true .   Returns   (Promise) : Returns a promise that resolves when any transitions associated with the change have completed.   Examples  Ractive.styleSet( 'colors.fg', '#000' )", 
            "title": "Ractive.styleSet()"
        }, 
        {
            "location": "/legacy/0.9/api/#ractiveunescapekey", 
            "text": "Unescapes the given key e.g.  foo\\\\.bar  =   foo.bar .  Syntax   Ractive.unescapeKey(key)   Arguments   key (string) : The key to unescape.   Returns   (string) : The unescaped key.   Examples  Ractive.unescapeKey('foo\\\\.bar'); // foo.bar", 
            "title": "Ractive.unescapeKey()"
        }, 
        {
            "location": "/legacy/0.9/api/#instance-properties", 
            "text": "", 
            "title": "Instance Properties"
        }, 
        {
            "location": "/legacy/0.9/api/#ractiveadaptors_1", 
            "text": "(Object string, Object )  The instance-only registry of adaptors.", 
            "title": "ractive.adaptors"
        }, 
        {
            "location": "/legacy/0.9/api/#ractivecomponents_1", 
            "text": "(Object string, Function )  The instance-only registry of components.", 
            "title": "ractive.components"
        }, 
        {
            "location": "/legacy/0.9/api/#ractivecontainer", 
            "text": "(Ractive)  Each component instance that is in a yielded fragment has a container instance that is accessible using  this.container .  foo \n   bar \n     baz / \n   /bar  /foo   If  bar   {{yield}} s, then  baz 's container will be the  foo  instance.", 
            "title": "ractive.container"
        }, 
        {
            "location": "/legacy/0.9/api/#ractivedecorators_1", 
            "text": "(Object string, Function )  The instance-only registry of decorators.", 
            "title": "ractive.decorators"
        }, 
        {
            "location": "/legacy/0.9/api/#ractiveeasing_1", 
            "text": "(Object string, Function )  The instance-only registry of easing functions.", 
            "title": "ractive.easing"
        }, 
        {
            "location": "/legacy/0.9/api/#ractiveevents_1", 
            "text": "(Object string, Function )  The instance-only registry of custom event plugins.", 
            "title": "ractive.events"
        }, 
        {
            "location": "/legacy/0.9/api/#ractiveinterpolators_1", 
            "text": "(Object string, Function )  A key-value hash of interpolators use by  ractive.animate()  or non-CSS transitions.", 
            "title": "ractive.interpolators"
        }, 
        {
            "location": "/legacy/0.9/api/#ractiveparent", 
            "text": "(Ractive)  Each component instance can access its parent using  this.parent .  foo \n   bar \n     baz / \n   /bar  /foo   baz 's parent is the  bar  instance, and  bar 's parent is the  foo  instance.", 
            "title": "ractive.parent"
        }, 
        {
            "location": "/legacy/0.9/api/#ractivepartials_1", 
            "text": "(Object string, string|Object|Function )  The instance-only registry of partials.", 
            "title": "ractive.partials"
        }, 
        {
            "location": "/legacy/0.9/api/#ractiveroot", 
            "text": "(Ractive)  Each component instance can access its root Ractive instance using  this.root .  foo \n   bar \n     baz / \n   /bar  /foo   foo ,  bar , and  baz  will all have the Ractive instance with this template as their  root .", 
            "title": "ractive.root"
        }, 
        {
            "location": "/legacy/0.9/api/#ractivetransitions_1", 
            "text": "(Object string, Function )  The instance-only registry of transitions.", 
            "title": "ractive.transitions"
        }, 
        {
            "location": "/legacy/0.9/api/#instance-methods", 
            "text": "", 
            "title": "Instance Methods"
        }, 
        {
            "location": "/legacy/0.9/api/#ractive95super", 
            "text": "Calls the parent method from a child method of the same name.  ractive._super()  is not always available. Only when Ractive detects its use does it make this reference to the parent method.  Syntax   ractive._super([arg[, ...argN]])   Arguments   [arg] (any) : One or more arguments to pass to the function.   Returns   (any) : Depends on the method called.   Examples   var Component = Ractive.extend({\n  oninit () {\n    console.log('super init')\n  }\n})\n\nvar SubComponent = Component.extend({\n  oninit () {\n    this._super()\n    console.log('sub init')\n  }\n})\n\nnew SubComponent()", 
            "title": "ractive._super()"
        }, 
        {
            "location": "/legacy/0.9/api/#ractiveadd", 
            "text": "Increments the selected keypath.  Syntax   ractive.add(keypath[, number])   Arguments   keypath (string) : The keypath of the number we're incrementing.  [number] (number) : The number to increment by. Defaults to  1 .   Returns   (Promise) : A promise that resolves when any transitions associated with the operation complete.   Examples   var r = Ractive({\n  el: '#main',\n  template: '#tpl',\n  data: {\n    counter: 0\n  }\n})\n\nsetTimeout(() =  {\n  r.add('counter')\n  console.log(r.get('counter'))\n}, 1000)\n\nsetTimeout(() =  {\n  r.add('counter', 10)\n  console.log(r.get('counter'))\n}, 2000)", 
            "title": "ractive.add()"
        }, 
        {
            "location": "/legacy/0.9/api/#ractiveanimate", 
            "text": "Similar to  ractive.set() , this will update the data and re-render any affected mustaches and notify observers.  All animations are handled by a global timer that is shared between Ractive instances (and which only runs if there are one or more animations still in progress), so you can trigger as many separate animations as you like without worrying about timer congestion. Where possible,  requestAnimationFrame  is used rather than  setTimeout .  Numeric values and strings that can be parsed as numeric values can be interpolated. Objects and arrays containing numeric values (or other objects and arrays which themselves contain numeric values, and so on recursively) are also interpolated.  Note that there is currently no mechanism for detecting cyclical structures! Animating to a value that indirectly references itself will cause an infinite loop.  Future versions of Ractive may include string interpolators - e.g. for SVG paths, colours, transformations and so on, a la D3 - and the ability to pass in your own interpolator.  If an animation is started on a keypath which is  already  being animated, the first animation is cancelled. (Currently, there is no mechanism in place to prevent collisions between e.g.  ractive.animate('foo', { bar: 1 })  and  ractive.animate('foo.bar', 0) .)  Syntax   ractive.animate(keypath, value[, options])   Arguments   keypath (string) : The keypath to animate.  value (number|string|Object|Array) : The value to animate to.  [options] (Object) :  [duration] (number) : How many milliseconds the animation should run for. Defaults to  400 .  [easing] (string|Function) : The name of an easing function or the easing function itself. Defaults to  linear .  [interpolator] (string) : The name of an interpolator function. Defaults to the built-in number interpolator if the value is numeric, or  null  if none is applicable.  [step] (Function) : A function called on each step of the animation.  t (number) : The animation progress between  0  and  1  with easing function already applied.  value (number) : The value at  t  with interpolator function already applied.    [complete] (Function) : A function to be called when the animation completes, with the  value  passed to  animate .     Returns   (Promise) : Returns a Promise which resolves with the target  value  and has an additional  stop  method, which cancels the animation.   Examples   var r = Ractive({\n  el: '#main',\n  template: '#tpl',\n  data: {\n    counter: 0\n  }\n})\n\nsetTimeout(() =  {\n  r.animate('counter', 20, { duration: 2000 })\n}, 1000)", 
            "title": "ractive.animate()"
        }, 
        {
            "location": "/legacy/0.9/api/#ractiveattachchild", 
            "text": "Creates a parent-child relationship between two Ractive instances. The child may be an instance of a component defined by  Ractive.extend() , but that is not a requirement, as children may be a plain Ractive instance created with  Ractive() .  Syntax  ractive.attachChild( child )\nractive.attachChild( child, options )  Arguments   child (Ractive instance) : The child instance to attach.  [options] (Object) :  target] (string) : An anchor name at which to render the instance. See [ Components . If the instance is already rendered, it will be unrendered and re-rendered at an appropriate anchor.  [append] (boolean) : Default  true  - add the instance to the end of the list for the targeted anchor.  [prepend] (boolean) : Add the instance to the beginning of the list for the targeted anchor.  [insertAt] (number) : Index at which to add the instance in the list for the targeted anchor.     When a child is attached to a parent, the child's  parent  property is updated in an observable way, so any references to  @this.parent  in the child will be notified of the change.  A child may be targeted to a  Components  when it is attached. If a child has no specified target, then it is responsible for managing its own render cycle. If a child does have a specified target, then the parent will manage rendering and unrendering the child as appropriate in the same way that a regular component has a managed render cycle.  When a child is attached targeting an anchor, only anchors that belong directly to the parent are considered as hosts. However, any element or component queries on the parent instance, including live queries, will consider the child when trying to match both elements and components. There is also an option on the query methods that allows querying remote, unmanaged instances, so that non-anchored children can also be queried for elements and components.  Returns   (Promise) : A  Promise  that resolves with the child instance when any transitions are complete.   Children can be detached using  ractive.detachChild() .  Examples  Example 1 : See the example for  Anchors", 
            "title": "ractive.attachChild()"
        }, 
        {
            "location": "/legacy/0.9/api/#ractivedetach", 
            "text": "Detaches the instance from the DOM, returning a document fragment. You can reinsert it, possibly in a different place, with  ractive.insert()  (note that if you are reinserting it immediately you don't need to detach it first - it will happen automatically).  Syntax   ractive.detach()   Arguments   None   Returns   (DocumentFragment) : A document fragment.   Examples   var r = Ractive({\n  el: '#main',\n  template: '#tpl',\n  data: {\n    counter: 0\n  }\n})\n\nsetTimeout(() =  {\n  var div = document.createElement('div')\n  div.appendChild(r.detach())\n  console.log(div.innerHTML)\n}, 1000)", 
            "title": "ractive.detach()"
        }, 
        {
            "location": "/legacy/0.9/api/#ractivedetachchild", 
            "text": "Detaches a child from an instance when it was previously attached with  ractive.attachChild() .  When a child instance that was attached targeting an anchor is detached, its instance is spliced out of the  @this.children.byName.anchorName  array so that subsequent children move forward to fill the void.  Syntax   ractive.detachChild( child )   Returns   (Promise) : A  Promise  that resolves with the child instance when any transitions are complete.   Examples  Example 1 : See the example for  Anchors", 
            "title": "ractive.detachChild()"
        }, 
        {
            "location": "/legacy/0.9/api/#ractivefind", 
            "text": "Returns the first element inside a given Ractive instance matching a CSS selector. This is similar to doing  this.el.querySelector(selector)  (though it doesn't actually use  querySelector() ).  Syntax   ractive.find(selector[, options])   Arguments   selector (string) : A CSS selector representing the element to find.  [options] (Object) :  remote (boolean} : Include attached children that are not rendered in anchors when looking for matching elements. Defaults to  false .     Returns   (Node) : A Node.   Examples   var r = Ractive({\n  el: '#main',\n  template: '#tpl'\n})\n\nsetTimeout(() =  {\n  var p = r.find('p.target')\n  console.log(p.outerHTML)\n}, 1000)", 
            "title": "ractive.find()"
        }, 
        {
            "location": "/legacy/0.9/api/#ractivefindall", 
            "text": "This method is similar to [ ractive.find() ]ractivefind), with an important difference - it returns a list of elements matching the selector, rather than a single node.  Syntax   ractive.findAll(selector[, options])   Arguments   selector (string) : A CSS selector representing the elements to find.  [options] (Object) :  remote (boolean) : Include attached children that are not rendered in anchors when searching for elements. Defaults to  false .     Returns   (Array Node ) : An array of nodes.   Examples   var r = Ractive({\n  el: '#main',\n  template: '#tpl'\n})\n\nsetTimeout(() =  {\n  var ps = r.findAll('p')\n  ps.forEach(function(p) {\n    console.log(p.outerHTML)\n  })\n}, 1000)", 
            "title": "ractive.findAll()"
        }, 
        {
            "location": "/legacy/0.9/api/#ractivefindallcomponents", 
            "text": "Returns all components inside a given Ractive instance with the given  name  (or all components of any kind if no name is given).  Syntax   ractive.findAllComponents([name[, options]])   Arguments   [name] (string) : The name of the component to find.  [options] (Object) :  remote (boolean) : Include attached children that are not rendered in anchors when searching components. Defaults to  false .     Returns   (Array ractive ) : An array of ractive instances.   Examples   var Component = Ractive.extend({\n  template: 'Component {{number}}'\n})\n\nvar r = Ractive({\n  el: '#main',\n  template: '#tpl',\n  components: {\n    Component: Component\n  }\n})\n\nsetTimeout(() =  {\n  var cs = r.findAllComponents('Component')\n  cs.forEach(function(c) {\n    console.log(c.toHTML())\n  })\n}, 1000)", 
            "title": "ractive.findAllComponents()"
        }, 
        {
            "location": "/legacy/0.9/api/#ractivefindcomponent", 
            "text": "Returns the first component inside a given Ractive instance with the given  name  (or the first component of any kind if no name is given).  Syntax   ractive.findComponent([name[, options]])   Arguments   [name] (string) : The name of the component to find.  [options] (Object) :  remote (boolean) : Include attached children that are not rendered in anchors when searching components. Defaults to  false .     Returns   (Ractive) : A ractive instance.   Examples   var Component = Ractive.extend({\n  template: 'Component {{number}}'\n})\n\nvar r = Ractive({\n  el: '#main',\n  template: '#tpl',\n  components: {\n    Component: Component\n  }\n})\n\nsetTimeout(() =  {\n  var c = r.findComponent('Component')\n  console.log(c.toHTML())\n}, 1000)", 
            "title": "ractive.findComponent()"
        }, 
        {
            "location": "/legacy/0.9/api/#ractivefindcontainer", 
            "text": "Returns the first container of this component instance with the given  name .  Syntax   ractive.findContainer(name)   Arguments   name (string) : The name of the container to find.   Returns   (Ractive) : Returns the first container of this component with the given  name .   Examples  // TODO", 
            "title": "ractive.findContainer()"
        }, 
        {
            "location": "/legacy/0.9/api/#ractivefindparent", 
            "text": "Returns the first parent of this component instance with the given  name .  Syntax   ractive.findParent(name)   Arguments   name (string) : The name of the parent to find.   Returns   (Ractive) : Returns the first parent of this component with the given  name .   Examples  // TODO", 
            "title": "ractive.findParent()"
        }, 
        {
            "location": "/legacy/0.9/api/#ractivefire", 
            "text": "Fires an event, which will be received by handlers that were bound using  ractive.on . In practical terms, you would mostly likely use this with  Ractive.extend() , to allow applications to hook into your subclass.  Syntax   ractive.fire(eventName[, context [, arg1[, ...argN]]])   Arguments   name (string) : The name of the event.  [context] (context|object) : A context object to use for the event or an object with properties to assign to a new context object. If you need to pass arguments but don't need to provide context, pass an empty object ( {} ) before the additional arguments.  From   0.9.4 , if you want to reuse a context exactly as it exists, it should have a  refire  property that is  === true .  [arg] (any) : The arguments that event handlers will be called with.   Returns   (boolean)   Examples   var r = Ractive()\n\nr.on('foo', () =  {\n  console.log('foo fired')\n})\n\nr.fire('foo')", 
            "title": "ractive.fire()"
        }, 
        {
            "location": "/legacy/0.9/api/#ractiveget", 
            "text": "Returns the value at  keypath .  Syntax   ractive.get([keypath][, options])   Arguments   [keypath] (string) : The keypath of the data to retrieve. If omitted, returns a shallow copy of the instance's data.  [options] (Object) : An options hash that may contain:  virtual (boolean) : When set to  false , excludes virtual keypaths (computations, links, mappings, etc.). Defaults to  true  for the root keypath and  false  for keypaths other than the root.  unwrap (boolean) : When set to  false , returns the adapted value of the data if an adaptor was applied. Defaults to  true .     Returns   (any) : Returns the data that exists at the given keypath, or the root data if no keypath is given.   Examples   var r = Ractive({\n  data: {\n    foo: {\n      bar: [ 'baz' ]\n    }\n  }\n})\n\nconsole.log(r.get('foo.bar.0'))   var r = new Ractive({\n  data : {\n    name :  Herbert \n  },\n  computed : {\n    foo  () {\n      return 55\n    }\n  }\n})\n\nconsole.log(r.get()) // =  {name :  Herbert , foo : 55}\n\nconsole.log(r.get({virtual : false})) // =  {name :  Herbert }", 
            "title": "ractive.get()"
        }, 
        {
            "location": "/legacy/0.9/api/#ractivegetcontext_1", 
            "text": "This is an instance specific version of  Ractive.getContext()  that will only search the local instance DOM for a matching node when a selector is given. If the given value is not a string, then it is passed directly through to the static version of this method.  Syntax   ractive.getContext(node)   Arguments   node (string|Node) : The DOM node or a CSS selector of a target node for which you wish to retrieve the Ractive instance or view details.   Returns   (Context) : Returns an Context object with helper methods to interact with the Ractive instance and context associated with the given node.   Examples  // TODO", 
            "title": "ractive.getContext()"
        }, 
        {
            "location": "/legacy/0.9/api/#ractiveinsert", 
            "text": "Inserts the instance to a different location. If the instance is currently in the DOM, it will be detached first. See also  ractive.detach() .  Syntax   ractive.insert(target[, anchor])   Arguments   target (string|Node|array-like) : The new parent element.  [anchor] (string|Node|array-like) : The sibling element to insert the instance before. If omitted, the instance will be inserted as the last child of the parent.   Returns   (undefined)   Examples   Ractive.components.aaa = Ractive.extend({\n    template:  button {{yield}} /button \n})\n\nRactive({\n    ...\n    template: `\n         button on-click= move teleport /button \n         button on-click= restore restore /button \n\n         div id= container1  style= border: 2px solid yellow; min-height: 50px \n             aaa hello /aaa \n         /div \n\n         div id= container2  style= border: 1px solid red; min-height: 50px \n\n         /div \n    `,\n    on: {\n        move () {\n          const aaa = this.findComponent('aaa')\n          const target = this.find('#container2')\n          aaa.insert(target)\n        },\n        restore () {\n          const aaa = this.findComponent('aaa')\n          const target = this.find('#container1')\n          aaa.insert(target)\n        }\n    }\n})", 
            "title": "ractive.insert()"
        }, 
        {
            "location": "/legacy/0.9/api/#ractivelink", 
            "text": "Creates a link between two keypaths that keeps them in sync. Since Ractive can't always watch the contents of objects, copying an object to two different keypaths in your data usually leads to one or both of them getting out of sync.  link  creates a sort of symlink between the two paths so that Ractive knows they are actually the same object. This is particularly useful for master/detail scenarios where you have a complex list of data and you want to be able to select an item to edit in a detail form.  Syntax   ractive.link(source, destination, options)   Arguments   source (string) : The keypath of the source item.  destination (string) : The keypath to use as the destination - or where you'd like the data 'copied'.  options (hash) :  instance  or  ractive : The Ractive instance in which to find the source keyapth. This allows cross-instance linking much like mapped paths between components.  keypath :  from   0.9.4  - The keypath to register as the source of the link. This is an advanced option that allows you to specify how the link should shuffle. For instance  items.0.name  will never shuffle, but if the keypath is specified as  .name , then it will shuffle when  items.0  shuffles.   Returns   (Promise) : Returns a promise.   Examples  ractive.link( 'some.nested.0.list.25.item', 'current' )\nractive.set( 'current.name', 'Rich' ); // some.nested.0.list.25.item.name is also updated to be 'Rich'  This can be used to great effect with method events and the  @keypath  special ref:  {{#each some.nested}}\n  {{#each list}}\n    {{#with item}}\n      {{.name}}\n       button on-click= event.link('.', 'current') Select /button \n    {{/with}}\n  {{/each}}\n{{/each}}\n\nName:  input value= {{~/current.name}}  /   Links can be removed using  ractive.unlink() .", 
            "title": "ractive.link()"
        }, 
        {
            "location": "/legacy/0.9/api/#ractiveobserve", 
            "text": "Observes the data at a particular keypath. Unless specified otherwise, the callback will be fired immediately, with  undefined  as  oldValue . Thereafter it will be called whenever the  observed keypath  changes.  Syntax   ractive.observe(keypath, callback[, options])  ractive.observe(map[, options])   Arguments    keypath (String) : The keypath to observe, or a group of space-separated keypaths. Any of the keys can be a  *  character, which is treated as a wildcard. A  **  means recursive.  The difference between  *  and  **  is that  *  provides your callback function  value  and  keypath  arguments containing the path of the what actually changed, at any level of the keypath. So instead of getting the same parent value on every change, you get the changed value from whatever arbitrarily deep keypath changed.    callback (Function) : The function that will be called, with  newValue ,  oldValue  and  keypath  as arguments (see Observers for more nuance regarding these arguments), whenever the observed keypath changes value. By default the function will be called with  ractive  as  this . Any wildcards in the keypath will have their matches passed to the callback at the end of the arguments list as well.   map (Object) : A map of keypath-observer pairs.  [options] (Object) :  [init] (boolean) : Defaults to  true . Whether or not to initialise the observer, i.e. call the function with the current value of  keypath  as the first argument and  undefined  as the second.  [defer] (boolean) : Defaults to  false , in which case observers will fire before any DOM changes take place. If  true , the observer will fire once the DOM has been updated.  links] (boolean) : Defaults to  false .  Whether or not the observer should \"follow through\" any links created with [ ractive.link() .  [strict] (boolean) : Defaults to  false .  strict  uses object identity to determine if there was a change, meaning that unless the primary object changed, it won't trigger the observer. For example with  { data: { foo: { bar: 'baz' } } } ,  ractive.observe('foo', ..., { strict: true })  will not fire on  ractive.set('foo.bar', 'bat')  but will on  ractive.set('foo', { bar: 'bip' }) .  [context] (any) : Defaults to  ractive . The context the observer is called in (i.e. the value of  this )  [array] (boolean) : Defaults to  false . Whether or not to observe the keypath as an array, meaning that change events will fire with a object containing two lists,  inserted  containing added elements, and  deleted  containing removed elements. There is also a  start  integer property indicating the index at which the replacements begin.  [old] (function) : Defaults to  undefined . A function that can be used to modify the  old  value passed to the observer callback. This can be used to freeze the old value, create a deep clone of it for future firings, etc.     Returns   (Object) : A handle object for controlling any observers created by the call to  observe  cancel : Permanently stops observers controlled by the handle.  isSilenced : Returns  true  if this handle is currently silenced.  silence : Stop calling callbacks associated with this handle. The observers are still processed by Ractive, so the old value will still be updated. This means that setting a new value on an observer while it is silenced, resuming the observer, and then setting the same value again will  not  result in the callback being fired if it would not be fired by the same sequence without silencing.  resume : Resume calling callbacks associated with this handle.     Examples  // TODO  Note that you can observe keypath  patterns ...  ractive.observe( 'items.*.status', function ( newValue, oldValue, keypath) {\n  var index = /items.(\\d+).status/.exec( keypath )[1]\n  alert( 'item ' + index + ' status changed from ' + oldValue + ' to ' + newValue )\n})  ...or multiple space-separated keypaths simultaneously:  ractive.observe( 'foo bar baz', function ( newValue, oldValue, keypath ) {\n  alert( keypath ) + ' changed from ' + oldValue + ' to ' + newValue )\n})  See Observers for more detail.", 
            "title": "ractive.observe()"
        }, 
        {
            "location": "/legacy/0.9/api/#ractiveobserveonce", 
            "text": "Observes the data at a particular keypath until the first change. After the handler has been called, it will be unsubscribed from any future changes.  Syntax   ractive.observeOnce(keypath, callback[, options])   Arguments   keypath (string) : The keypath to observe, or a group of space-separated keypaths. Any of the keys can be a `` character, which is treated as a wildcard.  callback (Function) : The function that will be called, with  newValue ,  oldValue  and  keypath  as arguments (see Observers for more nuance regarding these arguments), whenever the observed keypath changes value. By default the function will be called with  ractive  as  this . Any wildcards in the keypath will have their matches passed to the callback at the end of the arguments list as well.  [options] (Object) :  [defer] (boolean) : Defaults to  false , in which case observers will fire before any DOM changes take place. If  true , the observer will fire once the DOM has been updated.  [context] (any) : Defaults to  ractive . The context the observer is called in (i.e. the value of  this )     Returns   (Object) : An object with a  cancel  method, for cancelling the observer.   Examples  // TODO  Note that you can observe keypath  patterns ...  ractive.observeOnce( 'items.*.status', function ( newValue, oldValue, keypath ) {\n  var index = /items.(\\d+).status/.exec( keypath )[1]\n  alert( 'item ' + index + ' status changed from ' + oldValue + ' to ' + newValue )\n})  ...or multiple space-separated keypaths simultaneously:  ractive.observeOnce( 'foo bar baz', function ( newValue, oldValue, keypath ) {\n  alert( keypath + ' changed from ' + oldValue + ' to ' + newValue )\n})  See Observers for more detail.", 
            "title": "ractive.observeOnce()"
        }, 
        {
            "location": "/legacy/0.9/api/#ractiveoff", 
            "text": "Removes an event handler, several event handlers, or all event handlers.  To remove a single handler, you must specify both the event name and the handler. If you only specify the event name, all handlers bound to that event name will be removed. If you specify neither event name nor handler,  all  event handlers will be removed.  An alternative way to remove event handlers is to use the  cancel  method of the return value of a call to  ractive.on() .  Syntax   ractive.off([eventName[, handler]])   Arguments   eventName (string) : The event name to which this handler is currently bound.  handler (Function) : The handler to remove.   Returns   (Ractive) : Returns the  ractive  instance to allow this call to be chainable.   Examples  // TODO", 
            "title": "ractive.off()"
        }, 
        {
            "location": "/legacy/0.9/api/#ractiveon", 
            "text": "Subscribe to events.  Syntax   ractive.on(eventName, handler)  ractive.on(obj)   Arguments   eventName (String) : The name of the event to subscribe to  handler (Function) : The function that will be called, with  ractive  as  this . The arguments depend on the event, but the first argument is always a context object. Returning  false  from the handler will stop propagation and prevent default of DOM events and cancel event bubbling.  obj (Object) : An object with keys named for each event to subscribe to. The value at each key is the handler function for that event.   Returns   (Object) : A handle object for controlling any listners created by the call to  on  cancel : Permanently stops listeners controlled by the handle.  isSilenced : Returns  true  if this handle is currently silenced.  silence : Stop calling callbacks associated with this handle.  resume : Resume calling callbacks associated with this handle.     Examples  // single handler to function\nractive.on( 'activate', function () {...})\n\n// wildcard pattern matching\nractive.on( 'foo.*', function () {...} )\n\n// multiple handlers to one function\nractive.on( 'activate select', function () {...} )\n\n// map of handler/function pairs\nractive.on({\n  activate () {...},\n  select () {...}\n})\n\n// knock yourself out:\nractive.on({\n  activate () {...},\n  'bip bop boop' () {...},\n  'select foo.* bar' () {...}\n})", 
            "title": "ractive.on()"
        }, 
        {
            "location": "/legacy/0.9/api/#ractiveonce", 
            "text": "Subscribe to an event for a single firing. This is a convenience function on top of  ractive.on() .  Syntax   ractive.once(eventName, handler)   Arguments   eventName (string) : The name of the event to subscribe to.  handler (Function) : The function that will be called, with  ractive  as  this . The arguments depend on the event, but the first argument is always a context object. Returning  false  from the handler will stop propagation and prevent default of DOM events and cancel event bubbling.   Returns   (Object) : Returns an  Object  with a  cancel  method, which removes the handler.   Examples  // TODO", 
            "title": "ractive.once()"
        }, 
        {
            "location": "/legacy/0.9/api/#ractivepop", 
            "text": "The Ractive equivalent to  Array.pop  that removes an element from the end of the array at the given keypath and triggers an update event.  If the given keypath does not exist (is  undefined ), an empty array will be supplied instead. Otherwise, if the given keypath does not resolve to an array, an error will be thrown.  Syntax   ractive.pop(keypath)   Arguments   keypath (string) : The keypath of the array to change, e.g.  list  or  order.items .   Returns   (Promise) : Returns a promise that will resolve with the removed element after the update is complete.   Examples  // TODO", 
            "title": "ractive.pop()"
        }, 
        {
            "location": "/legacy/0.9/api/#ractivepush", 
            "text": "The Ractive equivalent to  Array.push  that appends one or more elements to the array at the given keypath and triggers an update event.  If the given keypath does not exist (is  undefined ), an empty array will be supplied instead. Otherwise, if the given keypath does not resolve to an array, an error will be thrown.  Syntax   ractive.push(keypath, value[, ...valueN])   Arguments   keypath (string) : The keypath of the array to change, e.g.  list  or  order.items .  value (any) : The value to append to the end of the array. One or more values may be supplied.   Returns   (Promise)  - Returns a Promise that will resolve after the update is complete.   Examples  // TODO", 
            "title": "ractive.push()"
        }, 
        {
            "location": "/legacy/0.9/api/#ractivereadlink", 
            "text": "Gets the source keypath and instance for a link.  Syntax   ractive.readLink(link[, options])   Arguments   link (string) : The keypath for the link that you would like to read.  options (Object) :  [canonical] (boolean) : Whether or not to read through any intermediate links too. Pass  canonical: true  to read through links to links all the way to the canonical data keypath. Defaults to  false .     Returns   (Object) :  keypath (string) : The source keypath to which the link points.  ractive (Ractive) : The source Ractive instance that contains the keypath to which the link points.     Examples  const r = Ractive({\n  data: {\n    items: [\n      { name: 'Apple' },\n      { name: 'Banana' },\n      { name: 'Orange' }\n    ]\n  }\n})\n\nr.link( 'items.0', 'currentItem' )\n\nr.readLink( 'currentItem' )\n// returns { ractive: r, keypath: 'items.0' }", 
            "title": "ractive.readLink()"
        }, 
        {
            "location": "/legacy/0.9/api/#ractiverender", 
            "text": "Renders the component into a DOM element.  Syntax   ractive.render(target)   Arguments   target (Node|String|array-like) : The DOM element to render to.   Returns   (Promise) : A promise that resolves when rendering completes or when the instance is already rendered.   Examples  // TODO", 
            "title": "ractive.render()"
        }, 
        {
            "location": "/legacy/0.9/api/#ractivereset", 
            "text": "Resets the entire  ractive.data  object and updates the DOM.  Syntax   ractive.reset(data)   Arguments   data (Object) : The data to reset with. Defaults to  {} .   Returns   (Promise) : A promise.   Examples  This differs from  ractive.set()  in the following way:  ractive = Ractive({\n  // ...,\n  data: { foo: 1 }\n})\n\nractive.set({ bar: 2 })\nconsole.log( ractive.get() ); // { foo: 1, bar: 2 }\n\nractive.reset({ bar: 2 })\nconsole.log( ractive.get() ); // { bar: 2 }", 
            "title": "ractive.reset()"
        }, 
        {
            "location": "/legacy/0.9/api/#ractiveresetpartial", 
            "text": "Resets a partial and re-renders all of its use-sites, including in any components that have inherited it. If a component has a partial with a same name that is its own, that partial will not be affected.  Inline partials that don't belong directly to a Ractive instance aren't affected by  resetPartial .  Syntax   ractive.resetPartial(name, partial)   Arguments   name (string) : The partial to reset.  partial (string|Object|Function) : A template string, pre-parsed template or a function that returns either.   Returns   (Promise) : A promise.   Examples  ractive = Ractive({\n  // ...,\n  partials: { foo: 'foo' }\n})\n\n// {{ foo}} will be replaced with 'foo'\n\nractive.resetPartial('foo', 'bar')\n\n// {{ foo}} will be replaced with 'bar'", 
            "title": "ractive.resetPartial()"
        }, 
        {
            "location": "/legacy/0.9/api/#ractiveresettemplate", 
            "text": "Resets the template and re-renders the entire instance using the new template.  Syntax   ractive.resetTemplate(template)   Arguments   template (string|Object) : The new template to use. If an object, the template should be the result of  Ractive.parse  with both version and template array properties.   Returns   (Promise) : A promise that resolves once any transitions that are triggered during the re-render are completed.   Examples  const ractive = new Ractive({\n  // ...,\n  template: 'replace me'\n});\n\nractive.resetTemplate('you have been replaced');\nractive.set('foo', 'world');\nractive.resetTemplate(Ractive.parse('Hello, {{foo}}'));", 
            "title": "ractive.resetTemplate()"
        }, 
        {
            "location": "/legacy/0.9/api/#ractivereverse", 
            "text": "The Ractive equivalent to  Array.reverse  reverses the array at the given keypath and triggers an update event.  If the given keypath does not resolve to an array, an error will be thrown.  Syntax   ractive.reverse(keypath)   Arguments   keypath (String) : The keypath of the array to reverse, e.g.  list  or  order.items   Returns   (Promise)  - A promise that will resolve after the update is complete.   Examples  // TODO", 
            "title": "ractive.reverse()"
        }, 
        {
            "location": "/legacy/0.9/api/#ractiveset", 
            "text": "Updates data and triggers a re-render of any mustaches that are affected (directly or indirectly) by the change. Any observers of affected keypaths will be notified.  When setting an array value, ractive will reuse the existing DOM nodes for the new array, adding or removing nodes as necessary. This can impact nodes with transitions. Use the  shuffle  option for setting a new array value while retaining existing nodes corresponding to individual array item values.  Syntax   ractive.set(keypath, value[, options])  ractive.set(map[, options])   Arguments   keypath (string) : The keypath of the data we're changing, e.g.  user  user.name  user.friends[1]  or  user.friends.1  users.*.status  images.aaa\\\\.jpg.url .    value (any) : The value we're changing it to. Can be a primitive or an object (or array), in which case dependants of  downstream keypaths  will also be re-rendered (if they have changed).  map (Object) : A map of  keypath: value  pairs, as above.  [options] Object :  deep (boolean) : Whether or not to perform a deep set on with the data at the given keypath. A deep set recursively merges the given data into the data structure at the given keypath. Defaults to  false .  shuffle (boolean|string|Function) : Whether or not to add/move/remove DOM associated with elements rather than just re-using the existing DOM. Defaults to  false .  true : Add/move/remove existing items to their new index using a strict equality comparison.  string : Add/move/remove existing items to their new index using a property comparison where the property compared is named by the given string.  Function : Add/move/remove existing items to their new index using the value returned by the given function for comparison.    keep (boolean) : Whether or not to keep the virtual DOM that would be disposed by the  set  operation. This is useful for hiding components without completely tearing them down and recreating them. It's also a little bit faster, as the virtual DOM doesn't have to be recreated when it would reappear. When the virtual DOM is re-rendered, it will also us the progressive enhancement process to reuse the existing DOM nodes that were detached originalls. Defaults to  false .     Returns   (Promise) : Returns a promise that will resolved after any transitions associated with the operation are complete.   Examples  // TODO  The  keypath  can also contain wildcards pattern-observers. All matching keypaths will be set with the supplied values:  ractive.on('selectAll', function () {\n  ractive.set('items.*.selected', true)\n})  See Also   Ractive.escapeKey()", 
            "title": "ractive.set()"
        }, 
        {
            "location": "/legacy/0.9/api/#ractiveshift", 
            "text": "The Ractive equivalent to  Array.shift  that removes an element from the beginning of the array at the given keypath and triggers an update event.  If the given keypath does not exist (is  undefined ), an empty array will be supplied instead. Otherwise, if the given keypath does not resolve to an array, an error will be thrown.  Syntax   ractive.shift(keypath)   Arguments   keypath (string) : The keypath of the array to change, e.g.  list  or  order.items .   Returns   (Promise) : A promise that will resolve with the removed element after the update is complete.   Examples  // TODO", 
            "title": "ractive.shift()"
        }, 
        {
            "location": "/legacy/0.9/api/#ractivesort", 
            "text": "The Ractive equivalent to  Array.sort  sorts the array at the given keypath and triggers an update event.  If the given keypath does not resolve to an array, an error will be thrown.  Syntax   ractive.sort(keypath[, compareFunction])   Arguments   keypath (string) : The keypath of the array to sort, e.g.  list  or  order.items .  compareFunction (Function) : A function that defines the sort order.   Returns   (Promise) : Returns a promise that will resolve after the update is complete.   Examples  // TODO", 
            "title": "ractive.sort()"
        }, 
        {
            "location": "/legacy/0.9/api/#ractivesplice", 
            "text": "The Ractive equivalent to  Array.splice  that can add new elements to the array while removing existing elements.  If the given keypath does not exist (is  undefined ), an empty array will be supplied instead. Otherwise, if the given keypath does not resolve to an array, an error will be thrown.  Syntax   ractive.splice(keypath, index, [removeCount[, add]])   Arguments   keypath (string) : The keypath of the array to change, e.g.  list  or  order.items .  index (number) : The index at which to start the operation.  [removeCount] (number) : The number of elements to remove starting with the element at * index . This may be 0 if you don't want to remove any elements.  [add] (any) : Any elements to insert into the array starting at * index . There can be 0 or more elements passed to add to the array.   Returns   (Promise) : Returns a promise that will resolve with the removed elements after the update is complete.   Examples  // TODO", 
            "title": "ractive.splice()"
        }, 
        {
            "location": "/legacy/0.9/api/#ractivesubtract", 
            "text": "Decrements the selected keypath.  Syntax   ractive.subtract(keypath[, number])   Arguments   keypath (string) : The keypath of the number we're decrementing.  [number] (number) : Defaults to  1 . The number to decrement by.   Returns   (Promise) : Returns a promise.   Examples  // TODO", 
            "title": "ractive.subtract()"
        }, 
        {
            "location": "/legacy/0.9/api/#ractiveteardown", 
            "text": "Unrenders this Ractive instance, removing any event handlers that were bound automatically by Ractive.  Calling  ractive.teardown()  causes a  teardown  event to be fired - this is most useful with  Ractive.extend()  as it allows you to clean up anything else (event listeners and other bindings) that are part of the subclass.  Syntax   ractive.teardown()   Arguments   None   Returns   (Promise) : A promise.   Examples  // TODO", 
            "title": "ractive.teardown()"
        }, 
        {
            "location": "/legacy/0.9/api/#ractivetocss", 
            "text": "Returns the scoped CSS of the current instance and its descendants.  At the moment, this will not work on a direct instance of Ractive and will log a warning. You can only use this method on an instance of a subclass.  Syntax   ractive.toCSS()   Arguments   None   Returns   (string) : The scoped CSS of the instance.   Examples  const Subclass = Ractive.extend({\n    ...\n    css: 'div{ color: red }'\n    ...\n})\n\nconst subclassInstance = Subclass({...})\n\n// Contains the scoped version of div{ color: red }\nsubclassInstance.toCSS()", 
            "title": "ractive.toCSS()"
        }, 
        {
            "location": "/legacy/0.9/api/#ractivetohtml", 
            "text": "Returns a chunk of HTML representing the current state of the instance. This is most useful when you're using Ractive in node.js, as it allows you to serve fully-rendered pages (good for SEO and initial pageload performance) to the client.  Syntax   ractive.toHTML()   Arguments   None   Returns   (string) : The instance HTML.   Examples  // TODO", 
            "title": "ractive.toHTML()"
        }, 
        {
            "location": "/legacy/0.9/api/#ractivetoggle", 
            "text": "Toggles the selected keypath. In other words, if  foo  is truthy, then  ractive.toggle('foo')  will make it  false , and vice-versa.  Syntax   ractive.toggle(keypath)   Arguments   keypath (string) : The keypath to toggle the value of. If  keypath  is a pattern, then all matching keypaths will be toggled.   Returns   (Promise) : A promise.   Examples  // TODO", 
            "title": "ractive.toggle()"
        }, 
        {
            "location": "/legacy/0.9/api/#ractivetransition", 
            "text": "Triggers a transition on a node managed by this Ractive instance.  Syntax   ractive.transition(transition, node, options)   Arguments   transition (string|Function) : A transition function or a name of a transition function.  node (HTMLElement) : The node on which to start the transition - optional if called from within a Ractive event handler, as it will be retrieved from the event if not supplied.  options (Object) : Options supplied to the transition.   Returns   (Promise) : A promise that resolves when the transition completes.   Examples  // TODO", 
            "title": "ractive.transition()"
        }, 
        {
            "location": "/legacy/0.9/api/#ractiveunlink", 
            "text": "Removes a link set up by  ractive.link() .  Syntax   ractive.unlink(destination)   Arguments   destination (string) : The destination supplied to [ ractive.link() ].   Returns   (Promise) : A promise.   Examples  // TODO", 
            "title": "ractive.unlink()"
        }, 
        {
            "location": "/legacy/0.9/api/#ractiveunrender", 
            "text": "Unrenders this Ractive instance, throwing away any DOM nodes associated with this instance. This is the counterpart to  ractive.render() . The rest of the ractive instance is left intact, unlike  ractive.teardown() .  Note that if the instance happens to be a component that is managed by another instance, the owning instance may veto the call to  unrender . If you need more precise control over component rendering, you should probably use an anchor and  ractive.attachChild()  instead.  Syntax   ractive.unrender()   Arguments   None   Returns   (Promise) : A promise.   Examples  // TODO", 
            "title": "ractive.unrender()"
        }, 
        {
            "location": "/legacy/0.9/api/#ractiveunshift", 
            "text": "The Ractive equivalent to  Array.unshift  that prepends one or more elements to the array at the given keypath and triggers an update event.  If the given keypath does not exist (is  undefined ), an empty array will be supplied instead. Otherwise, if the given keypath does not resolve to an array, an error will be thrown.  Syntax   ractive.unshift(keypath, value)   Arguments   keypath (string) : The keypath of the array to change, e.g.  list  or  order.items .  value (any) : The value to prepend to the beginning of the array. One or more values may be supplied.   Returns   (Promise) : Returns a promise that will resolve after the update is complete.   Examples  // TODO", 
            "title": "ractive.unshift()"
        }, 
        {
            "location": "/legacy/0.9/api/#ractiveupdate", 
            "text": "\"Dirty checks\" everything that depends directly or indirectly on the specified keypath. If no  keypath  is specified, all keypaths will be checked. Keypaths that involve special references (i.e.  @global ) require the keypath to be supplied.  This is useful when manipulating the instance's data without using the built in setter methods (i.e.  ractive.set() ,  ractive.animate() ).  Syntax   ractive.update([keypath][, options])   Arguments   [keypath] (string) : The keypath to treat as 'dirty'.  [options] (Object string, any ) :  force (boolean) : Force an update regardless of whether or not the internal change check determines that the keypath has  actually  changed. This is useful for forcing all expressions referencing a particular function to recompute.     Returns   (Promise) : A promise that resolves when any transitions associated with the operation complete.   Examples  ractive.observe( 'foo', function ( foo ) {\n  alert( foo )\n})\n\nmodel.foo = 'changed';   // Does not cause the instance to update.\nractive.update( 'foo' ); // Informs the instance that foo was changed externally.", 
            "title": "ractive.update()"
        }, 
        {
            "location": "/legacy/0.9/api/#ractiveupdatemodel", 
            "text": "If you programmatically manipulate inputs and other elements that have two\u2010way binding set up, your model can get out of sync. In these cases, we need to force a resync with  ractive.updateModel() :  Syntax   ractive.updateModel([keypath[, cascade]])   Arguments   keypath (string) : The keypath to treat as 'dirty'. Any two-way bindings linked to this keypath will be checked to see if the model is out of date  cascade (boolean) : If true, bindings that are  downstream  of  keypath  will also be checked - e.g.  ractive.updateModel( 'items', true )  would check  items.0.foo  and  items.1.foo  and so on. Defaults to  false .   Returns   (Promise) : A promise. If a  keypath  is not specified, all two-way bindings will be checked.   Examples  ractive = Ractive({\n  el: 'container',\n  template: ' input value= {{name}} '\n  data: { name: 'Bob' }\n})\n\nractive.find( 'input' ).value = 'Jim'\nalert( ractive.get( 'name' ) ); // alerts 'Bob', not 'Jim'\n\nractive.updateModel()\nalert( ractive.get( 'name' ) ); // alerts 'Jim'", 
            "title": "ractive.updateModel()"
        }, 
        {
            "location": "/legacy/0.9/api/#context-object", 
            "text": "The context object is the type of object you receive when calling getContext(). This object contains various properties and methods that allow you to interact with and obtain information about the Ractive instance, the node associated with it and the context surrounding it.  The special  @context  reference is also a context object that is associated with the nearest VDOM item and element. It's frequently used with event directives to interact with the data associated with the immediate context.  Helper methods that take a keypath will resolve relative to that node's context. Special references, template aliases, and key and index aliases are supported. If the method doesn't require a keypath, like  get , then the keypath will implicitly be  .  rather than  ~/ , as with regular instance methods.", 
            "title": "Context Object"
        }, 
        {
            "location": "/legacy/0.9/api/#contextadd", 
            "text": "See ractive.add().", 
            "title": "context.add()"
        }, 
        {
            "location": "/legacy/0.9/api/#contextanimate", 
            "text": "See ractive.animate().", 
            "title": "context.animate()"
        }, 
        {
            "location": "/legacy/0.9/api/#contextdecorators", 
            "text": "(Object)  A map of decorator name to decorator return object for all of the decorators on the node associated with the context.", 
            "title": "context.decorators"
        }, 
        {
            "location": "/legacy/0.9/api/#contextevent", 
            "text": "(Event|undefined)  The original event for contexts supplied to event directives. This is  undefined  for contexts not associated with an event.", 
            "title": "context.event"
        }, 
        {
            "location": "/legacy/0.9/api/#contextget", 
            "text": "See ractive.get().", 
            "title": "context.get()"
        }, 
        {
            "location": "/legacy/0.9/api/#contextgetbinding", 
            "text": "Returns the value of the binding if the node represented by this info object has a two-way binding.  Syntax   context.getBinding()   Arguments   None   Returns   (any) : The value of the binding.   Examples  {{#with foo.bar}} input id= findMe  value= {{.baz}}  / {{/with}}  Ractive.getContext('#findMe').getBinding(); // returns value of foo.bar.baz", 
            "title": "context.getBinding()"
        }, 
        {
            "location": "/legacy/0.9/api/#contextgetbindingpath", 
            "text": "Returns the keypath of the binding if the node represented by this info object has a two-way binding.  Syntax   context.getBindingPath([ractive])   Arguments   [ractive] (Ractive) : The instance to resolve the keypath against.   Returns   (string) : The keypath of the node binding.   Examples  {{#with foo.bar}} input id= findMe  value= {{.baz}}  / {{/with}}  Ractive.getContext('#findMe').getBindingPath(); // Returns  foo.bar.baz", 
            "title": "context.getBindingPath()"
        }, 
        {
            "location": "/legacy/0.9/api/#contextgetparent", 
            "text": "From   0.9.4  Gets the parent context of this context. This is finer grained than element access provided by  Ractive.getContext , as it can target sections that exist nested between elements.  Syntax   context.getParent(crossComponentBoundary)   Arguments   crossComponentBoundary (boolean) : Whether or not to cross into the context containing a component. Defaults to  false .   Returns   (context) : The parent context object.   Examples  div {{#with foo.bar}}{{#with .baz}} span / {{/with}}{{/with}} /div   const ctx = Ractive.getContext('span')\nctx.resolve(); // foo.bar.baz\nconst parent = ctx.getParent()\nparent.resolve(); // foo.bar", 
            "title": "context.getParent()"
        }, 
        {
            "location": "/legacy/0.9/api/#contexthaslistener", 
            "text": "Returns  true  if the element associated with the context has a Ractive-managed event listener for a given event name. The target event does not have to be an actual DOM event, so this method can be used conveniently in conjunction with  context.raise .  Syntax   context.hasListener(event[, bubble])   Arguments   event (string) : The name of the event for which to check for listeners.  bubble (boolean) : Whether or not to check parent elements for the event name as well, should the target element not have a listener. Defaults to  false .   Returns   (boolean) :  true  if a listener was found or  false  otherwise.   Examples  section on-other= othered \n   article on-thing= thinged Some text... /article  /section   const ctx = ractive.getContext('article');\nctx.hasListener('thing'); // true\nctx.hasListener('other'); // false\nctx.hasListener('other', true); // true", 
            "title": "context.hasListener()"
        }, 
        {
            "location": "/legacy/0.9/api/#contextisbound", 
            "text": "Returns  true  if the node represented by this info object has a two-way binding.  Syntax   context.isBound()   Arguments   None   Returns   (boolean) :  true  if the node represented has a two-way binding.   Examples  {{#with foo.bar}}\n   input id= foo  value= {{.baz}}  / \n   input id= bar  value=  / \n{{/with}}  Ractive.getContext('#foo').isBound(); // Returns true\nRactive.getContext('#bar').isBound(); // Returns false", 
            "title": "context.isBound()"
        }, 
        {
            "location": "/legacy/0.9/api/#contextlink", 
            "text": "See ractive.link().", 
            "title": "context.link()"
        }, 
        {
            "location": "/legacy/0.9/api/#contextlisten", 
            "text": "Subscribes an event listener either directly on the node associated with the context or as a delegate if appropriate. This is not like the  on  method, but is instead basically an  addEventListener  helper that is delegation-aware.  Syntax  context.listen( event, callback )  Arguments   event (string) : The name of the event to subscribe.  callback (function) : The callback function to be called when the event fires.   Returns   (Object) : An object with a  cancel  method to unlisten the event.", 
            "title": "context.listen()"
        }, 
        {
            "location": "/legacy/0.9/api/#contextnode", 
            "text": "(Node|undefined)  The node associated with the context. Note that it is possible to get a context that is not associated with an element, which will leave the node  undefined .", 
            "title": "context.node"
        }, 
        {
            "location": "/legacy/0.9/api/#contextobserve", 
            "text": "See ractive.observe().", 
            "title": "context.observe()"
        }, 
        {
            "location": "/legacy/0.9/api/#contextobserveonce", 
            "text": "See ractive.observeOnce().", 
            "title": "context.observeOnce()"
        }, 
        {
            "location": "/legacy/0.9/api/#contextoriginal", 
            "text": "(Event|undefined)  The original DOM event object. Normally present when the event is a Ractive DOM event. May be  undefined  on custom events or events from event plugins.", 
            "title": "context.original"
        }, 
        {
            "location": "/legacy/0.9/api/#contextpop", 
            "text": "See ractive.pop().", 
            "title": "context.pop()"
        }, 
        {
            "location": "/legacy/0.9/api/#contextpush", 
            "text": "See ractive.push().", 
            "title": "context.push()"
        }, 
        {
            "location": "/legacy/0.9/api/#contextractive", 
            "text": "(Ractive)  This property holds a reference to the Ractive instance that controls the node represented by this info object.", 
            "title": "context.ractive"
        }, 
        {
            "location": "/legacy/0.9/api/#contextraise", 
            "text": "Triggers the nearest matching event directive relative to the context. This is useful for decorators and other library constructs that want to be able to raise their own events that aren't necessarily tied to a DOM event. Raised events do not bubble.  Syntax   context.raise(eventName[, event[, ...args]])   Arguments   eventName (string) : The name of the event to raise. For  div on-something=\"...\" , the event name would be  'something' .  [event] (context|object) : The context for the event or an object of properties to assign to the context for the event. Defaults to  {} .  [args] (...any) : Additional arguments to supply to the event handler.   Examples  // TODO", 
            "title": "context.raise()"
        }, 
        {
            "location": "/legacy/0.9/api/#contextreadlink", 
            "text": "See ractive.readLink().", 
            "title": "context.readLink()"
        }, 
        {
            "location": "/legacy/0.9/api/#contextresolve", 
            "text": "Resolves the given keypath to a full keypath. If a Ractive instance is supplied, the resolved path will also account for any mappings defined for the instance.  Syntax   context.resolve([keypath[, ractive]])   Arguments   [keypath] (string) : The keypath to resolve.  [ractive] (Ractive) : The instance to resolve the keypath against.   Returns   (string) : The resolved keypath.   Examples  // TODO", 
            "title": "context.resolve()"
        }, 
        {
            "location": "/legacy/0.9/api/#contextreverse", 
            "text": "See ractive.reverse().", 
            "title": "context.reverse()"
        }, 
        {
            "location": "/legacy/0.9/api/#contextset", 
            "text": "See ractive.set().", 
            "title": "context.set()"
        }, 
        {
            "location": "/legacy/0.9/api/#contextsetbinding", 
            "text": "Sets the binding of the node represented by this info object to the specified value.  Syntax   context.setBinding(value)   Arguments   value (any) . The value to set.   Returns   (Promise)   Examples  // TODO", 
            "title": "context.setBinding()"
        }, 
        {
            "location": "/legacy/0.9/api/#contextshift", 
            "text": "See ractive.shift().", 
            "title": "context.shift()"
        }, 
        {
            "location": "/legacy/0.9/api/#contextsplice", 
            "text": "See ractive.splice().", 
            "title": "context.splice()"
        }, 
        {
            "location": "/legacy/0.9/api/#contextsort", 
            "text": "See ractive.sort().", 
            "title": "context.sort()"
        }, 
        {
            "location": "/legacy/0.9/api/#contextsubtract", 
            "text": "See ractive.subtract().", 
            "title": "context.subtract()"
        }, 
        {
            "location": "/legacy/0.9/api/#contexttoggle", 
            "text": "See ractive.toggle().", 
            "title": "context.toggle()"
        }, 
        {
            "location": "/legacy/0.9/api/#contextunlink", 
            "text": "See ractive.unlink().", 
            "title": "context.unlink()"
        }, 
        {
            "location": "/legacy/0.9/api/#contextunlisten", 
            "text": "Unsubscribe an event listener that was subscribed with  listen . This is basically a  removeEventListener  helper that is delegation-aware.  Syntax  context.unlisten( event, callback )  Arguments   event (string) : The name of the event to unsubscribe.  callback (function) : The callback that was previously subscribed.", 
            "title": "context.unlisten()"
        }, 
        {
            "location": "/legacy/0.9/api/#contextunshift", 
            "text": "See ractive.unshift().", 
            "title": "context.unshift()"
        }, 
        {
            "location": "/legacy/0.9/api/#contextupdate", 
            "text": "See ractive.update().", 
            "title": "context.update()"
        }, 
        {
            "location": "/legacy/0.9/api/#contextupdatemodel", 
            "text": "See ractive.updateModel().", 
            "title": "context.updateModel()"
        }, 
        {
            "location": "/legacy/0.9/api/#parse-object", 
            "text": "The parse object is an object you receive as the second argument in function templates. This helper object provides you with essential functions to dissect markup before turning over the template for use.", 
            "title": "Parse Object"
        }, 
        {
            "location": "/legacy/0.9/api/#pfromid", 
            "text": "Retrieves the template from the DOM  script  tag specified by  id . Make sure to set  type='text/ractive'  on the  script  tag to prevent the browser from running the template as a script.  Syntax   p.fromId(id)   Arguments   id (string) : The id of the  script  tag containing the template. The leading  #  is optional.   Returns   (string) : The template inside the specified element.   Examples  // TODO", 
            "title": "p.fromId()"
        }, 
        {
            "location": "/legacy/0.9/api/#pisparsed", 
            "text": "Test whether the supplied template is already parsed and is in its object form.  Syntax   p.isParsed(template)   Arguments   template (string|Object) : The template, either in its string form or object form.   Returns   (boolean) : Returns  true  if the template is already parsed,  false  if otherwise.   Examples  // TODO", 
            "title": "p.isParsed()"
        }, 
        {
            "location": "/legacy/0.9/api/#pparse", 
            "text": "Parses the template using Ractive.parse(). Full Ractive runtime must be loaded.  Syntax   p.parse(template[, parseOptions])   Arguments   template (string|Object) : The template in its string form or object form.  parseOptions] (Object) : Template parser options. See [Ractive.parse() for all available options. If  parseOptions  is not specified, it defaults to those of the current instance.   Returns   (Object) : The parsed template.   Examples  // TODO", 
            "title": "p.parse()"
        }, 
        {
            "location": "/legacy/0.9/api/#transition-object", 
            "text": "The transition object is an object you receive when writing transitions. It has a few properties and methods designed to make creating transitions easier.", 
            "title": "Transition Object"
        }, 
        {
            "location": "/legacy/0.9/api/#tanimatestyle", 
            "text": "Animates CSS properties to a certain value.  Syntax   t.animateStyle(prop, value, options[, complete])  t.animateStyle(props, options[, complete])   Arguments   props (Object) : A map of animation properties and values.  prop (string) : The style to animate.  value (any) : The value to animate it to.  options (Object) : Animation options.  duration (number) : The duration of the animation.  easing (string) : The easing function of the animation.  delay (number) : The number of milliseconds before the animation starts.  [complete] (Function) : A function that is executed when the animation completes, or immediately if no changes were made.   Returns   (Promise) : A promise that resolves when the animation completes.   Examples  // TODO", 
            "title": "t.animateStyle()"
        }, 
        {
            "location": "/legacy/0.9/api/#tcomplete", 
            "text": "Signals Ractive that the transition is complete.  Syntax   t.complete[noReset])   Arguments   noReset] (boolean) : If  true , [ t.resetStyle()  is not called. Defaults to  false .   Returns   (undefined)   Examples  // TODO", 
            "title": "t.complete()"
        }, 
        {
            "location": "/legacy/0.9/api/#tgetstyle", 
            "text": "Retrieve a CSS property value from  t.node .  Syntax   t.getStyle(prop)   Arguments   prop (string) : An unprefixed CSS property either in camelCase or kebab-case.  prop (Array) : An array of CSS properties.   Returns   (string) : The value of the specified style property.  (Object) : A key-value pair of properties and their respective values.   Examples  // TODO", 
            "title": "t.getStyle()"
        }, 
        {
            "location": "/legacy/0.9/api/#tisintro", 
            "text": "(boolean)  Should be self-explanatory...", 
            "title": "t.isIntro"
        }, 
        {
            "location": "/legacy/0.9/api/#tname", 
            "text": "(string)  The name of the transition.", 
            "title": "t.name"
        }, 
        {
            "location": "/legacy/0.9/api/#tnode", 
            "text": "(Node)  The node that's entering or leaving the DOM", 
            "title": "t.node"
        }, 
        {
            "location": "/legacy/0.9/api/#tprocessparams", 
            "text": "Builds a map of parameters whose values are taken from the provided arguments. When used with a single number or string argument, serves as a shorthand for creating a map with a  duration  property.  Syntax   t.processParams(params[, defaults])   Arguments   params (number) : Numeric shorthand for the  duration  parameter. Expressed in milliseconds.  params (string) : String shorthand for the  duration  parameter. Valid values are:  \"fast\" - 200ms  \"slow\" - 600ms  Any other string - 400ms    params (Object) : A map of parameters and their values.  [defaults] (Object) : A map of parameters and their default values.   Returns   (Object) : A map of parameters and their values.   Examples  // TODO", 
            "title": "t.processParams()"
        }, 
        {
            "location": "/legacy/0.9/api/#tsetstyle", 
            "text": "Sets a CSS property on  t.node  to a value.  Syntax   t.setStyle(prop, value)  t.setStyle(props)   Arguments   prop (string) : An unprefixed CSS property either in camelCase or kebab-case.  props (Object) : A key-value pair of CSS properties and their respective values.  value (string) : A valid value for the specified CSS property.   Returns   (undefined)   Examples  // TODO", 
            "title": "t.setStyle()"
        }, 
        {
            "location": "/legacy/0.9/api/#component-files", 
            "text": "Remember the good old days? When all CSS went in  style  elements in  head ? When all JS went in  script  elements just before  /body ? When all HTML was written in Mustache inside inert  script  elements? When it felt good when everything just worked after a page refresh? Ractive remembers, and it's bringing those good times back with component files.  Ractive component files are simply self-contained HTML files that define a component and contains all the markup, data, styles and logic it needs. It's also designed with dependency management in mind, allowing it to declare library and component dependencies. Best of all, component files are written in the same way regardless of the development process involved, build step or none.", 
            "title": "Component files"
        }, 
        {
            "location": "/legacy/0.9/api/#example-component-file", 
            "text": "!-- Example component file --  !-- Import a component named Foo from the file foo.html. --  link rel='ractive' href='foo.html' name='foo'  !-- Define the markup for this component. --  h1 {{ title }} /h1  !-- Use imported foo component --  p This is an imported 'foo' component:  foo/ /p  !-- Define the styles for this component. --  style \n  p { color: red; } /style  !-- Define the behavior for this component. --  script \nconst $ = require( 'jquery' )\n\ncomponent.exports = {\n  onrender () {\n    $(' p / ').text('component rendered').insertAfter($this.find('p'))\n  },\n  data: {\n    title: 'Hello World!'\n  }\n} /script   The above component file roughly translates to the following in vanilla JS:  import Ractive from 'ractive'\nimport $ from 'jquery'\nimport foo from './foo.html'\n\nexport default Ractive.extend({\n  components: { foo },\n  onrender () {\n    $(' p / ').text('component rendered').insertAfter($this.find('p'))\n  },\n  data: {\n    title: 'Hello World!'\n  },\n  template: `\n     h1 {{ title }} /h1 \n     p This is an imported 'foo' component:  foo/ /p \n  `,\n  css: `\n    p { color: red; }\n  `\n})", 
            "title": "Example component file"
        }, 
        {
            "location": "/legacy/0.9/api/#writing", 
            "text": "", 
            "title": "Writing"
        }, 
        {
            "location": "/legacy/0.9/api/#link-relractive", 
            "text": "Top-level  link rel=\"ractive\"  elements define dependencies on other components. It accepts two attributes:    href  - The path to the required component file. Paths that start with  ./  or  ../  are resolved relative to the importing component file. Otherwise, resolution is loader-specific.    name  (optional) - The registered name of the component. This corresponds to the key used in the  components  initialization option. When not defined, the filename of the dependency will be used as the name.    The names and the loaded dependency will be assigned to the component's  components  initialization option.", 
            "title": "&lt;link rel=\"ractive\"&gt;"
        }, 
        {
            "location": "/legacy/0.9/api/#style_1", 
            "text": "Top-level  style  elements define the styles for the component. If more than one  style  element is found on the component file, their contents are concatenated in the order of appearance of the  style  elements. Contents of these elements will be concatenated and assigned to the component's  css  initialization option.", 
            "title": "&lt;style&gt;"
        }, 
        {
            "location": "/legacy/0.9/api/#script", 
            "text": "A top-level  script  defines the component's initialization. The script's scope has a  component  object that is similar to Node's  module  object. Initialization options for the component is expected via  component.exports . It also has a special  require  function that fetches script dependencies.  require 's behavior depends on the loader used. Refer to the specific loader's documentation to know more.  There can only ever be one  script  in a component file. Defining more than one will result in the loader throwing an error.", 
            "title": "&lt;script&gt;"
        }, 
        {
            "location": "/legacy/0.9/api/#template_1", 
            "text": "After yanking out top-level  link rel=\"ractive\" ,  style  or  script  from the component file, anything that's left becomes a part of the template. The remaining markup will be assigned to the component's  template  initialization option.", 
            "title": "Template"
        }, 
        {
            "location": "/legacy/0.9/api/#using", 
            "text": "In order to use component files, you will have to use  loaders , Head over to  the loaders page  to learn more about loaders and help you choose a loader that suits your needs.", 
            "title": "Using"
        }, 
        {
            "location": "/legacy/0.9/plugins/", 
            "text": "Adaptors\n\n\nIn some cases you want to write your UI in Ractive but have a custom back-end manage the data. Adaptors allow you to teach Ractive how to talk to those custom data sources without having to change the way you write Ractive or having to write a lot of connector code up front.\n\n\nWriting\n\n\nAdaptors translate custom non-POJO (non-Plain Old JS Object) data sources into POJOs and vice-versa. Generally, an adaptor does the following:\n\n\n\n\nChecks if data needs to be adapted, and if so, \"wraps\" an adaptor to it.\n\n\nProvides a POJO version of your data source for Ractive to use.\n\n\nCaptures data changes on your data source and mirror them to the data in Ractive.\n\n\nCaptures data changes on the data in Ractive and mirror them to the data source.\n\n\n\n\nconst myAdaptor = {\n  filter ( value, keypath, ractive ) {\n    // return `true` if a particular object is of the type we want to adapt.\n  },\n  wrap ( ractive, value, keypath, prefixer ) {\n    // Setup\n    return {\n      get () {\n        // Returns POJO version of your data backend.\n      },\n      set (property, value) {\n        // Data setter for POJO property keypaths.\n      },\n      reset (value) {\n        // Data setter for POJO keypath.\n      },\n      teardown () {\n        // Code executed on teardown.\n      }\n    }\n  }\n}\n\n\n\n\nAn adaptor definition is an object with two methods:\n\n\n\n\nfilter\n: A function which, if it returns \ntrue\n, tells Ractive to use the adaptor on the value.\n\n\nvalue\n: The value to check.\n\n\nkeypath\n: The keypath of \nvalue\n relative to the instance root.\n\n\nractive\n: The instance where \nvalue\n resides.\n\n\n\n\n\n\nwrap\n: A function that sets up an adaptor.\n\n\nractive\n: The instance where \nvalue\n resides.\n\n\nvalue\n: The value to adapt.\n\n\nkeypath\n: The keypath of \nvalue\n relative to the instance root.\n\n\nprefixer\n: A function that accepts an object and returns a shallow clone with its keys prepended with \nkeypath\n.\n\n\n\n\n\n\n\n\nThe \nwrap\n function must return an object with four methods:\n\n\n\n\nget\n: A function that returns the POJO representation of the adapted data.\n\n\nset\n: A function that's called when the keypath being updated is a property of the adapted data.\n\n\nproperty\n: The property name to be updated.\n\n\nvalue\n: The new value.\n\n\n\n\n\n\nreset\n: A function that's called when the keypath being updated is the adapted data itself. If \nreset\n returns \nfalse\n, Ractive will replace the data on the keypath with the POJO version, and tear down the adaptor.\n\n\nvalue\n: The new value\n\n\n\n\n\n\nteardown\n: A function that's called when an adaptor is being removed.\n\n\n\n\nAdaptors only adapt one level\n\n\nAn adaptor only adapts an object's immediate properties. Updating nested data via Ractive or via the data source will not update the other.\n\n\nNo built-in infinite loop detection\n\n\nThere is no built-in mechanism for avoiding infinite loops. If your adaptor calls \nractive.set()\n on adapted data, which in turn will call the adaptor's \nset()\n method, which may directly or indirectly trigger another \nractive.set()\n on the same adapted data, a stack overflow error might occur.\n\n\nThis isn't a problem with primitive values since Ractive doesn't bother calling \nset()\n if a value hasn't changed. But with objects and arrays, there's no easy and performant way to tell if the contents have changed. So \nset()\n gets called \nin case something changed\n rather than \nbecause something changed\n.\n\n\nDifferent for every back-end\n\n\nThe adaptor structure only provides you with the means to talk to and listen from a custom back-end. It does not impose any rules on how to write an adaptor for a certain back-end. For instance, an adaptor for a constructor-based object may be written differently from an adaptor meant to interact with a socket server.\n\n\nRegistering\n\n\nLike other plugins, there's 3 ways you can register adaptors:\n\n\nGlobally, via the \nRactive.adaptors\n static property.\n\n\nRactive.adaptors.myAdaptor = myAdaptor\n\n\n\n\nPer component, via the component's \nadaptors\n initialization property.\n\n\nconst MyComponent = Ractive.extend({\n  adaptors: { myAdaptor }\n})\n\n\n\n\nPer instance, via the instance's \nadaptors\n initialization property.\n\n\nconst ractive = Ractive({\n  adaptors: { myAdaptor }\n})\n\n\n\n\nUsing\n\n\nIn order to use an adaptor, you must tell the component or an instance to use it using the \nadapt\n initialization option.\n\n\nconst ractive = Ractive({\n  adapt: [ 'myAdaptor' ]\n})\n\n\n\n\nExamples\n\n\nIn the following example, we have a \nBox\n constructor that uses accessors to get and set its \nwidth\n and \nheight\n properties. Since an instance of \nBox\n will have no publicly visible properties, Ractive cannot bind to them directly.\n\n\nfunction Box(width, height) {\n  var _width = width\n  var _height = height\n\n  this.getWidth = () =\n { return _width; }\n  this.setWidth = (width) =\n { _width = width; }\n  this.getHeight = () =\n { return _height; }\n  this.setHeight = (height) =\n { _height = height }\n}\n\n\n\n\nIn order for Ractive to properly use a \nBox\n instance, we build an adaptor for \nBox\n.\n\n\nRactive.adaptors.boxAdaptor = {\n  filter ( object ) {\n    // Checks if the piece of data is an instance of Box.\n    return object instanceof Box\n  },\n  wrap ( ractive, box, keypath, prefixer ) {\n\n    // We keep a reference to the original functions before monkey-patching.\n    const setWidth = box.setWidth\n    const setHeight = box.setHeight\n\n    // Use ractive.set on the the adapted data whenever the setters are used.\n    box.setWidth = (width) =\n {\n      ractive.set(prefixer({\n        width: width\n      }))\n    }\n\n    box.setHeight = (height) =\n {\n      ractive.set(prefixer({\n        height: height\n      }))\n    }\n\n    return {\n      // Return a POJO representation of an instance of Box.\n      get () {\n        return {\n          width: box.getWidth(),\n          height: box.getHeight()\n        }\n      },\n      // Update the adapted object's properties\n      set (property, value) {\n        if(property === 'width') setWidth.call(box, value)\n        if(property === 'height') setHeight.call(box, value)\n      },\n      // Update the adapted object.\n      reset (data) {\n        // We don't adapt non-objects. And if the new data is an instance of Box\n        // there's a high chance that its a new instance. In either case, we\n        // need to tear down this adapter and have Ractive set it up again if\n        // necessary.\n        if(typeof data !== 'object' || data instanceof Box) return false\n\n        // Otherwise, we just parse through the data and update the existing box\n        // instance.\n        if(data.width !== undefined) setWidth.call(box, data.width)\n        if(data.height !== undefined) setHeight.call(box, data.height)\n      },\n      // Delete the monkey-patched methods.\n      teardown () {\n        delete box.setWidth\n        delete box.setHeight\n      }\n    }\n  }\n}\n\n\n\n\nThen we use \nboxAdaptor\n on an instance. The data can now be treated like regular Ractive data. Updates done directly on \nbox\n will reflect on Ractive. Any changes via Ractive will reflect on \nbox\n.\n\n\nconst ractive = Ractive({\n  el: 'body',\n  // Tell the instance we'll be using boxAdaptor\n  adapt: [ 'boxAdaptor' ],\n  // We write Ractive like normal.\n  template: `\n    \ndiv\nBox is {{ box.width }}x{{ box.height }}\n/div\n,\n    \ndiv\ninput type=\ntext\n value=\n{{ box.width }}\n/div\n\n    \ndiv\ninput type=\ntext\n value=\n{{ box.height }}\n/div\n\n  `\n})\n\nconst box = new Box(3, 4)\n\n// Set the Box instance as if it were a POJO.\nractive.set('box', box)\n\n// Both box instance and box object will have 7 width and 11 height and will\n// be rendered in the UI accordingly.\nbox.setWidth(7)\nractive.set('box.height', 11)\n\n\n\n\nComponents\n\n\nIn many situations, you want to encapsulate behaviour and markup into a single reusable \ncomponent\n, which can be dropped into Ractive applications. Components are simply custom-configured \"subclasses\" of Ractive (analogous, but technically incorrect).\n\n\nWriting\n\n\nThere are several ways to write Ractive components. Standard initialization options apply for configuration unless where changes are explicitly mentioned.\n\n\nThe most common way to define a component is by using \nRactive.extend()\n.\n\n\n// A subclass of Ractive\nconst MyComponent = Ractive.extend({\n  template: `\n    \ndiv class=\nmy-component\n\n      \nspan class=\nmy-component__message\n{{ message }}\n/span\n\n    \n/div\n\n  `,\n  css: `\n    .my-component__message { color: red }\n  `,\n  data: { message: 'Hello World' }\n})\n\n\n\n\nAnother way to define a component is by using component files and loaders.\n\n\ndiv class=\nmy-component\n\n  \nspan class=\nmy-component__message\n{{ message }}\n/span\n\n\n/div\n\n\n\nstyle\n\n  .my-component__message { color: red }\n\n/style\n\n\n\nscript\n\ncomponent.exports = {\n  data: { message: 'Hello World' }\n}\n\n/script\n\n\n\n\n\nRegistering\n\n\nLike other plugins, there's 3 ways you can register components:\n\n\nGlobally, via the \nRactive.components\n static property:\n\n\n// Available to all instances of Ractive.\nRactive.components.MyComponent = Ractive.extend({ ... })\n\n\n\n\nPer component, via the component's \ncomponents\n initialization property.\n\n\n// Only available for instances of AnotherComponent.\nconst AnotherComponent = Ractive.extend({\n  components: { MyComponent }\n})\n\n\n\n\nPer instance, via the instance's \ncomponents\n initialization property.\n\n\n// Only available to this specific instance.\nconst ractive = Ractive({\n  components: { MyComponent }\n})\n\n\n\n\nUsing\n\n\nComponents are simply subclasses of Ractive, which means they are also instatiable.\n\n\nconst ractive = MyComponent({ ... })\n\n\n\n\nBut where components really shine is when they're used on templates. They are written like \ncustom elements\n. Each custom element notation represents one instance of the component.\n\n\nconst AnotherComponent = Ractive.extend({\n  template: `\n    \ndiv\n\n      \nMyComponent /\n \n!-- One instance of MyComponent --\n\n      \nMyComponent /\n \n!-- Another instance of MyComponent --\n\n      \nMyComponent /\n \n!-- Yet another instance of MyComponent --\n\n    \n/div\n\n  `\n})\n\n\n\n\nThe component's tag name depends on the name used upon registration. The same component can be registered more than once using different names.\n\n\nconst MyComponent = Ractive.extend({...})\nRactive.components.MyComponent = MyComponent\nRactive.components.MyComponentOtherName = MyComponent\n\nconst AnotherComponent = Ractive.extend({\n  template: `\n    \ndiv\n\n      \nMyComponent /\n          \n!-- Using MyComponent --\n\n      \nMyComponentOtherName /\n \n!-- Using MyComponent's other name --\n\n    \n/div\n\n  `\n})\n\n\n\n\nExamples\n\n\n\n\n\nDecorators\n\n\nA decorator is a simple way to add behaviour to a node when it is rendered, or to augment it in some way. Decorators are a good way to integrate DOM manipulation libraries with Ractive, such as \njQuery UI\n or \nBootstrap\n.\n\n\nWriting\n\n\nconst myDecorator = (node[, ...args]) =\n {\n  // Setup code\n  return {\n    teardown () {\n      // Cleanup code\n    },\n    update ([...args]) {\n      // Update code\n    },\n    invalidate () {\n      // Code called on invalidate\n    }\n  }\n}\n\n\n\n\nDecorators are simply functions that are called upon to setup the decorator once Ractive detects its use. It takes a \nnode\n argument and returns an object with a \nteardown\n and \nupdate\n property.\n\n\nnode\n is the element to which the decorator is applied to.\n\n\n[args]\n are optional arguments provided by the decorator directive.\n\n\nteardown\n is a function that gets called when the decorator is torn down.\n\n\nupdate\n is an optional function that gets called when the arguments update.\n\n\ninvalidate\n, starting with 0.9.3, is an optional function that gets called when any bit of template downstream from the node is being updated.\n\n\nAny updates to the arguments will call the decorator's \nteardown\n and run the decorator function again, essentially setting up the decorator again. If an \nupdate\n function is provided on the return object, that will be called instead of the \nteardown\n and setup function.\n\n\nRegistering\n\n\nLike other plugins, there's 3 ways you can register decorators:\n\n\nGlobally, via the \nRactive.decorators\n static property.\n\n\nRactive.decorators.myDecorator = myDecorator\n\n\n\n\nPer component, via the component's \ndecorators\n initialization property.\n\n\nconst MyComponent = Ractive.extend({\n  decorators: { myDecorator }\n})\n\n\n\n\nPer instance, via the instance's \ndecorators\n initialization property.\n\n\nconst ractive = Ractive({\n  decorators: { myDecorator }\n})\n\n\n\n\nUsing\n\n\nOne or more decorators can be added to an element via the \nas-*\n directive. Arguments are passed to the decorator function by supplying comma-separated expressions as values. These expressions will become the second argument and onwards of the transition function.\n\n\n!-- without arguments --\n\n\ndiv as-myDecorator\n...\n/div\n\n\n\n!-- with arguments --\n\n\ndiv as-myDecorator=\narg1, .some.other.arg2, 10 * @index\n as-somethingElseToo\n...\n/div\n\n\n\n\n\nExamples\n\n\nThe following example builds a decorator that updates the time.\n\n\nRactive.decorators.timer = (node, time) =\n {\n  node.innerHTML = 'Hello World!'\n\n  return {\n    teardown () {\n      node.innerHTML = ''\n    },\n    update (time) {\n      node.innerHTML = time\n    }\n  }\n}\n\nconst ractive = Ractive({\n  el: 'body',\n  template: `\n    \nspan as-timer=\ntime\n/span\n\n  `,\n  data: {\n    time: 0\n  }\n})\n\nsetInterval(function () {\n  ractive.set('time', Date.now())\n}, 1000)\n\n\n\n\nEasings\n\n\nEasing functions describe the animation's progression from start to finish. Easings are used by \nractive.animate\n and some transitions. Out of the box, Ractive comes with \nlinear\n, \neaseIn\n, \neaseOut\n and \neaseInOut\n.\n\n\nWriting\n\n\nconst myEasing = ( t ) =\n {\n  // Calculation\n  return v\n}\n\n\n\n\nEasing functions receive \nt\n, a value from \n0\n to \n1\n, which represents the linear progression of the animation from start to finish. The easing function must then return \nv\n, a value also from \n0\n to \n1\n, which represents the progress of the animation for that easing.\n\n\nRegistering\n\n\nLike other plugins, there's 3 ways you can register an easing function:\n\n\nGlobally via the \nRactive.easing\n static property.\n\n\nRactive.easing.myEasing = myEasing\n\n\n\n\nPer component via the component's \neasing\n initialization property.\n\n\nconst MyComponent = Ractive.extend({\n  easing: { myEasing }\n})\n\n\n\n\nPer instance, via the instance's \neasing\n initialization property.\n\n\nconst ractive = Ractive({\n  easing: { myEasing }\n})\n\n\n\n\nUsing\n\n\nEasing functions are utilized by \nractive.animate()\n and transitions to define animations.\n\n\n\nractive.animate('counter', 60, {\n  easing: 'myEasing'\n})\n\n\n\n\nExamples\n\n\nHere's an \nelastic\n easing function taken from \ndanro\n's excellent \neasing.js\n library.\n\n\nRactive.easing.elastic = ( t ) =\n {\n  return -1 * Math.pow(4,-8*t) * Math.sin((t*6-1)*(2*Math.PI)/2) + 1\n}\n\n\n\n\nEvents\n\n\nEvents allow custom-named events on DOM elements. Common use cases for custom DOM events include normalizing cross-browser events, normalizing cross-device events, implementing custom events, and so much more.\n\n\nWriting\n\n\nconst myEvent = (node, fire) =\n {\n  // Setup code\n  return {\n    teardown () {\n      // Cleanup code\n    }\n  }\n}\n\n\n\n\nEvents are simply functions that are called to set up the event on a DOM element. The event function accepts two arguments: \nnode\n and \nfire\n, and returns an object containing a \nteardown\n property.\n\n\nnode\n is the element to which the event is being applied.\n\n\nfire\n is the function that must be called when the event has taken place. \nfire\n takes a single argument, the event object received by handlers. The minimum requirement for the event object is a \nnode\n property that references DOM node the event is attached to, and an \noriginal\n property which references the native DOM \nevent\n object supplied by the native handler, if available.\n\n\nThe event object will be augmented with \ncontext\n, \nkeypath\n and \nindex\n properties, whose values depend on the data context the node is in. \ncontext\n references the data context that surrounds the node, \nkeypath\n is a string that leads to the current data context and \nindex\n is a number that references the index number of the data, should the data context be in an array.\n\n\nteardown\n is a function that gets called once the element is torn down. This allows the event to clean up after itself.\n\n\nRegistering\n\n\nLike other plugins, there's 3 ways you can register events:\n\n\nGlobally, via the \nRactive.events\n static property.\n\n\nRactive.events.myEvent = myEvent\n\n\n\n\nPer component, via the component's \nevents\n initialization property.\n\n\nconst MyComponent = Ractive.extend({\n  events: { myEvent }\n})\n\n\n\n\nPer instance, via the instance's \nevents\n initialization property.\n\n\nconst ractive = Ractive({\n  events: { myEvent }\n})\n\n\n\n\nUsing\n\n\nEvents use the same \non-*\n attribute syntax as component and DOM events. When Ractive encounters an \non-*\n attribute on a DOM element, it looks for a registered event and applies it on the element. If no matching event name was found, Ractive will think the event name is a native DOM event and will attach one accordingly.\n\n\n// This will apply the \nmyEvent\n custom event if one is registered.\n// Otherwise, Ractive will think it's a DOM event. You have been warned!\n\nspan on-myEvent=\nfoo()\nClick me!\n/span\n\n\n\n\n\nExamples\n\n\nHere's an example of a \"long press\" event which fires when the mouse is clicked and held for 1 second.\n\n\n// Definition\nRactive.events.longpress = (node, fire) =\n {\n  let timer = null\n\n  function clearTimer () {\n    if(timer) clearTimeout(timer)\n    timer = null\n  }\n\n  function mouseDownHandler(event) {\n    clearTimer()\n\n    timer = setTimeout(() =\n {\n      fire({\n        node: node,\n        original: event\n      })\n    }, 1000)\n  }\n\n  function mouseUpHandler () {\n    clearTimer()\n  }\n\n  node.addEventListener('mousedown', mouseDownHandler)\n  node.addEventListener('mouseup', mouseUpHandler)\n\n  return {\n    teardown () {\n      node.removeEventListener('mousedown', mouseDownHandler)\n      node.removeEventListener('mouseup', mouseUpHandler)\n    }\n  }\n}\n\n// Usage:\nRactive({\n  el: 'body',\n  template: `\n    \nbutton type=\nbutton\n on-longpress=\n@this.greetz()\nClick Me!\n/button\n\n  `,\n  greetz () {\n    console.log('Hello World!')\n  }\n})\n\n\n\n\nInterpolators\n\n\nInterpolator functions describe a value's progression during an animation from start to finish. Interpolator functions also determine the value on the model as well as what gets rendered during the animation.\n\n\nWriting\n\n\nconst myInterpolator = (from, to) =\n {\n\n  return t =\n {\n    return valueAtTimeT\n  }\n}\n\n\n\n\n\nInterpolator plugins accept \nfrom\n and \nto\n. \nfrom\n is the value on the animated keypath before calling \nractive.animate()\n and \nto\n is the value being set by \nractive.animate()\n. The plugin must return a function that receives \nt\n and returns a value that represents the animated value at \nt\n. \nt\n is a value from \n0\n to \n1\n representing the animation's progress with easing already applied.\n\n\nRegistering\n\n\nLike other plugins, there's 3 ways you can register an interpolator function:\n\n\nGlobally via the \nRactive.interpolators\n static property.\n\n\nRactive.interpolators.myInterpolator = myInterpolator\n\n\n\n\nPer component via the component's \ninterpolators\n initialization property.\n\n\nconst MyComponent = Ractive.extend({\n  interpolators: { myInterpolator }\n})\n\n\n\n\nPer instance, via the instance's \ninterpolators\n initialization property.\n\n\nconst ractive = Ractive({\n  interpolators: { myInterpolator }\n})\n\n\n\n\nUsing\n\n\nInterpolator functions are utilized by \nractive.animate()\n by supplying the interpolator name to the \ninterpolator\n option.\n\n\nractive.animate('counter', 60, {\n  interpolator: 'myInterpolator'\n})\n\n\n\n\nExamples\n\n\nHere's an abridged version of Ractive's built-in \nnumber\n interpolator which interpolates numeric values (numbers and number-like strings) during animation.\n\n\nRactive.interpolators.number = (from, to) =\n {\n  const start = Number(from)\n  const end = Number(to)\n\n  if (Number.isNaN(start) || Number.isNaN(end)) return null\n\n  const delta = end - start\n  const noChangeInterpolator = () =\n start\n  const changeInterpolator = t =\n start + (t * delta)\n  return delta ? changeInterpolator : noChangeInterpolator\n}\n\n\n\n\nPartials\n\n\nA partial is a template snippet which can be reused in templates or in other partials. They help to keep templates uncluttered, non-repetetive and easy to read.\n\n\nWriting\n\n\nconst myPartial = '\n!-- template --\n'\n\n\n\n\nPartials are simply Ractive templates.\n\n\nRegistering\n\n\nUnlike other plugins, partials have more than 3 registration options.\n\n\nGlobally via the \nRactive.partials\n static property.\n\n\nRactive.partials.myPartial = MyPartial\n\n\n\n\nGlobally, via a non-executing script tag on the current page.\n\n\nscript type=\nractive/template\n id=\nmyPartial\n\n  ...\n\n/script\n\n\n\n\n\nPer component, via the component's \npartials\n initialization property.\n\n\nconst MyComponent = Ractive.extend({\n  partials: { myPartial }\n})\n\n\n\n\nPer instance, via the instance's \npartials\n initialization property.\n\n\nconst ractive = Ractive({\n  partials: { myPartial }\n})\n\n\n\n\nIn-template, using the \n{{#partial}}\n mustache.\n\n\n{{#partial myPartial}}\n  ...\n{{/}}\n\n\n\n\nUsing\n\n\nPartials can be used using \n{{\npartialName}}\n. Partials work where any template would work and takes on its surrounding context.\n\n\n{{#partial myPartial}}\n  \ndiv class=\nmessage\n{{message}}\n/div\n\n{{/partial}}\n\n\ndiv class=\napp\n\n  {{\nmyPartial}}\n\n/div\n\n\n\n\n\nValid names\n\n\nPartials may be named with the same rules as any other identifier in Ractive or JavaScript, but since there isn't much danger of trying to do math in a partial name, they enjoy relaxed naming requirements that allow otherwise reserved globals and keywords to be used for partial names.\n\n\nPartial names may also contain \n-\n and \n/\n characters as long as they are surrounded by other valid characters e.g. \ntemplates/some-partial-template\n.\n\n\nContext\n\n\nPartials be given an explicit context. Simply supply a reference to the context following the partial name on usage.\n\n\nRactive({\n  data: {\n    foo:{\n      bar: 'Hello, World!'\n    }\n  },\n  template: `\n    {{#partial myPartial}}{{bar}}{{/partial}}\n\n    {{\nmyPartial foo}}\n  `\n})\n\n\n\n\nAliases\n\n\nReferences can also be aliased in partials. Simply define aliases as comma-separated \nreference as alias\n pairs following the partial name on usage.\n\n\nRactive({\n  data: {\n    status: 'Me, Hungry!',\n    foo:{\n      bar: 'Hello, World!'\n    }\n  },\n  template: `\n    {{#partial myPartial}}{{msg}} {{state}}{{/partial}}\n\n    {{\nmyPartial foo.bar as msg, status as state}}\n  `\n})\n\n\n\n\nRecursive partials\n\n\nPartials can be used recursively. A common use case for this is when reusing partials on a tree-like structure, like a directory listing.\n\n\ndiv class='fileSystem'\n\n  {{#root}}\n    {{\nfolder}}\n  {{/root}}\n\n/div\n\n\n{{#partial folder}}\n\nul class='folder'\n\n  {{#files}}\n    {{\nfile}}\n  {{/files}}\n\n/ul\n\n{{/partial}}\n\n{{#partial file}}\n\nli class='file'\n\n  \nimg class='icon-{{type}}'\n\n  \nspan\n{{filename}}\n/span\n\n\n  \n!-- if this is actually a folder, embed the folder partial --\n\n  {{# type === 'folder' }}\n    {{\nfolder}}\n  {{/ type === 'folder' }}\n\n/li\n\n{{/partial}}\n\n\n\n\nrv = Ractive({\n  el: 'container',\n  template: '#myTemplate',\n  data: {\n    root: {\n      files: [\n        { type: 'jpg', filename: 'hello.jpg' },\n        { type: 'mp3', filename: 'NeverGonna.mp3' },\n        { type: 'folder', filename: 'subfolder', files: [\n          { type: 'txt', filename: 'README.txt' },\n          { type: 'folder', filename: 'rabbithole', files: [\n            { type: 'txt', filename: 'Inception.txt' }\n          ]}\n        ]}\n      ]\n    }\n  }\n})\n\n\n\n\nIn the example above, subfolders use the \n{{\nfolder}}\n partial, which uses the \n{{\nfile}}\n partial for each file, and if any of those files are folders, the \n{{\nfolder}}\n partial will be invoked again, and so on until there are no more files.\n\n\nBeware of cyclical data structures! Ractive makes no attempt to detect cyclicality, and will happily continue rendering partials until the \nBig Crunch\n (or your browser exceeds its maximum call stack size. Whichever is sooner).\n\n\nInjecting partials\n\n\nOne good use of partials is to vary the shape of a template according to some condition, the same way you might use \ndependency injection\n elsewhere in your code.\n\n\nFor example, you might offer a different view to mobile users:\n\n\ndiv class='main'\n\n  \ndiv class='content'\n\n    {{\ncontent}}\n  \n/div\n\n\n  \ndiv class='sidebar'\n\n    {{\nsidebar}}\n  \n/div\n\n\n/div\n\n\n\n\n\nisMobile = /mobile/i.test( navigator.userAgent ); // please don't do this in real life!\n\nractive = Ractive({\n  el: myContainer,\n  template: myTemplate,\n  partials: {\n    content: isMobile ? mobileContentPartial : desktopContentPartial,\n    sidebar: isMobile ? mobileSidebarPartial : desktopSidebarPartial\n  }\n})\n\n\n\n\nOr you might make it possible to extend a subclass without overriding its template:\n\n\ndiv class='modal-background'\n\n  \ndiv class='modal'\n\n    {{\nmodalContent}}\n  \n/div\n\n\n/div\n\n\n\n\n\n// Create a Modal subclass\nModal = Ractive.extend({\n  template: modalTemplate,\n  init () {\n    var self = this, resizeHandler\n\n    resizeHandler = () =\n {\n      self.center()\n    }\n\n    // when the window resizes, keep the modal horizontally and vertically centred\n    window.addEventListener( 'resize', resizeHandler )\n\n    // clean up after ourselves later\n    this.on( 'teardown', function () {\n      window.removeEventListener( 'resize', resizeHandler )\n    })\n\n    // manually call this.center() the first time\n    this.center()\n  },\n  center () {\n    // centering logic goes here\n  }\n})\n\nhelloModal = Modal({\n  el: document.body,\n  partials: {\n    modalContent: '\np\nHello!\n/p\na class=\nmodal-button\n proxy-tap=\nclose\nClose\n/a\n'\n  }\n})\n\nhelloModal.on( 'close', function () {\n  this.teardown()\n})\n\n\n\n\nPartial expressions\n\n\nExpressions can also be used to reference a partial instead of fixed partial names. Ractive will evaluate the expression and use its return value to select a partial. This is useful when you want the data to indicate what type of partial it should render with.\n\n\nIn the following example, \norganisms\n contains a list of organisms whose \ntype\n can either be \nperson\n or \nanimal\n. Partials for each type is defined and the list uses the \ntype\n of each item to determine which partial to use.\n\n\n{{#partial person}}Hi! I am {{.name}} and I have {{.fingerCount}} fingers!{{/}}\n\n{{#partial animal}}Hi! I am a {{.name}} and I have {{.legCount}} legs!{{/}}\n\n\nul\n\n  {{# organisms }}\n    \nli\n{{\n type }}\n/li\n\n  {{/}}\n\n/ul\n\n\n\n\n\nIn the case where there's a collision between the expression and a partial of the same name, Ractive will not evaluate the expression and instead, will immediately resolve to that partial.\n\n\nIn the following example, a partial named \ntype\n is defined. Instead of evaluating \ntype\n's value, it will resolve to the partial named \ntype\n.\n\n\n{{#partial person}}Hi! I am {{.name}} and I have {{.fingerCount}} fingers!{{/}}\n\n{{#partial animal}}Hi! I am a {{.name}} and I have {{.legCount}} legs!{{/}}\n\n{{#partial type}}Hi! I am {{.name}}{{/}}\n\n\nul\n\n  {{# organisms }}\n    \nli\n{{\n type }}\n/li\n\n  {{/}}\n\n/ul\n\n\n\n\n\nPartials can also be registered on-the-fly as well as have functions determine the partial to use.\n\n\nIn the following example, \nmakePartial\n registers a partial on the fly using \ntemplate\n and \nid\n, and returns the partial name for use in the template.\n\n\nRactive({\n  el: 'main',\n  template: `\n    \nspan\nAdd a partial:\n/span\n\n    \ntextarea value=\n{{tpl}}\n /\n/div\n\n    \nbutton on-click=\n@this.add()\nAdd\n/button\nbr/\n\n\n    {{#list}}\n      {{\n @this.makePartial(.id, .template) }}\n    {{/}}\n  `,\n  data: {\n    list: [],\n    tpl: '',\n\n  },\n  add () {\n    this.push('list', {\n      id: Math.random(),\n      template: this.get('tpl')\n    })\n    this.set('tpl', '')\n  },\n  makePartial (id, template) {\n    const name = 'partial-' + id\n    this.partials[name] = this.partials[name] || template\n    return name\n  }\n})\n\n\n\n\nUpdating Partials\n\n\nPartials may be reset after they are rendered using \nractive.resetPartial()\n. A reset partial will update everywhere it is referenced, so if it is used multiple times or inherited by a component, those instances will be updated as well. If a component has a partial with the same name as a parent partial, partial resets will not affect it since it is a different partial.\n\n\nIt should be noted that partials evaluate lazily, so it is possible to cause a single partial to update by wrapping it in a conditional section and causing the section to be hidden and re-shown.\n\n\n{{^toggle}}{{\nrickroll}}{{/}}\n\n\n\n\nractive.partials.rickroll = 'I wouldn\\'t do that to you, chum.'\nractive.set('toggle', true)\nractive.set('toggle', false)\n\n\n\n\nExamples\n\n\nHere's an example of a gallery using a partial for its thumbnail information:\n\n\n!-- The partial called \nthumbnail\n --\n\n\nfigure class='thumbnail'\n\n  \nimg src='assets/thumbnails/{{id}}.jpg'\n\n  \nfigcaption\n{{description}}\n/figcaption\n\n\n/figure\n\n\n\n!-- The template that uses the partial --\n\n\ndiv class='gallery'\n\n  {{#items}}\n    {{\nthumbnail}}\n  {{/items}}\n\n/div\n\n\n\n\n\nTransitions\n\n\nTransitions allow you to control how enter the DOM and how they leave the DOM. This allows you to define intro and outro behavior, particularly animations, when elements go in and out of the page.\n\n\nWriting\n\n\nconst myTransition = ( t[, ...args]] ) =\n {\n  // Manipulate the DOM.\n  // Call t.complete() when completed.\n}\n\n\n\n\nTransitions are simply functions that get called to animate a specified element.\n\n\nt\n is a transition helper object that aids in the implementation of the transition.\n\n\n[args]\n is the arguments passed in via the transition directive.\n\n\nTransitions are expected to be asynchronous. In order to signal Ractive that the transition has completed, the transition must call the \nt.complete()\n.\n\n\nNote that transitions control the element's arrival and departure to the page. That means upon completion, any styling done to the element will be removed automatically.\n\n\nRegistering\n\n\nLike other plugins, there's 3 ways you can register transitions:\n\n\nGlobally, via the \nRactive.transitions\n static property.\n\n\nRactive.transitions.myTransition = myTransition\n\n\n\n\nPer component, via the component's \ntransitions\n initialization property.\n\n\nconst MyComponent = Ractive.extend({\n  transitions: { myTransition }\n})\n\n\n\n\nPer instance, via the instance's \ntransitions\n initialization property.\n\n\nconst ractive = Ractive({\n  transitions: { myTransition }\n})\n\n\n\n\nUsing\n\n\nTransitions are added to an element via the \n*-in\n, \n*-out\n or \n*-in-out\n directives. The transition may be applied on element render (\n-in\n), on element removal (\n-out\n), or both (\n-in-out\n).\n\n\ndiv myTransition-in\nIntro-only\n/div\n\n\ndiv myTransition-out\nOutro-only\n/div\n\n\ndiv myTransition-in-out\nIntro and outro\n/div\n\n\n\n\n\nArguments are passed to the transition function by supplying comma-separated expressions as values to \n*-in\n, \n*-out\n or \n*-in-out\n. These expressions will become the second argument and onwards of the transition function.\n\n\ndiv myTransition-in-out=\n'Hello, World!', 42\nHello, World!\n/div\n\n\n\n\n\nExamples\n\n\nThe following example demonstrates a \"flash\" transition which colors the element green upon attachment, and red prior to removal.\n\n\nRactive.transitions.flash = (t, params) =\n {\n  // Process params and declaring defaults.\n  const options = t.processParams(params, {\n    color: t.isIntro ? '#0f0' : '#f00',\n    duration: 400\n  })\n\n  // The \ntransition\n\n  t.setStyle('color', options.color)\n\n  // Signal Ractive that the transition is complete.\n  setTimeout(t.complete, options.duration)\n}\n\nRactive({\n  el: 'body',\n  template: `\n    \nbutton on-click='@this.insert()'\nInsert item\n/button\n\n    \nbutton on-click='@this.remove()'\nRemove item\n/button\n\n    \nul\n\n      {{#items}}\n      \nli flash-in-out\n{{this}}\n/li\n\n      {{/items}}\n    \n/ul\n\n  `,\n  data: {\n    items: []\n  },\n  insert () {\n    this.push('items', Date.now())\n  },\n  remove () {\n    this.splice('items', 0, 1)\n  }\n})", 
            "title": "Plugins"
        }, 
        {
            "location": "/legacy/0.9/plugins/#adaptors", 
            "text": "In some cases you want to write your UI in Ractive but have a custom back-end manage the data. Adaptors allow you to teach Ractive how to talk to those custom data sources without having to change the way you write Ractive or having to write a lot of connector code up front.", 
            "title": "Adaptors"
        }, 
        {
            "location": "/legacy/0.9/plugins/#writing", 
            "text": "Adaptors translate custom non-POJO (non-Plain Old JS Object) data sources into POJOs and vice-versa. Generally, an adaptor does the following:   Checks if data needs to be adapted, and if so, \"wraps\" an adaptor to it.  Provides a POJO version of your data source for Ractive to use.  Captures data changes on your data source and mirror them to the data in Ractive.  Captures data changes on the data in Ractive and mirror them to the data source.   const myAdaptor = {\n  filter ( value, keypath, ractive ) {\n    // return `true` if a particular object is of the type we want to adapt.\n  },\n  wrap ( ractive, value, keypath, prefixer ) {\n    // Setup\n    return {\n      get () {\n        // Returns POJO version of your data backend.\n      },\n      set (property, value) {\n        // Data setter for POJO property keypaths.\n      },\n      reset (value) {\n        // Data setter for POJO keypath.\n      },\n      teardown () {\n        // Code executed on teardown.\n      }\n    }\n  }\n}  An adaptor definition is an object with two methods:   filter : A function which, if it returns  true , tells Ractive to use the adaptor on the value.  value : The value to check.  keypath : The keypath of  value  relative to the instance root.  ractive : The instance where  value  resides.    wrap : A function that sets up an adaptor.  ractive : The instance where  value  resides.  value : The value to adapt.  keypath : The keypath of  value  relative to the instance root.  prefixer : A function that accepts an object and returns a shallow clone with its keys prepended with  keypath .     The  wrap  function must return an object with four methods:   get : A function that returns the POJO representation of the adapted data.  set : A function that's called when the keypath being updated is a property of the adapted data.  property : The property name to be updated.  value : The new value.    reset : A function that's called when the keypath being updated is the adapted data itself. If  reset  returns  false , Ractive will replace the data on the keypath with the POJO version, and tear down the adaptor.  value : The new value    teardown : A function that's called when an adaptor is being removed.", 
            "title": "Writing"
        }, 
        {
            "location": "/legacy/0.9/plugins/#adaptors-only-adapt-one-level", 
            "text": "An adaptor only adapts an object's immediate properties. Updating nested data via Ractive or via the data source will not update the other.", 
            "title": "Adaptors only adapt one level"
        }, 
        {
            "location": "/legacy/0.9/plugins/#no-built-in-infinite-loop-detection", 
            "text": "There is no built-in mechanism for avoiding infinite loops. If your adaptor calls  ractive.set()  on adapted data, which in turn will call the adaptor's  set()  method, which may directly or indirectly trigger another  ractive.set()  on the same adapted data, a stack overflow error might occur.  This isn't a problem with primitive values since Ractive doesn't bother calling  set()  if a value hasn't changed. But with objects and arrays, there's no easy and performant way to tell if the contents have changed. So  set()  gets called  in case something changed  rather than  because something changed .", 
            "title": "No built-in infinite loop detection"
        }, 
        {
            "location": "/legacy/0.9/plugins/#different-for-every-back-end", 
            "text": "The adaptor structure only provides you with the means to talk to and listen from a custom back-end. It does not impose any rules on how to write an adaptor for a certain back-end. For instance, an adaptor for a constructor-based object may be written differently from an adaptor meant to interact with a socket server.", 
            "title": "Different for every back-end"
        }, 
        {
            "location": "/legacy/0.9/plugins/#registering", 
            "text": "Like other plugins, there's 3 ways you can register adaptors:", 
            "title": "Registering"
        }, 
        {
            "location": "/legacy/0.9/plugins/#globally-via-the-ractiveadaptors-static-property", 
            "text": "Ractive.adaptors.myAdaptor = myAdaptor", 
            "title": "Globally, via the Ractive.adaptors static property."
        }, 
        {
            "location": "/legacy/0.9/plugins/#per-component-via-the-components-adaptors-initialization-property", 
            "text": "const MyComponent = Ractive.extend({\n  adaptors: { myAdaptor }\n})", 
            "title": "Per component, via the component's adaptors initialization property."
        }, 
        {
            "location": "/legacy/0.9/plugins/#per-instance-via-the-instances-adaptors-initialization-property", 
            "text": "const ractive = Ractive({\n  adaptors: { myAdaptor }\n})", 
            "title": "Per instance, via the instance's adaptors initialization property."
        }, 
        {
            "location": "/legacy/0.9/plugins/#using", 
            "text": "In order to use an adaptor, you must tell the component or an instance to use it using the  adapt  initialization option.  const ractive = Ractive({\n  adapt: [ 'myAdaptor' ]\n})", 
            "title": "Using"
        }, 
        {
            "location": "/legacy/0.9/plugins/#examples", 
            "text": "In the following example, we have a  Box  constructor that uses accessors to get and set its  width  and  height  properties. Since an instance of  Box  will have no publicly visible properties, Ractive cannot bind to them directly.  function Box(width, height) {\n  var _width = width\n  var _height = height\n\n  this.getWidth = () =  { return _width; }\n  this.setWidth = (width) =  { _width = width; }\n  this.getHeight = () =  { return _height; }\n  this.setHeight = (height) =  { _height = height }\n}  In order for Ractive to properly use a  Box  instance, we build an adaptor for  Box .  Ractive.adaptors.boxAdaptor = {\n  filter ( object ) {\n    // Checks if the piece of data is an instance of Box.\n    return object instanceof Box\n  },\n  wrap ( ractive, box, keypath, prefixer ) {\n\n    // We keep a reference to the original functions before monkey-patching.\n    const setWidth = box.setWidth\n    const setHeight = box.setHeight\n\n    // Use ractive.set on the the adapted data whenever the setters are used.\n    box.setWidth = (width) =  {\n      ractive.set(prefixer({\n        width: width\n      }))\n    }\n\n    box.setHeight = (height) =  {\n      ractive.set(prefixer({\n        height: height\n      }))\n    }\n\n    return {\n      // Return a POJO representation of an instance of Box.\n      get () {\n        return {\n          width: box.getWidth(),\n          height: box.getHeight()\n        }\n      },\n      // Update the adapted object's properties\n      set (property, value) {\n        if(property === 'width') setWidth.call(box, value)\n        if(property === 'height') setHeight.call(box, value)\n      },\n      // Update the adapted object.\n      reset (data) {\n        // We don't adapt non-objects. And if the new data is an instance of Box\n        // there's a high chance that its a new instance. In either case, we\n        // need to tear down this adapter and have Ractive set it up again if\n        // necessary.\n        if(typeof data !== 'object' || data instanceof Box) return false\n\n        // Otherwise, we just parse through the data and update the existing box\n        // instance.\n        if(data.width !== undefined) setWidth.call(box, data.width)\n        if(data.height !== undefined) setHeight.call(box, data.height)\n      },\n      // Delete the monkey-patched methods.\n      teardown () {\n        delete box.setWidth\n        delete box.setHeight\n      }\n    }\n  }\n}  Then we use  boxAdaptor  on an instance. The data can now be treated like regular Ractive data. Updates done directly on  box  will reflect on Ractive. Any changes via Ractive will reflect on  box .  const ractive = Ractive({\n  el: 'body',\n  // Tell the instance we'll be using boxAdaptor\n  adapt: [ 'boxAdaptor' ],\n  // We write Ractive like normal.\n  template: `\n     div Box is {{ box.width }}x{{ box.height }} /div ,\n     div input type= text  value= {{ box.width }} /div \n     div input type= text  value= {{ box.height }} /div \n  `\n})\n\nconst box = new Box(3, 4)\n\n// Set the Box instance as if it were a POJO.\nractive.set('box', box)\n\n// Both box instance and box object will have 7 width and 11 height and will\n// be rendered in the UI accordingly.\nbox.setWidth(7)\nractive.set('box.height', 11)", 
            "title": "Examples"
        }, 
        {
            "location": "/legacy/0.9/plugins/#components", 
            "text": "In many situations, you want to encapsulate behaviour and markup into a single reusable  component , which can be dropped into Ractive applications. Components are simply custom-configured \"subclasses\" of Ractive (analogous, but technically incorrect).", 
            "title": "Components"
        }, 
        {
            "location": "/legacy/0.9/plugins/#writing_1", 
            "text": "There are several ways to write Ractive components. Standard initialization options apply for configuration unless where changes are explicitly mentioned.  The most common way to define a component is by using  Ractive.extend() .  // A subclass of Ractive\nconst MyComponent = Ractive.extend({\n  template: `\n     div class= my-component \n       span class= my-component__message {{ message }} /span \n     /div \n  `,\n  css: `\n    .my-component__message { color: red }\n  `,\n  data: { message: 'Hello World' }\n})  Another way to define a component is by using component files and loaders.  div class= my-component \n   span class= my-component__message {{ message }} /span  /div  style \n  .my-component__message { color: red } /style  script \ncomponent.exports = {\n  data: { message: 'Hello World' }\n} /script", 
            "title": "Writing"
        }, 
        {
            "location": "/legacy/0.9/plugins/#registering_1", 
            "text": "Like other plugins, there's 3 ways you can register components:", 
            "title": "Registering"
        }, 
        {
            "location": "/legacy/0.9/plugins/#globally-via-the-ractivecomponents-static-property", 
            "text": "// Available to all instances of Ractive.\nRactive.components.MyComponent = Ractive.extend({ ... })", 
            "title": "Globally, via the Ractive.components static property:"
        }, 
        {
            "location": "/legacy/0.9/plugins/#per-component-via-the-components-components-initialization-property", 
            "text": "// Only available for instances of AnotherComponent.\nconst AnotherComponent = Ractive.extend({\n  components: { MyComponent }\n})", 
            "title": "Per component, via the component's components initialization property."
        }, 
        {
            "location": "/legacy/0.9/plugins/#per-instance-via-the-instances-components-initialization-property", 
            "text": "// Only available to this specific instance.\nconst ractive = Ractive({\n  components: { MyComponent }\n})", 
            "title": "Per instance, via the instance's components initialization property."
        }, 
        {
            "location": "/legacy/0.9/plugins/#using_1", 
            "text": "Components are simply subclasses of Ractive, which means they are also instatiable.  const ractive = MyComponent({ ... })  But where components really shine is when they're used on templates. They are written like  custom elements . Each custom element notation represents one instance of the component.  const AnotherComponent = Ractive.extend({\n  template: `\n     div \n       MyComponent /   !-- One instance of MyComponent -- \n       MyComponent /   !-- Another instance of MyComponent -- \n       MyComponent /   !-- Yet another instance of MyComponent -- \n     /div \n  `\n})  The component's tag name depends on the name used upon registration. The same component can be registered more than once using different names.  const MyComponent = Ractive.extend({...})\nRactive.components.MyComponent = MyComponent\nRactive.components.MyComponentOtherName = MyComponent\n\nconst AnotherComponent = Ractive.extend({\n  template: `\n     div \n       MyComponent /            !-- Using MyComponent -- \n       MyComponentOtherName /   !-- Using MyComponent's other name -- \n     /div \n  `\n})", 
            "title": "Using"
        }, 
        {
            "location": "/legacy/0.9/plugins/#examples_1", 
            "text": "", 
            "title": "Examples"
        }, 
        {
            "location": "/legacy/0.9/plugins/#decorators", 
            "text": "A decorator is a simple way to add behaviour to a node when it is rendered, or to augment it in some way. Decorators are a good way to integrate DOM manipulation libraries with Ractive, such as  jQuery UI  or  Bootstrap .", 
            "title": "Decorators"
        }, 
        {
            "location": "/legacy/0.9/plugins/#writing_2", 
            "text": "const myDecorator = (node[, ...args]) =  {\n  // Setup code\n  return {\n    teardown () {\n      // Cleanup code\n    },\n    update ([...args]) {\n      // Update code\n    },\n    invalidate () {\n      // Code called on invalidate\n    }\n  }\n}  Decorators are simply functions that are called upon to setup the decorator once Ractive detects its use. It takes a  node  argument and returns an object with a  teardown  and  update  property.  node  is the element to which the decorator is applied to.  [args]  are optional arguments provided by the decorator directive.  teardown  is a function that gets called when the decorator is torn down.  update  is an optional function that gets called when the arguments update.  invalidate , starting with 0.9.3, is an optional function that gets called when any bit of template downstream from the node is being updated.  Any updates to the arguments will call the decorator's  teardown  and run the decorator function again, essentially setting up the decorator again. If an  update  function is provided on the return object, that will be called instead of the  teardown  and setup function.", 
            "title": "Writing"
        }, 
        {
            "location": "/legacy/0.9/plugins/#registering_2", 
            "text": "Like other plugins, there's 3 ways you can register decorators:", 
            "title": "Registering"
        }, 
        {
            "location": "/legacy/0.9/plugins/#globally-via-the-ractivedecorators-static-property", 
            "text": "Ractive.decorators.myDecorator = myDecorator", 
            "title": "Globally, via the Ractive.decorators static property."
        }, 
        {
            "location": "/legacy/0.9/plugins/#per-component-via-the-components-decorators-initialization-property", 
            "text": "const MyComponent = Ractive.extend({\n  decorators: { myDecorator }\n})", 
            "title": "Per component, via the component's decorators initialization property."
        }, 
        {
            "location": "/legacy/0.9/plugins/#per-instance-via-the-instances-decorators-initialization-property", 
            "text": "const ractive = Ractive({\n  decorators: { myDecorator }\n})", 
            "title": "Per instance, via the instance's decorators initialization property."
        }, 
        {
            "location": "/legacy/0.9/plugins/#using_2", 
            "text": "One or more decorators can be added to an element via the  as-*  directive. Arguments are passed to the decorator function by supplying comma-separated expressions as values. These expressions will become the second argument and onwards of the transition function.  !-- without arguments --  div as-myDecorator ... /div  !-- with arguments --  div as-myDecorator= arg1, .some.other.arg2, 10 * @index  as-somethingElseToo ... /div", 
            "title": "Using"
        }, 
        {
            "location": "/legacy/0.9/plugins/#examples_2", 
            "text": "The following example builds a decorator that updates the time.  Ractive.decorators.timer = (node, time) =  {\n  node.innerHTML = 'Hello World!'\n\n  return {\n    teardown () {\n      node.innerHTML = ''\n    },\n    update (time) {\n      node.innerHTML = time\n    }\n  }\n}\n\nconst ractive = Ractive({\n  el: 'body',\n  template: `\n     span as-timer= time /span \n  `,\n  data: {\n    time: 0\n  }\n})\n\nsetInterval(function () {\n  ractive.set('time', Date.now())\n}, 1000)", 
            "title": "Examples"
        }, 
        {
            "location": "/legacy/0.9/plugins/#easings", 
            "text": "Easing functions describe the animation's progression from start to finish. Easings are used by  ractive.animate  and some transitions. Out of the box, Ractive comes with  linear ,  easeIn ,  easeOut  and  easeInOut .", 
            "title": "Easings"
        }, 
        {
            "location": "/legacy/0.9/plugins/#writing_3", 
            "text": "const myEasing = ( t ) =  {\n  // Calculation\n  return v\n}  Easing functions receive  t , a value from  0  to  1 , which represents the linear progression of the animation from start to finish. The easing function must then return  v , a value also from  0  to  1 , which represents the progress of the animation for that easing.", 
            "title": "Writing"
        }, 
        {
            "location": "/legacy/0.9/plugins/#registering_3", 
            "text": "Like other plugins, there's 3 ways you can register an easing function:", 
            "title": "Registering"
        }, 
        {
            "location": "/legacy/0.9/plugins/#globally-via-the-ractiveeasing-static-property", 
            "text": "Ractive.easing.myEasing = myEasing", 
            "title": "Globally via the Ractive.easing static property."
        }, 
        {
            "location": "/legacy/0.9/plugins/#per-component-via-the-components-easing-initialization-property", 
            "text": "const MyComponent = Ractive.extend({\n  easing: { myEasing }\n})", 
            "title": "Per component via the component's easing initialization property."
        }, 
        {
            "location": "/legacy/0.9/plugins/#per-instance-via-the-instances-easing-initialization-property", 
            "text": "const ractive = Ractive({\n  easing: { myEasing }\n})", 
            "title": "Per instance, via the instance's easing initialization property."
        }, 
        {
            "location": "/legacy/0.9/plugins/#using_3", 
            "text": "Easing functions are utilized by  ractive.animate()  and transitions to define animations.  \nractive.animate('counter', 60, {\n  easing: 'myEasing'\n})", 
            "title": "Using"
        }, 
        {
            "location": "/legacy/0.9/plugins/#examples_3", 
            "text": "Here's an  elastic  easing function taken from  danro 's excellent  easing.js  library.  Ractive.easing.elastic = ( t ) =  {\n  return -1 * Math.pow(4,-8*t) * Math.sin((t*6-1)*(2*Math.PI)/2) + 1\n}", 
            "title": "Examples"
        }, 
        {
            "location": "/legacy/0.9/plugins/#events", 
            "text": "Events allow custom-named events on DOM elements. Common use cases for custom DOM events include normalizing cross-browser events, normalizing cross-device events, implementing custom events, and so much more.", 
            "title": "Events"
        }, 
        {
            "location": "/legacy/0.9/plugins/#writing_4", 
            "text": "const myEvent = (node, fire) =  {\n  // Setup code\n  return {\n    teardown () {\n      // Cleanup code\n    }\n  }\n}  Events are simply functions that are called to set up the event on a DOM element. The event function accepts two arguments:  node  and  fire , and returns an object containing a  teardown  property.  node  is the element to which the event is being applied.  fire  is the function that must be called when the event has taken place.  fire  takes a single argument, the event object received by handlers. The minimum requirement for the event object is a  node  property that references DOM node the event is attached to, and an  original  property which references the native DOM  event  object supplied by the native handler, if available.  The event object will be augmented with  context ,  keypath  and  index  properties, whose values depend on the data context the node is in.  context  references the data context that surrounds the node,  keypath  is a string that leads to the current data context and  index  is a number that references the index number of the data, should the data context be in an array.  teardown  is a function that gets called once the element is torn down. This allows the event to clean up after itself.", 
            "title": "Writing"
        }, 
        {
            "location": "/legacy/0.9/plugins/#registering_4", 
            "text": "Like other plugins, there's 3 ways you can register events:", 
            "title": "Registering"
        }, 
        {
            "location": "/legacy/0.9/plugins/#globally-via-the-ractiveevents-static-property", 
            "text": "Ractive.events.myEvent = myEvent", 
            "title": "Globally, via the Ractive.events static property."
        }, 
        {
            "location": "/legacy/0.9/plugins/#per-component-via-the-components-events-initialization-property", 
            "text": "const MyComponent = Ractive.extend({\n  events: { myEvent }\n})", 
            "title": "Per component, via the component's events initialization property."
        }, 
        {
            "location": "/legacy/0.9/plugins/#per-instance-via-the-instances-events-initialization-property", 
            "text": "const ractive = Ractive({\n  events: { myEvent }\n})", 
            "title": "Per instance, via the instance's events initialization property."
        }, 
        {
            "location": "/legacy/0.9/plugins/#using_4", 
            "text": "Events use the same  on-*  attribute syntax as component and DOM events. When Ractive encounters an  on-*  attribute on a DOM element, it looks for a registered event and applies it on the element. If no matching event name was found, Ractive will think the event name is a native DOM event and will attach one accordingly.  // This will apply the  myEvent  custom event if one is registered.\n// Otherwise, Ractive will think it's a DOM event. You have been warned! span on-myEvent= foo() Click me! /span", 
            "title": "Using"
        }, 
        {
            "location": "/legacy/0.9/plugins/#examples_4", 
            "text": "Here's an example of a \"long press\" event which fires when the mouse is clicked and held for 1 second.  // Definition\nRactive.events.longpress = (node, fire) =  {\n  let timer = null\n\n  function clearTimer () {\n    if(timer) clearTimeout(timer)\n    timer = null\n  }\n\n  function mouseDownHandler(event) {\n    clearTimer()\n\n    timer = setTimeout(() =  {\n      fire({\n        node: node,\n        original: event\n      })\n    }, 1000)\n  }\n\n  function mouseUpHandler () {\n    clearTimer()\n  }\n\n  node.addEventListener('mousedown', mouseDownHandler)\n  node.addEventListener('mouseup', mouseUpHandler)\n\n  return {\n    teardown () {\n      node.removeEventListener('mousedown', mouseDownHandler)\n      node.removeEventListener('mouseup', mouseUpHandler)\n    }\n  }\n}\n\n// Usage:\nRactive({\n  el: 'body',\n  template: `\n     button type= button  on-longpress= @this.greetz() Click Me! /button \n  `,\n  greetz () {\n    console.log('Hello World!')\n  }\n})", 
            "title": "Examples"
        }, 
        {
            "location": "/legacy/0.9/plugins/#interpolators", 
            "text": "Interpolator functions describe a value's progression during an animation from start to finish. Interpolator functions also determine the value on the model as well as what gets rendered during the animation.", 
            "title": "Interpolators"
        }, 
        {
            "location": "/legacy/0.9/plugins/#writing_5", 
            "text": "const myInterpolator = (from, to) =  {\n\n  return t =  {\n    return valueAtTimeT\n  }\n}  Interpolator plugins accept  from  and  to .  from  is the value on the animated keypath before calling  ractive.animate()  and  to  is the value being set by  ractive.animate() . The plugin must return a function that receives  t  and returns a value that represents the animated value at  t .  t  is a value from  0  to  1  representing the animation's progress with easing already applied.", 
            "title": "Writing"
        }, 
        {
            "location": "/legacy/0.9/plugins/#registering_5", 
            "text": "Like other plugins, there's 3 ways you can register an interpolator function:", 
            "title": "Registering"
        }, 
        {
            "location": "/legacy/0.9/plugins/#globally-via-the-ractiveinterpolators-static-property", 
            "text": "Ractive.interpolators.myInterpolator = myInterpolator", 
            "title": "Globally via the Ractive.interpolators static property."
        }, 
        {
            "location": "/legacy/0.9/plugins/#per-component-via-the-components-interpolators-initialization-property", 
            "text": "const MyComponent = Ractive.extend({\n  interpolators: { myInterpolator }\n})", 
            "title": "Per component via the component's interpolators initialization property."
        }, 
        {
            "location": "/legacy/0.9/plugins/#per-instance-via-the-instances-interpolators-initialization-property", 
            "text": "const ractive = Ractive({\n  interpolators: { myInterpolator }\n})", 
            "title": "Per instance, via the instance's interpolators initialization property."
        }, 
        {
            "location": "/legacy/0.9/plugins/#using_5", 
            "text": "Interpolator functions are utilized by  ractive.animate()  by supplying the interpolator name to the  interpolator  option.  ractive.animate('counter', 60, {\n  interpolator: 'myInterpolator'\n})", 
            "title": "Using"
        }, 
        {
            "location": "/legacy/0.9/plugins/#examples_5", 
            "text": "Here's an abridged version of Ractive's built-in  number  interpolator which interpolates numeric values (numbers and number-like strings) during animation.  Ractive.interpolators.number = (from, to) =  {\n  const start = Number(from)\n  const end = Number(to)\n\n  if (Number.isNaN(start) || Number.isNaN(end)) return null\n\n  const delta = end - start\n  const noChangeInterpolator = () =  start\n  const changeInterpolator = t =  start + (t * delta)\n  return delta ? changeInterpolator : noChangeInterpolator\n}", 
            "title": "Examples"
        }, 
        {
            "location": "/legacy/0.9/plugins/#partials", 
            "text": "A partial is a template snippet which can be reused in templates or in other partials. They help to keep templates uncluttered, non-repetetive and easy to read.", 
            "title": "Partials"
        }, 
        {
            "location": "/legacy/0.9/plugins/#writing_6", 
            "text": "const myPartial = ' !-- template -- '  Partials are simply Ractive templates.", 
            "title": "Writing"
        }, 
        {
            "location": "/legacy/0.9/plugins/#registering_6", 
            "text": "Unlike other plugins, partials have more than 3 registration options.", 
            "title": "Registering"
        }, 
        {
            "location": "/legacy/0.9/plugins/#globally-via-the-ractivepartials-static-property", 
            "text": "Ractive.partials.myPartial = MyPartial", 
            "title": "Globally via the Ractive.partials static property."
        }, 
        {
            "location": "/legacy/0.9/plugins/#globally-via-a-non-executing-script-tag-on-the-current-page", 
            "text": "script type= ractive/template  id= myPartial \n  ... /script", 
            "title": "Globally, via a non-executing script tag on the current page."
        }, 
        {
            "location": "/legacy/0.9/plugins/#per-component-via-the-components-partials-initialization-property", 
            "text": "const MyComponent = Ractive.extend({\n  partials: { myPartial }\n})", 
            "title": "Per component, via the component's partials initialization property."
        }, 
        {
            "location": "/legacy/0.9/plugins/#per-instance-via-the-instances-partials-initialization-property", 
            "text": "const ractive = Ractive({\n  partials: { myPartial }\n})", 
            "title": "Per instance, via the instance's partials initialization property."
        }, 
        {
            "location": "/legacy/0.9/plugins/#in-template-using-the-partial-mustache", 
            "text": "{{#partial myPartial}}\n  ...\n{{/}}", 
            "title": "In-template, using the {{#partial}} mustache."
        }, 
        {
            "location": "/legacy/0.9/plugins/#using_6", 
            "text": "Partials can be used using  {{ partialName}} . Partials work where any template would work and takes on its surrounding context.  {{#partial myPartial}}\n   div class= message {{message}} /div \n{{/partial}} div class= app \n  {{ myPartial}} /div", 
            "title": "Using"
        }, 
        {
            "location": "/legacy/0.9/plugins/#valid-names", 
            "text": "Partials may be named with the same rules as any other identifier in Ractive or JavaScript, but since there isn't much danger of trying to do math in a partial name, they enjoy relaxed naming requirements that allow otherwise reserved globals and keywords to be used for partial names.  Partial names may also contain  -  and  /  characters as long as they are surrounded by other valid characters e.g.  templates/some-partial-template .", 
            "title": "Valid names"
        }, 
        {
            "location": "/legacy/0.9/plugins/#context", 
            "text": "Partials be given an explicit context. Simply supply a reference to the context following the partial name on usage.  Ractive({\n  data: {\n    foo:{\n      bar: 'Hello, World!'\n    }\n  },\n  template: `\n    {{#partial myPartial}}{{bar}}{{/partial}}\n\n    {{ myPartial foo}}\n  `\n})", 
            "title": "Context"
        }, 
        {
            "location": "/legacy/0.9/plugins/#aliases", 
            "text": "References can also be aliased in partials. Simply define aliases as comma-separated  reference as alias  pairs following the partial name on usage.  Ractive({\n  data: {\n    status: 'Me, Hungry!',\n    foo:{\n      bar: 'Hello, World!'\n    }\n  },\n  template: `\n    {{#partial myPartial}}{{msg}} {{state}}{{/partial}}\n\n    {{ myPartial foo.bar as msg, status as state}}\n  `\n})", 
            "title": "Aliases"
        }, 
        {
            "location": "/legacy/0.9/plugins/#recursive-partials", 
            "text": "Partials can be used recursively. A common use case for this is when reusing partials on a tree-like structure, like a directory listing.  div class='fileSystem' \n  {{#root}}\n    {{ folder}}\n  {{/root}} /div \n\n{{#partial folder}} ul class='folder' \n  {{#files}}\n    {{ file}}\n  {{/files}} /ul \n{{/partial}}\n\n{{#partial file}} li class='file' \n   img class='icon-{{type}}' \n   span {{filename}} /span \n\n   !-- if this is actually a folder, embed the folder partial -- \n  {{# type === 'folder' }}\n    {{ folder}}\n  {{/ type === 'folder' }} /li \n{{/partial}}  rv = Ractive({\n  el: 'container',\n  template: '#myTemplate',\n  data: {\n    root: {\n      files: [\n        { type: 'jpg', filename: 'hello.jpg' },\n        { type: 'mp3', filename: 'NeverGonna.mp3' },\n        { type: 'folder', filename: 'subfolder', files: [\n          { type: 'txt', filename: 'README.txt' },\n          { type: 'folder', filename: 'rabbithole', files: [\n            { type: 'txt', filename: 'Inception.txt' }\n          ]}\n        ]}\n      ]\n    }\n  }\n})  In the example above, subfolders use the  {{ folder}}  partial, which uses the  {{ file}}  partial for each file, and if any of those files are folders, the  {{ folder}}  partial will be invoked again, and so on until there are no more files.  Beware of cyclical data structures! Ractive makes no attempt to detect cyclicality, and will happily continue rendering partials until the  Big Crunch  (or your browser exceeds its maximum call stack size. Whichever is sooner).", 
            "title": "Recursive partials"
        }, 
        {
            "location": "/legacy/0.9/plugins/#injecting-partials", 
            "text": "One good use of partials is to vary the shape of a template according to some condition, the same way you might use  dependency injection  elsewhere in your code.  For example, you might offer a different view to mobile users:  div class='main' \n   div class='content' \n    {{ content}}\n   /div \n\n   div class='sidebar' \n    {{ sidebar}}\n   /div  /div   isMobile = /mobile/i.test( navigator.userAgent ); // please don't do this in real life!\n\nractive = Ractive({\n  el: myContainer,\n  template: myTemplate,\n  partials: {\n    content: isMobile ? mobileContentPartial : desktopContentPartial,\n    sidebar: isMobile ? mobileSidebarPartial : desktopSidebarPartial\n  }\n})  Or you might make it possible to extend a subclass without overriding its template:  div class='modal-background' \n   div class='modal' \n    {{ modalContent}}\n   /div  /div   // Create a Modal subclass\nModal = Ractive.extend({\n  template: modalTemplate,\n  init () {\n    var self = this, resizeHandler\n\n    resizeHandler = () =  {\n      self.center()\n    }\n\n    // when the window resizes, keep the modal horizontally and vertically centred\n    window.addEventListener( 'resize', resizeHandler )\n\n    // clean up after ourselves later\n    this.on( 'teardown', function () {\n      window.removeEventListener( 'resize', resizeHandler )\n    })\n\n    // manually call this.center() the first time\n    this.center()\n  },\n  center () {\n    // centering logic goes here\n  }\n})\n\nhelloModal = Modal({\n  el: document.body,\n  partials: {\n    modalContent: ' p Hello! /p a class= modal-button  proxy-tap= close Close /a '\n  }\n})\n\nhelloModal.on( 'close', function () {\n  this.teardown()\n})", 
            "title": "Injecting partials"
        }, 
        {
            "location": "/legacy/0.9/plugins/#partial-expressions", 
            "text": "Expressions can also be used to reference a partial instead of fixed partial names. Ractive will evaluate the expression and use its return value to select a partial. This is useful when you want the data to indicate what type of partial it should render with.  In the following example,  organisms  contains a list of organisms whose  type  can either be  person  or  animal . Partials for each type is defined and the list uses the  type  of each item to determine which partial to use.  {{#partial person}}Hi! I am {{.name}} and I have {{.fingerCount}} fingers!{{/}}\n\n{{#partial animal}}Hi! I am a {{.name}} and I have {{.legCount}} legs!{{/}} ul \n  {{# organisms }}\n     li {{  type }} /li \n  {{/}} /ul   In the case where there's a collision between the expression and a partial of the same name, Ractive will not evaluate the expression and instead, will immediately resolve to that partial.  In the following example, a partial named  type  is defined. Instead of evaluating  type 's value, it will resolve to the partial named  type .  {{#partial person}}Hi! I am {{.name}} and I have {{.fingerCount}} fingers!{{/}}\n\n{{#partial animal}}Hi! I am a {{.name}} and I have {{.legCount}} legs!{{/}}\n\n{{#partial type}}Hi! I am {{.name}}{{/}} ul \n  {{# organisms }}\n     li {{  type }} /li \n  {{/}} /ul   Partials can also be registered on-the-fly as well as have functions determine the partial to use.  In the following example,  makePartial  registers a partial on the fly using  template  and  id , and returns the partial name for use in the template.  Ractive({\n  el: 'main',\n  template: `\n     span Add a partial: /span \n     textarea value= {{tpl}}  / /div \n     button on-click= @this.add() Add /button br/ \n\n    {{#list}}\n      {{  @this.makePartial(.id, .template) }}\n    {{/}}\n  `,\n  data: {\n    list: [],\n    tpl: '',\n\n  },\n  add () {\n    this.push('list', {\n      id: Math.random(),\n      template: this.get('tpl')\n    })\n    this.set('tpl', '')\n  },\n  makePartial (id, template) {\n    const name = 'partial-' + id\n    this.partials[name] = this.partials[name] || template\n    return name\n  }\n})", 
            "title": "Partial expressions"
        }, 
        {
            "location": "/legacy/0.9/plugins/#updating-partials", 
            "text": "Partials may be reset after they are rendered using  ractive.resetPartial() . A reset partial will update everywhere it is referenced, so if it is used multiple times or inherited by a component, those instances will be updated as well. If a component has a partial with the same name as a parent partial, partial resets will not affect it since it is a different partial.  It should be noted that partials evaluate lazily, so it is possible to cause a single partial to update by wrapping it in a conditional section and causing the section to be hidden and re-shown.  {{^toggle}}{{ rickroll}}{{/}}  ractive.partials.rickroll = 'I wouldn\\'t do that to you, chum.'\nractive.set('toggle', true)\nractive.set('toggle', false)", 
            "title": "Updating Partials"
        }, 
        {
            "location": "/legacy/0.9/plugins/#examples_6", 
            "text": "Here's an example of a gallery using a partial for its thumbnail information:  !-- The partial called  thumbnail  --  figure class='thumbnail' \n   img src='assets/thumbnails/{{id}}.jpg' \n   figcaption {{description}} /figcaption  /figure  !-- The template that uses the partial --  div class='gallery' \n  {{#items}}\n    {{ thumbnail}}\n  {{/items}} /div", 
            "title": "Examples"
        }, 
        {
            "location": "/legacy/0.9/plugins/#transitions", 
            "text": "Transitions allow you to control how enter the DOM and how they leave the DOM. This allows you to define intro and outro behavior, particularly animations, when elements go in and out of the page.", 
            "title": "Transitions"
        }, 
        {
            "location": "/legacy/0.9/plugins/#writing_7", 
            "text": "const myTransition = ( t[, ...args]] ) =  {\n  // Manipulate the DOM.\n  // Call t.complete() when completed.\n}  Transitions are simply functions that get called to animate a specified element.  t  is a transition helper object that aids in the implementation of the transition.  [args]  is the arguments passed in via the transition directive.  Transitions are expected to be asynchronous. In order to signal Ractive that the transition has completed, the transition must call the  t.complete() .  Note that transitions control the element's arrival and departure to the page. That means upon completion, any styling done to the element will be removed automatically.", 
            "title": "Writing"
        }, 
        {
            "location": "/legacy/0.9/plugins/#registering_7", 
            "text": "Like other plugins, there's 3 ways you can register transitions:", 
            "title": "Registering"
        }, 
        {
            "location": "/legacy/0.9/plugins/#globally-via-the-ractivetransitions-static-property", 
            "text": "Ractive.transitions.myTransition = myTransition", 
            "title": "Globally, via the Ractive.transitions static property."
        }, 
        {
            "location": "/legacy/0.9/plugins/#per-component-via-the-components-transitions-initialization-property", 
            "text": "const MyComponent = Ractive.extend({\n  transitions: { myTransition }\n})", 
            "title": "Per component, via the component's transitions initialization property."
        }, 
        {
            "location": "/legacy/0.9/plugins/#per-instance-via-the-instances-transitions-initialization-property", 
            "text": "const ractive = Ractive({\n  transitions: { myTransition }\n})", 
            "title": "Per instance, via the instance's transitions initialization property."
        }, 
        {
            "location": "/legacy/0.9/plugins/#using_7", 
            "text": "Transitions are added to an element via the  *-in ,  *-out  or  *-in-out  directives. The transition may be applied on element render ( -in ), on element removal ( -out ), or both ( -in-out ).  div myTransition-in Intro-only /div  div myTransition-out Outro-only /div  div myTransition-in-out Intro and outro /div   Arguments are passed to the transition function by supplying comma-separated expressions as values to  *-in ,  *-out  or  *-in-out . These expressions will become the second argument and onwards of the transition function.  div myTransition-in-out= 'Hello, World!', 42 Hello, World! /div", 
            "title": "Using"
        }, 
        {
            "location": "/legacy/0.9/plugins/#examples_7", 
            "text": "The following example demonstrates a \"flash\" transition which colors the element green upon attachment, and red prior to removal.  Ractive.transitions.flash = (t, params) =  {\n  // Process params and declaring defaults.\n  const options = t.processParams(params, {\n    color: t.isIntro ? '#0f0' : '#f00',\n    duration: 400\n  })\n\n  // The  transition \n  t.setStyle('color', options.color)\n\n  // Signal Ractive that the transition is complete.\n  setTimeout(t.complete, options.duration)\n}\n\nRactive({\n  el: 'body',\n  template: `\n     button on-click='@this.insert()' Insert item /button \n     button on-click='@this.remove()' Remove item /button \n     ul \n      {{#items}}\n       li flash-in-out {{this}} /li \n      {{/items}}\n     /ul \n  `,\n  data: {\n    items: []\n  },\n  insert () {\n    this.push('items', Date.now())\n  },\n  remove () {\n    this.splice('items', 0, 1)\n  }\n})", 
            "title": "Examples"
        }, 
        {
            "location": "/legacy/0.9/concepts/", 
            "text": "Architecture\n\n\nThere are three major sections in the Ractive source code: The parser which handles template parsing, the models which handle data management and the views which handle the virtual DOM. This document aims to give a breakdown of just what exactly each of these sections do.\n\n\nParser\n\n\nRactive's parser is reponsible for taking in Mustache-like/Handlebar-like templates. Unlike Mustache and Handlebars, however, it turns them into an \nAST\n for use by the runtime. In addition, it also supports a fair amount of ES syntax for use in expressions.\n\n\nEach item expressable in Ractive-flavored mustache has its own parsing function that may also be comprised of other parsing functions. Each bit of ES syntax that Ractive understands for expressions also has its own parsing function. The parser starts at the beginning of the template string and starts applying each parsing function in precedence order. Each function will then consume as much of the template as needed to return an item, like an element, a section, a partial, a bit of text, or an interpolator. It may also return nothing. Most items can also contain children, including items of the same type as themselves, and will thus recurse by trying to parse their content.\n\n\nMustaches\n\n\nEach type of mustache has its own reader that calls the appropriate expression or reference readers internally. For instance, the partial reader reads the current open mustache delimiter (defaults to \n{{\n) followed by a \n. It then expects to find a relaxed reference, meaning it may contain dashes and slashes among other usually-forbidden characters. It may then optionally read a context expression or series of alias definitions\n\n\nExpressions\n\n\nThe expression readers are set arranged such that they can read valid ES expressions with the correct operator precedence by starting with ternary conditionals and trying different expression types from there. Once the expression tree has been parsed, it is flattened into an expression string and a list of references that are used within that string. If the parsing is done with \ncsp\n (Content Security Policy) support enabled, then the expression strings are also turned into functions and attached to the output template structure so that the template can be used as-is from a script tag without \neval\ning.\n\n\nCleanup\n\n\nAfter all of the nodes have been parsed from the template, the template is cleaned up in a process that, among other things, merges adjacent text nodes and forms individual conditional sections out of \nelseif\n/\nelse\n trees.\n\n\nModels\n\n\nRactive wraps any data given to it into a tree-like hierarchy of \nModel\n. Any data that is rendered into a template will be bound to a \nModel\n. Access to read and write data in Ractive is handled through the model hierarchy based on keypaths, which are, generally, a list of object properties that one would need to follow to reach a leaf of the data tree starting from the root. Each key along the keypath has its own corresponding model.\n\n\nModels allow entities that depend upon them to register themeselves to receive change notifications when the model value changes. This is how Ractive keeps track of exactly which parts of the view need to be updated when values change.\n\n\nAll of the data managed by Ractive is represented by its model hierarchy.\n\n\nAlmost every type of Model is a subclass of \nModel\n, so it seems a good place to start. Each model typically has a parent model, a key that is used to access its value from its parent, and a value. Most models also have children of some sort, which are tracked by key such that \n{ foo: { bar: 'baz' } }\n would have a model with a \nchildByKey['foo']\n, which would also have a model at \nchildByKey['bar']\n. The value of each of the models listed there would be the object containing \nfoo: { bar:\nbaz\n}\n, its \nfoo\n child would be the object \nbar: 'baz'\n, and its \nbar\n child would be the string \n'baz'\n. Where children of a model are other models, dependents (\ndeps\n) of a model may be anything that wants to be notified of changes, and each model will typically have a number of dependents, too.\n\n\nEach model has a unique keypath that is assembled by taking its key and each of its parents keys up to the root and joining them with a \n.\n.\n\n\nModels are also inherently lazy, meaning their value is not necessarily available when the are created. A value is retrieved from a model using its \nget\n method which may have the side effect of computing the value. Once a value has been computed, it is generally cached until a change happens that would cause the cache to be invalidated. In most models, there isn't really an opportunity for that change outside of normal change propagation.\n\n\nRootModel\n\n\nEvery tree needs a root, and \nRootModel\n serves that purpose here. Each Ractive instance gets its own \nRootModel\n that is stored at its \nviewmodel\n property. This special model is also the storage point for computations and mappings.\n\n\nKeyModel\n\n\nThe last major model remaining is the \nKeyModel\n. Instances of this represent indices of arrays and keys of objects during iteration. The key flavor never is immutable, becuase the keys of  objects never change (they may be removed, but that doesn't change the key itself). The index flavor \ndoes\n change, but only when the array represented by its parent model is shuffled.\n\n\nOther models\n\n\nThere are a few other types of \nModel\n in the code, such as the \nRactiveModel\n, which represents a Ractive instance, and the \nGlobalModel\n, which represents the global object of the current environment a.k.a. \nwindow\n for browsers and \nglobal\n for Node.js.\n\n\nModel operations\n\n\nChange propagation\n\n\nWhen a change is supplied to a model, its \nset\n method is called, which usually delegates to \napplyValue\n. \napplyValue\n checks to see that the value has actually changed in some way (hint: setting to the same object or array is considered a change because something may have changed further in), and if it has, it will start change notification for all of the model's children and dependents. If the model has resolvers registered with it trying to get an unresolved value, then this is where the unresolved value will be resolved and the resolver satisfied and cleared. Next, any children will be notified that their parent has had a value change and that they may need to update accordingly, which may trigger further cascades of resolution and change notification. Next, any dependents of the model will be notified that the model has had a value change as their \nhandleChange\n methods are called. Finally, upstream models (parents) are notified that a change has taken place somewhere among its children.\n\n\nThe child notification of the propagation is handled by the model's \nmark\n method. \nmark\n also checks to see that the value has actually changed, and if it has, will notify its children and dependents that it has had a value change. This is also the method called when the user signals that they have changed some data externally by calling \nractive.update()\n.\n\n\nShuffling\n\n\nThere is a special form of change wherein an array is modified without being swapped out, which is triggered by array methods like \nsplice\n, \npush\n, and \npop\n. When an array modification happens, change propagation takes a special path through the model that allows more precise DOM manipulation rather than throwing all of the DOM out and replacing it with a new result. This is achieved by having the special array method handlers compute which indexes are actually changed and having the array model's deps that can actally handle a shuffle ignore any untouched indices.\n\n\nThe instance method \nmerge\n does something similar, but instead of modifying the underlying array, it compares the members of the new supplied array against the model array to compute the index changes. It the swaps in the new array and triggers a shuffle based on the computed index changes.\n\n\nAdaptation\n\n\nBetween the change check and the change propagation during \napplyValue\n, there is a step that handles part of adaptation so that external objects with special behaviors, like backbone models, can be used as data sources. An adaptors takes the special object, wraps it up, and returns the wrapper that also has a value that represents the object for consumption by Ractive. Most adaptors also have methods to update values in their source data as well, and those methods are called when an update is applied to an adapted model.\n\n\nComputations\n\n\nA computation is exactly what is sounds like: a getter and optional setter function that are used to provide read and optional write access to some non-fixed piece of data. Each computation is stored in the root model \ncomputations\n hash by its keypath. Computations can be created in two places:\n\n\n\n\nExplicitly when a \ncomputed\n map is passed to a Ractive instantiation or when an entry is later added to a instance's computed map. These may be read/write and have a keypath that mirrors their name.\n\n\nImplicitly when an expression is used in a template. These are read-only and have a keypath that is an expanded representation of their expression.\n\n\n\n\nA computation is also a form of model, so anything that depends on it will subscribe to it as if it were a regular model. Change propagation happens in the same way as a regular model as well.\n\n\nSince computations may depend on other bits of data controlled by Ractive, while they are being retrieved, any references to other models will cause the extra references to be \ncapture\nd. When the computation is complete, the computation will register with each of its captured dependencies so that it will be notified when it needs to invalidate and notify its dependents of the change.\n\n\nMappings\n\n\nWhen a Ractive instance has children, typically components, it may supply a handles to its own data to them in the form of mappings. The child instance stores a reference to the parent model at its mapped name and uses it when its dependents request access to keypaths that start with the mapped name. This allows child instances, which may be isolated, to stay in sync with portions of their parents data easily, because the parent still controls the data (single source of truth) and there is no syncing involved. So if a parent has a component \nComponent foo=\"{{bar.baz.bat.bippy}}\" /\n, then the component instance will get a mapping \nfoo\n that references the parent model at \nbar.baz.bat.bippy\n.\n\n\nVirtual DOM\n\n\nEvery piece of DOM that Ractive can manage has a corresponding class in the virtual DOM to handle the DOM node, which generally end up being either Elements or Text Nodes. View items are grouped together as Fragments of view, which may then be owned by other fragments or items. At the root of every ractive instance is a Fragment instance that contains its entire virtual DOM tree. Each Ractive template construct has at least one analog in the virtual DOM. The bulk of Ractive's view functionality is implemented in the Section, Interpolator, and Element items, with there being a number of specialized element classes to handle special types of HTML element.\n\n\nAll virtual DOM items go through roughly the same lifecycle: creation, binding, rendering, bubbling, updating, unrendering, and unbinding. Creation is basically just the constructor call and almost always is immediately followed by binding. Binding is the point at which the item resolves and registers with its data references. Rendering is the point at which the item inserts an actual DOM node into the DOM. Bubbling and updating are the two halves of the update process, which is discussed in the next section. Unrendering is the point at which the item should no longer be present in the DOM, and it often occurs at the same point as unbinding, which is the point at which the item unregisters with the viewmodel and is effectively destroyed.\n\n\nThere a number of other members, such as events and decorators, and processes, such as change propagation, which are described in detail in the view overview.\n\n\nRactive views are structured virtual DOM trees that are assembled from template AST and manage DOM nodes on the page when they are rendered. Virtual DOM items are grouped together in \nFragment\ns, which contain them, and they may also own \nFragment\ns that contain other items. Each item may contain a reference to a DOM node when rendered, though every item doesn not have a DOM analog.\n\n\nParallel DOM\n\n\nRactive works by maintaining a simplified model of the part of the DOM that it's responsible for. This model contains all the information - about data-binding, event handling and so on - that it needs to keep things up-to-date.\n\n\nYou can inspect the parallel DOM to understand what's going on under the hood, if you're into that sort of thing. Each Ractive instance, once rendered, has a \nfragment\n property. Each fragment has a number of properties:\n\n\n\n\ncontextStack\n - the context stack in which mustache references should be evaluated\n\n\nroot\n - a reference to the Ractive instance to which it belongs\n\n\nowner\n - the \nitem\n that owns this fragment (in the case of the root fragment, the same as \nroot\n)\n\n\nitems\n - the items belonging to this fragment\n\n\n\n\nItems\n means elements, text nodes, and mustaches. Elements may have fragments of their own (i.e. if they have children). A partial mustache will have a fragment, and a section mustache will have zero or more fragments depending on the value of its keypath.\n\n\nElements may also have attributes, which have a different kind of fragment (a \ntext fragment\n as opposed to a \nDOM fragment\n), containing text and mustaches.\n\n\nEach item has a \ndescriptor\n, which is something like DNA. This comes straight from the parsed template.\n\n\nThis is the briefest of overviews - if you want to gain a deeper understanding of what's going on under the hood, \nuse the source\n.\n\n\nStates\n\n\nItems generally follow a fixed lifecycle.\n\n\n\n\nConstruction - the item is created and knows about its parent and the template chunk from which it was created. Its template may also indicate what its children should look like if it has them.\n\n\nbind\n - the item looks up any references is may have and registers with the model(s) that they represent. At this point, the item may create child items and bind them as well.\n\n\nrender\n - the item may create an actual DOM node and tell its children to create their DOM nodes as necessary. The resulting nodes will be inserted into the document.\n\n\nunrender\n - thie item is no longer needed and will be removed from the document immediately or in the near future.\n\n\nunbind\n - this typically goes along with \nunrender\n and tells the models on which this item depends that they should no longer send change notifications to it.\n\n\n\n\nThere is a sixth floating step \nrebind\n that happens any time one dependency models shuffles (and in certain other very special circumstances) that causes the items to re-resolve their models and re-register if necessary.\n\n\nVirtual DOM Items\n\n\nText\n\n\nText is the simplest item. It simply holds a string that it turns into a \nTextNode\n when rendered.\n\n\nInterpolator\n\n\nThis is the next simplest item. It resolves a model for its reference or expression and renders the value of the model as a text node if needed. Interpolators don't necessarily render directly, as they may be used for values by other items, such as attributes, mappings, and bindings.\n\n\nElement\n\n\nAn \nElement\n represents a DOM element. It also contains a number of other items in the form of \nAttribute\ns, \nDecorator\ns, \nTransition\ns, \nEventDirective\ns, and its children in a \nFragment\n.\n\n\nAttributes\n\n\nThere are actually several different items that are treated as attributes for \nElement\ns, event though only two of them actually may render into the DOM.\n\n\n\n\nAttribute\ns - maybe obvious, they these represent a DOM attribute on their parent element. There are a number of different handlers for updating attributes depending on the element and attribute name. The \nupdateDelegate\n for a particular attribute can be found in \ngetUpdateDelegate.js\n.\n\n\nConditionalAttribute\ns - render as a string and are parsed into actual DOM attributes using a \ndiv\n or an \nsvg\n depending on their parent element.\n\n\nMapping\ns - when rendered add a mapping to their component, and when unrendered, remove it. These aren't attached to \nElement\ns, but instead, are attached to \nComponent\ns (see below).\n\n\nEventDirective\ns - when rendered attach an event listener to their parent, and when unrenedered, remove it. Event parameters are kept in sync with their bindings and are evaluated when the event fires.\n\n\nBindingDirective\ns - when rendered and unrendered update their parent element's bindings, if they exist.\n\n\nDecorator\ns - when rendered call the named decorator with their parent element, and when unrenedered, remove it. \nDecorator\ns also have an update cycle related to their parameters.\n\n\nTransition\ns - are a sort of weird case. When rendered, they attach a transition handler to their element, and when the element renders or unrenders, if an appropriate transition handler is registered, will trigger the transition. Transition parameters are also kept in sync with their bindings.\n\n\n\n\nBindings\n\n\nCertain attributes may also trigger a binding to be created on their parent element. For instance, if two-way binding is enabled on the parent element, and the parent element is an \ninput\n, a \nvalue\n attribute with a single \nInterpolator\n as its content will cause a two-way binding to be created between the value of the \ninput\n and the model of the \nInterpolator\n. This binding will handle updating the model when the input \nvalue\n has changed. There are a few other types of bindings for managing check values, content editables, name-bound lists of checkboxes, and other miscellaneous special values.\n\n\nA \nlazy\n binding directive will cause any associated two-way bindings to fire either after a timeout or on blur, depending on the value of the \nlazy\n directive.\n\n\nSection\n\n\nSection\ns come in many flavors, depending on the chunk of template from which they are created. A section may provide context, be conditional (positive or negative), or be iterative. Generic sections (\n{{#something}}...{{/}}\n in template) will adjust their type, to a certain extent, based on the value of their model. A generic section will always provide context in the form of their model. An \nif\n-style conditional section, including \nelseif\n, \nelse\n, and \nunless\n do not provide context. An \neach\n section will always provide context in the form of the current iteration. A \nwith\n section will always provide context as its model, but it will only render if its model is considered truthy by Ractive, which is pretty much the same as JS truthy except \n{}\n and \n[]\n are falsey. A generic section will be context/conditional if it is anything other than an array, which will make it iterative.\n\n\nSections that provide context do so by binding their \nFragment\ns with their model so that the reference resolution process can find the appropriate contexts when resolving.\n\n\nContext/Conditional\n\n\nContext and conditional sections will render and unrender their child fragment as their model changes truthiness. Conditional sections always stand alone, even it they have \nelseif\n or \nelse\n branches nested within them, because those branches are turned into independent sections during parsing.\n\n\nIterative\n\n\nIf section is designated iterative (\n{{#each ...}}\n) or is a general section with an array value resolution, the section will create a special form of fragment for each index or key in the value. The special form \nRepeatedFragment\n handles mapping of indices, keys, and references to those to a corresponding model. Iterative sections also have special handling for shuffles so that DOM is not wholesale destroyed and recreated when the array shuffles.\n\n\nIterative sections may supply an alias for their context, so that referencing the iterated value is a little bit easier. See \nAliases\n below for more info, as this is just a slightly specialized form of that.\n\n\nIterative sections may also supply key and/or index aliases so that their keys and/or indices may be referenced by a name from within their child fragments.\n\n\nAlias\n\n\nAlias sections simply resolve their models and act as a lookup endpoint for reference resolution. Aliasing happens entirely in the view.\n\n\nComponent\n\n\nA component is a sort-of special form of \nElement\n that, instead of creating a DOM element, creates a new Ractive instance. The child instance will be rendered and unrendered in place of the component placeholder in the DOM.\n\n\nAny plain \nAttribute\ns with a single \nInterpolator\n as content in a component's template are turned into \nMapping\ns.\n\n\nThe resolution process no longer happens strictly within the vDOM, as the result of \nRactive.getContext\n also uses the target \nElement\n's fragment to resolve relative references. Event objects are also extended with methods from the same helper.\n\n\nUpdates\n\n\nThe \nrunloop\n controls when the DOM is actually updated and when transitions start in \nbatch\nes. It also handles resolving promises when transitions have completed and the DOM is completely up to date.\n\n\nAs changes propagate through the viewmodel, view items are notified of the change through their \nhandleChange\n method. Most items just set a dirty flag and notify their parent, via their \nbubble\n method, that they will need to be updated at the completion of the runloop turn. The root fragment of each instance affected will then register with the runloop. Once the changes are ready to be flushed to the view, each fragment registered with the runloop is called on to update, where the process happens in reverse, with each parent fragment checking to see if there is a change it needs to respond to and propagating the update downward to its children.\n\n\nData management\n\n\nDependents\n\n\nRactive maintains a dependency graph in order to do only the minimum amount of work necessary to keep the DOM up-to-date. If you inspect a Ractive instance, you'll see a property called \n_deps\n. This is where all dependants are listed, indexed by their dependency.\n\n\nExpression dependencies\n\n\nRactive uses dynamic analysis to determine dependencies. Depedendencies are determined by capturing references in the viewmodel while the function is executing. Dependencies for functions are re-captured each time the function is executed.\n\n\np\n{{ formattedName() }}\n/p\n\n\n\n\n\nvar ractive = Ractive({\n  template: template,\n  el: output,\n  data: {\n    user: { firstName: 'John', lastName: 'Public' },\n    formattedName () {\n      return this.get('user.lastName') + ', ' + this.get('user.firstName')\n    }\n  }\n}\n\n\n\n\nResult:\n\n\np\nPublic, John\n/p\n\n\n\n\n\nIn this example, the function \nformattedName\n will depend on both \nuser.firstName\n and \nuser.lastName\n, and updating either (or \nuser\n) will cause any expressions referencing \nformattedName\n to be re-evaluated as well.\n\n\nractive.set('user.firstName', 'Jane')\n\n\n\n\nResult:\n\n\np\nPublic, Jane\n/p\n\n\n\n\n\nPriority\n\n\nRactive runs updates based on priority. For instance, when a subtree of the DOM needs to be removed while at the same time updates are pending for that subtree. What Ractive does is prioritize the removal of the subtree over the updates. This causes the dependents on the subtree to unregister themselves, eliminating the need to update, resulting with only the removal operation being done.\n\n\nIndirect dependencies\n\n\nIf you have a mustache which depends on \nfoo.bar\n, and \nfoo\n changes, it's quite possible that the mustache needs to re-render. We say that the mustache has an \nindirect dependency\n on \nfoo\n, or that it has a \ndirect dependency on a downstream keypath\n of \nfoo\n.\n\n\nThis relationship is expressed through the \n_depsMap\n property of a Ractive instance - whenever \nfoo\n changes, as well as dealing with direct \nfoo\n dependants we check the map for those indirect dependants.\n\n\nIn the case of expressions and observers, we also need to consider dependants of \nupstream keypaths\n. For example, suppose we have a section based on a sorted array - if we modify one of the members of the array, we need to see if the sort order has changed or not as a result:\n\n\n{{#( sort( list, 'name' ) )}}\n  \np\n{{name}}\n/p\n\n{{/()}}\n\n\n\n\nractive = Ractive({\n  el: myContainer,\n  template: myTemplate,\n  data: {\n    list: [{ name: 'Bob' }, { name: 'Charles' }, { name: 'Alice' }],\n    sort ( list, property ) {\n      return list.slice().sort( function ( a, b ) {\n        return a[ property ] \n b[ property ] ? -1 : 1\n      })\n    }\n  }\n})\n\n// renders Alice, Bob, Charles\n\nractive.set( 'list[0].name', 'Zebediah' )\n\n// updates to Alice, Charles, Zebediah\n\n\n\n\nIn the example, setting \nlist[0].name\n causes dependants of \nlist\n to be updated.\n\n\nAs well as expressions, Observers respond to both upstream and downstream changes.\n\n\nExpressions with multiple dependencies\n\n\nThe expression \n{{ a + b }}\n has two dependencies - \na\n and \nb\n (or more accurately, whatever those references resolve to). The \n_deps\n graph actually includes objects representing those individual references, rather than the expression itself - the reference objects then notify the expression (if their value has changed) that it will need to re-evaluate itself.\n\n\nBecause the expression has multiple dependencies, it won't trigger an update straight away - it will wait until all the new data has come in first. So doing \nractive.set({ a: 1, b: 2 })\n will only trigger one update, not two.\n\n\nTwo-way binding\n\n\nTwo-way binding allows data to update bi-directionally, from data to the UI and vice versa.\n\n\n\n\n\nRactive({\n  data: {\n    msg: 'Hello, World!'\n  },\n  template: `\n    \ninput type=\ntext\n value=\n{{ msg }}\n {{ msg }}\n\n    \nbutton on-click=\n@this.set('msg', 'Lorem Ipsum')\nTo lipsum\n/button\n\n  `\n})\n\n\n\n\nTwo-way binding can be disabled via the \ntwoway\n initialization option or the \ntwoway\n input directive.\n\n\nAmbiguous references\n\n\nAn ambiguous reference refers to a reference whose data does not exist at the time of construction. Ractive must make an assumption, following a resolution algorithm, on what ambiguous references resolve to. Until a suitable keypath pops into existence, ambiguous references resolve to \nundefined\n.\n\n\n\n\n\nRactive({\n  data: {},\n  template: `\n    \ninput value=\n{{ msg }}\n {{ msg }}\n  `,\n})\n\n\n\n\nAmbiguous references can be locked to a specific keypath, skipping the whole resolution process, using keypath prefixes.\n\n\nLazy updates\n\n\nBy default, Ractive uses various events (i.e. \nchange\n, \nclick\n, \ninput\n, \nkeypress\n) to listen for changes on interactive elements and immediately update bound data. In cases where data updates should only take place after the element loses focus, Ractive also supports lazy updating.\n\n\n\n\n\nRactive({\n  lazy: true,\n  data: {\n    msg: ''\n  },\n  template: `\n    \ndiv\nType and click outside the input\n/div\n\n    \ninput type=\ntext\n value=\n{{ msg }}\n {{ msg }}\n  `\n})\n\n\n\n\nLazy updates can be enabled via the \nlazy\n initialization option or the \nlazy\n directive.\n\n\nComputed Properties\n\n\nComputed properties are top-level pseudo-data references whose value is defined by a computation and which automatically update when its dependencies update.\n\n\nFunction syntax\n\n\nThe function syntax defines a computed property as a function that returns the computed value. The context of the function is the current instance.\n\n\n\n\n\nRactive({\n  data: {\n    width: 200,\n    length: 300\n  },\n  computed: {\n    area () {\n      return this.get('width') * this.get('length')\n    }\n  },\n  template: `\n    Width: \ninput type=\ntext\n value=\n{{ width }}\n\n    Length: \ninput type=\ntext\n value=\n{{ length }}\n\n    Area: {{ area }}\n  `\n})\n\n\n\n\nExpression syntax\n\n\nThe expression syntax defines a computed property as a string containing a JavaScript expression. \n${}\n is replaced internally with a \nractive.get()\n, using its contents as a keypath.\n\n\n\n\n\nRactive({\n  data: {\n    width: 200,\n    length: 300\n  },\n  computed: {\n    area: '${width} * ${length}'\n  },\n  template: `\n    Width: \ninput type=\ntext\n value=\n{{ width }}\n\n    Length: \ninput type=\ntext\n value=\n{{ length }}\n\n    Area: {{ area }}\n  `\n})\n\n\n\n\nAccessor syntax\n\n\nBoth function and expression syntaxes only describe retrieval of the computed property's value, and therefore makes the computed property read-only. The accessor syntax defines a computed property by providing \nget\n and \nset\n methods. \nget\n is called to retrieve its value and \nset\n is called when something updates its value.\n\n\n\n\n\nRactive({\n  data: {\n    side: 200\n  },\n  computed: {\n    area: {\n      get () {\n        return Math.pow(this.get('side'), 2)\n      },\n      set(v) {\n        this.set('side', Math.sqrt(v))\n      }\n    }\n  },\n  template: `\n    Side: \ninput type=\ntext\n value=\n{{ side }}\n\n    Area: \ninput type=\ntext\n value=\n{{ area }}\n\n  `\n})\n\n\n\n\nBoth function and expression syntaxes are supported for the \nget\n method.\n\n\nObservers\n\n\nNested properties\n\n\nObservers observe \nupstream\n and \ndownstream\n keypaths. This allows observers to execute when data is updated indirectly, whether if it's the enclosing structure or a descendant structure.\n\n\n\n\n\nconst instance = Ractive({\n  data: {\n    foo: {\n      bar: 1\n    }\n  },\n  observe: {\n    'foo' (newValue) {\n      console.log('foo changed to', newValue)\n    },\n    'foo.bar' (newValue) {\n      console.log('foo.bar changed to', newValue)\n    }\n  }\n})\n\ninstance.set('foo.bar', 2)\ninstance.set('foo', { bar: 3 })\n\n\n\n\nObservers can be set to only execute on the specified keypath via the \nstrict\n option for both \nobserve\n initialization option and \nractive.observe()\n.\n\n\nWildcards\n\n\nWildcards allow observers to observe keypaths whose segments cannot be determined in advance. This is useful when observing an array, observing items within an array, or observing changes on object properties.\n\n\n\n\n\nconst instance = Ractive({\n  data: {\n    people: [\n      {name: 'Rich Harris'},\n      {name: 'Marty Nelson'}\n    ],\n    config: {\n      allowComments: true,\n      allowEdit: false\n    }\n  },\n  observe: {\n    // Observe changes on the array\n    'people.*' () {\n      console.log('array observer', arguments)\n    },\n    // Observe changes on the name property of any item in the array\n    'people.*.name' () {\n      console.log('array item observer', arguments)\n    },\n    // Observe changes on any property of an object\n    'config.*' () {\n      console.log('object property observer', arguments)\n    }\n  }\n})\n\ninstance.push('people', {name: 'Jason Brown'})\ninstance.set('people.3', {name: 'Jack Black'})\ninstance.set('config.allowEdit', true)\n\n\n\n\nMultiple sources\n\n\nMultiple keypaths can be observed by adding them one after the other, separating them with a space.\n\n\n\n\n\nconst instance = Ractive({\n  data: {\n    user: {username: 'browniefed'},\n    config: {isAdmin: false},\n    commentCount: 0\n  },\n  observe: {\n    'user.username config.isAdmin commentCount' () {\n      console.log('data changed', arguments)\n    }\n  }\n})\n\ninstance.set('user.username', 'chris')\ninstance.set('config.isAdmin', true)\ninstance.set('commentCount', 42)\n\n\n\n\nCaveats\n\n\nObservers do not defensively clone the old and new values as identity of these values may be essential. Thus, observers on non-primitive values may result in having identically equal old and new values.\n\n\n\n\n\nconst instance = Ractive({\n  data: {\n    config: {\n      allowComments: true,\n      allowEdit: false\n    }\n  },\n  observe: {\n    'config' (newValue, oldValue) {\n      console.log(newValue === oldValue)\n    }\n  }\n})\n\ninstance.set('config.allowEdit', true)\n\n\n\n\nBoth \nobserve\n initialization option and \nractive.observe()\n accept an \nold\n option which allows you to define the old value passed to the observer prior to modifications.\n\n\nComponents\n\n\nMappings\n\n\nMappings connect pieces of data on the enclosing instance to data on enclosed instances. Changes on one side will reflect on the other.\n\n\nRactive.components.MyComponent = Ractive.extend({\n  data: {\n    message: ''\n  },\n  template: `\n    \ninput type=\ntext\n value=\n{{ message }}\n\n  `\n})\n\nconst instance = Ractive({\n  el: 'body',\n  data: {\n    text: ''\n  },\n  template: `\n    \nMyComponent message=\n{{ text }} /\n\n  `\n})\n\nractive.set('text', 'Hello World!')\n\n\n\n\nIn the example above, \ntext\n on the instance is mapped to \nMyComponent\n's \nmessage\n. Updates on \ntext\n will update \nmessage\n and any UI elements bound to it. Updates on \nmessage\n, like editing the \ninput\n bound with it, will update \ntext\n.\n\n\nData context\n\n\nEach component instance comes with its own data context so that its data does not pollute the primary data. Any mapping between the component and the enclosing instance will still update across both contexts.\n\n\nRactive.components.MyComponent = Ractive.extend({\n  data: {\n    shades: '',\n    option: ''\n  }\n})\n\nconst instance = Ractive({\n  template: `\n    \nMyComponent shades='{{colors}}' option='A' /\n\n  `,\n  data: {\n    name: 'Colors',\n    colors: ['red', 'blue', 'yellow']\n  }\n})\n\nconst widget = ractive.findComponent('MyComponent')\n\nractive.get() // {\ncolors\n:[\nred\n,\nblue\n,\nyellow\n], \nname\n:\nColors\n}\nwidget.get()  // {\nshades\n:[\nred\n,\nblue\n,\nyellow\n], \noption\n:\nA\n}\n\nractive.set('colors.1', 'green')\n\nractive.get() // {\ncolors\n:[\nred\n,\ngreen\n,\nyellow\n], \nname\n:\nColors\n}\nwidget.get()  // {\nshades\n:[\nred\n,\ngreen\n,\nyellow\n], \noption\n:\nA\n}\n\n\n\n\nIn the example above, the enclosing instance data holds \nname\n and \ncolors\n. \ncolors\n is mapped to \nshades\n and \noption\n is set on an instance of \nMyComponent\n. Upon inspection, \nname\n from the enclosing instance does not cross over to \nMyComponent\n nor does \noption\n cross over to the enclosing instance. However, since \ncolors\n on the instance is mapped to \nshades\n on the component, any modifications on either side will reflect on the other.\n\n\nIsolation\n\n\nBy default, components are \"isolated\". Descendant components can update ancestor data only when there is an explicit mapping between them. This avoids unintended mutation of ancestor data and ensures portability of components.\n\n\nRactive.components.ChildComponent = Ractive.extend({\n  template: 'Message missing {{ message }}'\n})\n\nconst instance = Ractive({\n  el: 'body',\n  template: '\nChildComponent /\n',\n  data: {\n    message: 'The ChildComponent will not know anything about this message'\n  }\n})\n\n\n\n\nIn the example above, \nChildComponent\n will not print anything since \nmessage\n is not defined in the component and due to isolation, the component cannot see the instance's \nmessage\n.\n\n\nIsolation can be disabled via the \nisolated\n initialization option.\n\n\nEvent Management\n\n\nLike many other libraries, Ractive implements its own \npublish/subscribe\n mechanism for triggering and responding to particular events. One of the advantages of using Ractive-managed events is that events are automatically unsubscribed and unreferenced once the instance is torn down, avoiding the need to do manual housekeeping.\n\n\nSources\n\n\nEvent API\n\n\nEvents that are published as a result of using the event APIs directly (i.e. \nractive.fire\n). Most of the other event sources use the event APIs to publish events at some point in their operation.\n\n\ninstance.fire('someevent', 'Hello, World!')\n\n\n\n\nLifecycle events\n\n\nLifecycle events are events that are published by an instance during the different phases of its existence. Ractive instances publish the following lifecycle events:\n\n\n\n\nconstruct\n\n\nconfig\n\n\ninit\n\n\nrender\n\n\ncomplete\n\n\nupdate\n\n\ninsert\n\n\ndetach\n\n\nunrender\n\n\nteardown\n\n\ndestruct\n\n\n\n\nLifecycle event names are reserved. They should not be used as names of other events.\n\n\nDOM events\n\n\nDOM events are events that are published by the DOM.\n\n\nbutton on-click=\n...\n\n\n\n\n\nCustom events\n\n\nCustom events are events that are published by event plugins.\n\n\nimg on-tap=\n...\n\n\n\n\n\nComponent events\n\n\nComponent events are events that are published by \ncomponents\n.\n\n\nMyModal on-close=\n...\n /\n\n\n\n\n\nHandling\n\n\nEvent API\n\n\nEvents published from the direct use of the event APIs are also handled by directly using the event APIs (i.e. \nractive.on\n, \nractive.once\n). Most of the other handling methods use the event APIs to handle events at some point in their operation.\n\n\ninstance.on('someevent', (context, message) =\n {\n  console.log(message)\n})\n\n\n\n\nLifecycle events\n\n\nLifecycle events are handled by assigning a function to the appropriate lifecycle event initialization option.\n\n\nRactive({\n  onrender () {\n    console.log('instance has been rendered')\n  }\n})\n\n\n\n\nThe event APIs can also subscribe to lifecycle events. However, the handler must subscribe prior to the event publishing. Using the lifecycle event initialization options is the safer option to ensure the correct timing of subscriptions.\n\n\nProxy syntax\n\n\nRactive instances do not immediately subscribe to template-based events (DOM events, component events, custom events). The proxy syntax \"proxies\" template-based events into events that the current instance can subscribe to. From there, the events are handled by event APIs. Arguments are not supported in this syntax.\n\n\nRactive({\n  template: `\n    \nbutton on-click=\nbuttonclicked\nClick Me!\n/button\n\n  `,\n  on: {\n    buttonclicked (context) {\n      console.log('button clicked')\n    }\n  }\n})\n\n\n\n\nExpression syntax\n\n\nA more powerful form of template-based event handling is the expression syntax, which allows the use of expressions as their values. This form acts very similar to inline scripts plus some useful additions. The expression syntax also has full, unmustached access to data and special references.\n\n\nThe first form is a special form of the proxy syntax. It accepts an array whose first item is the event name, and the rest are its arguments.\n\n\nRactive({\n  template: `\n    \nbutton on-click=\n['buttonclicked', 'foo', 'bar']\nClick Me!\n/button\n\n  `,\n  on: {\n    buttonclicked (context, foo, bar) {\n      console.log('button clicked passing', foo, bar)\n    }\n  }\n})\n\n\n\n\nThe second form uses expressions directly. This allows unrestricted access to almost anything, from calling instance methods, custom methods, or even firing a proxy event manually.\n\n\nRactive({\n  data: { msg: '' },\n  template: `\n    \nbutton on-click=\n@this.set('msg', 'Hello, World!')\nSet message\n/button\n\n    \nbutton on-click=\n@this.greetz(msg)\nPrint message\n/button\n\n    \nbutton on-click=\n@this.fire('manualproxy', msg)\nPrint message via proxy\n/button\n\n    \nbutton on-click=\n@this.set('foo', 1), @this.set('bar', 2)\nCccombo!!!\n/button\n\n  `,\n  greetz(message) {\n    console.log(`${message}`)\n  },\n  on: {\n    manualproxy (context, message) {\n      console.log(`${message}`)\n    }\n  }\n})\n\n\n\n\nEvent context\n\n\nEvent handlers, regardless of event source, receive an \ncontext\n object as first argument. The \ncontext\n object is a special instance of a context object augmented with additional event-related properties where applicable.\n\n\n\n\nname\n - The name of the published event.\n\n\nnode\n - A reference to the DOM node publishing the event. Only available on DOM events.\n\n\nevent\n - A reference to the DOM event. Only available on DOM\n\n\noriginal\n - A reference to the DOM event. Only available on DOM\n\n\ncomponent\n - A reference to the component that published the event. Only available on propagated events.\n\n\n\n\nRactive({\n  template: `\n    \nbutton on-click=\nbuttonclicked\nClick Me!\n/button\n\n  `,\n  on: {\n    buttonclicked (context) {\n      console.log(event.node.type) // submit\n    }\n  }\n})\n\n\n\n\nNamespacing\n\n\nPattern-matching is supported on any type of event, allowing a form of event namespacing. This is done by using a keypath-like event name and using wildcards (\n*\n) on segments during subscription.\n\n\nRactive({\n  el: 'body',\n  append: true,\n  template: `\n    \nbutton on-click=\nfoo.bar\nClick Me!\n/button\n\n    \nbutton on-click=\nfoo.baz\nClick Me!\n/button\n\n    \nbutton on-click=\nfoo.bam\nClick Me!\n/button\n\n    \nbutton on-click=\nqux.bar\nClick Me!\n/button\n\n    \nbutton on-click=\nqux.baz\nClick Me!\n/button\n\n    \nbutton on-click=\nqux.bam\nClick Me!\n/button\n\n  `,\n  on: {\n    '*.bar' (context) {\n      console.log('A bar event was published')\n    },\n    'qux.*' (context) {\n      console.log('A qux event was published')\n    }\n  }\n})\n\n\n\n\nBe aware that handlers subscribing to just \n*\n will fire for \nall\n events.\n\n\nPropagation\n\n\nDOM event propagation\n\n\nNative DOM event propagation is preserved, allowing things such as delegation.\n\n\nRactive({\n  template: `\n    \ndiv on-click=\nbuttonclicked\n\n      \nbutton type=\nbutton\nClick Me!\n/button\n\n    \n/div\n\n  `,\n  on: {\n    buttonclicked (context) {\n      console.log('button clicked')\n    }\n  }\n})\n\n\n\n\nComponent propagation\n\n\nPropagation across component boundaries is also supported. Propagating events are namespaced using the publishing component's name as prefix. This applies to component, proxy, and even lifecycle events.\n\n\nconst ChildComponent = Ractive.extend({\n  template: '\ndiv\n/div\n',\n  oncomplete () {\n    this.fire('childevent')\n  }\n})\n\nconst ParentComponent = Ractive.extend({\n  components: { ChildComponent },\n  template: '\nChildComponent /\n'\n})\n\nconst instance = Ractive({\n  components: { ParentComponent },\n  template: '\nParentComponent /\n'\n})\n\ninstance.on('ChildComponent.childevent', function () {\n  console.log('Hello World!')\n})\n\n\n\n\nStopping propagation\n\n\nPropagation can be stopped by simply returning \nfalse\n from an event handler. If the event is a DOM event, \nevent.stopPropagation()\n and \nevent.preventDefault()\n are automatically called.\n\n\nRactive({\n  template: `\n    \ndiv on-click=\nancestorbuttonclick\n\n      \nbutton on-click=\ndescendantbuttonclick\nClick Me!\n/button\n\n    \n/div\n\n  `,\n  on: {\n    ancestorbuttonclick (context) {\n      console.log('This will not run')\n    },\n    descendantbuttonclick (context) {\n      console.log('This will run')\n      return false\n    }\n  }\n})\n\n\n\n\nReturning \nfalse\n also stops propagation across components.\n\n\nconst ChildComponent = Ractive.extend({\n  template: '\ndiv\n/div\n',\n  oncomplete () {\n    this.fire('childevent')\n  }\n})\n\nconst ParentComponent = Ractive.extend({\n  components: { ChildComponent },\n  template: '\nChildComponent /\n',\n  on: {\n    'ChildComponent.childevent' () {\n      return false\n    }\n  }\n})\n\nconst instance = Ractive({\n  components: { ParentComponent },\n  template: '\nParentComponent /\n'\n})\n\ninstance.on('ChildComponent.childevent', function () {\n  console.log('This will not run')\n})\n\n\n\n\nAssigning a handler using \non-*\n will also stop propagation. However, if \non-*\n is assigned a proxy event and not stopped, that proxy event will propagate in place of the stopped event.\n\n\nconst ChildComponent = Ractive.extend({\n  template: '\ndiv\n/div\n',\n  oncomplete () {\n    this.fire('childevent1')\n    this.fire('childevent2')\n    this.fire('childevent3')\n    this.fire('childevent4')\n  }\n})\n\nconst ParentComponent = Ractive.extend({\n  components: { ChildComponent },\n  template: `\n    \nChildComponent\n      on-childevent1=\n\n      on-childevent2=\nchildevent2proxy\n\n      on-childevent3=\nchildevent3proxy\n\n      on-childevent4=\n@this.parentMethod()\n\n    /\n\n  `,\n  on: {\n    childevent2proxy () {\n      // childevent2proxy replaces childevent2\n    },\n    childevent3proxy () {\n      // childevent3proxy replaces childevent3 but stopped\n      return false\n    }\n  },\n  parentMethod () {\n    // childevent4 handled by a method\n  }\n})\n\nconst instance = Ractive({\n  components: { ParentComponent },\n  template: '\nParentComponent /\n'\n})\n\ninstance.on('ChildComponent.childevent1', function () {\n  console.log('childevent1 stopped by a blank handler')\n})\n\ninstance.on('ChildComponent.childevent2', function () {\n  console.log('childevent2 stopped by a proxy event')\n})\n\ninstance.on('ChildComponent.childevent3', function () {\n  console.log('childevent3 stopped by a proxy event')\n})\n\ninstance.on('ChildComponent.childevent4', function () {\n  console.log('childevent4 stopped by a method call')\n})\n\ninstance.on('ParentComponent.childevent3proxy', function () {\n  console.log('childevent3proxy stopped by returning false')\n})\n\n// This one gets through since its proxy event was left to propagate\ninstance.on('ParentComponent.childevent2proxy', function () {\n  console.log('childevent2proxy fired')\n})\n\n\n\n\nRendering\n\n\nSynchronous rendering\n\n\nRactive does not batch renders, asynchronously render, nor render at next tick. The instance's DOM is updated immediately after its dependencies update. This is a trade-off between optimization and predictability. Ractive chose the latter route to make it easier to anticipate the state of the DOM at any given moment.\n\n\n\n\n\nconst instance = Ractive({\n  target: 'body',\n  data: {\n    count: 0,\n  },\n  template: `\n    \ndiv\n{{ count }}\n/div\n\n  `,\n})\n\nconst div = instance.find('div')\n\nconsole.log('Before:', div.innerHTML)\ninstance.set('count', 100)\nconsole.log('After:', div.innerHTML)\n\n// Before: 0\n// After: 100\n\n\n\n\nThe only time rendering happens asynchronously is during animations and transitions. All mutator methods return a promise which resolves when the animations and/or transitions resulting from these operations complete.\n\n\n\n\n\nconst instance = Ractive({\n  target: 'body',\n  data: {\n    count: 0,\n  },\n  template: `\n    \ndiv\n{{ count }}\n/div\n\n  `,\n})\n\nconst div = instance.find('div')\n\nconsole.log('Before:', div.innerHTML)\ninstance.animate('count', 100).then(() =\n {\n  console.log('Resolved:', div.innerHTML)\n})\nconsole.log('After:', div.innerHTML)\n\n// Before: 0\n// After: 0\n//\n// Resolved: 100\n\n\n\n\nScoped CSS\n\n\nCSS provided via the \ncss\n initialization option is scoped to the component.\n\n\nconst Component = Ractive.extend({\n  template: `\n    \nspan\nI'm red\n/span\n\n    \ndiv\n\n      \nspan\nI'm also red\n/span\n\n    \n/div\n\n  `,\n  css: `\n    span { color: red }\n  `\n})\n\nRactive({\n  components: { Component },\n  el: 'body',\n  template: `\n    \nComponent /\n\n    \nspan\nI'm not red\n/span\n\n  `\n})\n\n\n\n\nThis is done by generating a unique id for each component definition. That ID is then added to each selector defined in \ncss\n and to each top-level element in the component's DOM.\n\n\nspan[data-ractive-css~=\n{6f9bd745-a6b9-9346-0c8c-e3cc94b3d2a5}\n],\n[data-ractive-css~=\n{6f9bd745-a6b9-9346-0c8c-e3cc94b3d2a5}\n] span {\n  color: red\n}\n\n\n\n\nspan data-ractive-css=\n{6f9bd745-a6b9-9346-0c8c-e3cc94b3d2a5}\nI'm red\n/span\n\n\ndiv data-ractive-css=\n{6f9bd745-a6b9-9346-0c8c-e3cc94b3d2a5}\n\n  \nspan\nI'm also red\n/span\n\n\n/div\n\n\nspan\nI'm not red\n/span\n\n\n\n\n\nCurrently, there are a few limitations to this feature:\n\n\n\n\nID-based scoping is not true component scoping and will affect elements of descendant components.\n\n\ncss\n can only be used with components and not on direct Ractive instances. This may change in the future.\n\n\n\n\nProgressive Enhancement\n\n\nTODO\n\n\nServer-side\n\n\nServer-side rendering can be achieved using \nractive.toHTML()\n and \nractive.toCSS()\n. Both methods render the instance and its descendants at their current state to HTML and CSS, respectively.\n\n\nconst Component1 = Ractive.extend({\n  data: {\n    message: ''\n  },\n  template: `\n    \ndiv class=\ncomponent1\n{{message}}\n/div\n\n  `,\n  css: `\n    .component1 { color: red }\n  `\n})\n\nconst Component2 = Ractive.extend({\n  data: {\n    greeting: ''\n  },\n  template: `\n    \ndiv class=\ncomponent2\n{{greeting}}\n/div\n\n  `,\n  css: `\n    .component2 { color: green }\n  `\n})\n\nconst App = Ractive.extend({\n  components: {\n    Component1,\n    Component2\n  },\n  data: {\n    greet: '',\n    msg: ''\n  },\n  template: `\n    \nComponent1 message=\n{{ msg }}\n /\n\n    \nComponent2 greeting=\n{{ greet }}\n /\n\n  `\n})\n\nconst state = { greet: 'Good Morning!', msg: 'Hello, World!' }\nconst app = App({ data: state })\nconst html = app.toHTML()\nconst css = app.toCSS()\n\n\n\n\nCurrently, there are a few limitations to this feature:\n\n\n\n\nractive.toHTML()\n prints HTML without component IDs while \nractive.toCSS()\n prints out selectors with component IDs, which causes the HTML and CSS to not match up.\n\n\nA workaround is to render the CSS as is by setting \nnoCssTransform\n to \ntrue\n and to use a CSS naming convention (i.e BEM, OOCSS, SMACSS) to match up selectors with their elements.\n\n\n\n\n\n\nractive.toHTML()\n does not automatically insert the document CSS when rendering a component that represents a full document. This must be done manually.\n\n\n\n\nSecurity\n\n\nUse of the Function constructor\n\n\nRactive uses the \nFunction\n constructor only to convert expressions (i.e. mustache expressions, expression-style computed properties) into value-generating functions. As of 0.9, \nallowExpressions\n initialization option is available to toggle the expression-to-function feature. Setting it to \nfalse\n will tell Ractive neither to parse nor process expressions.\n\n\nContent Security Policy\n\n\nOut of the box, Ractive will violate certain CSP directives due to the use of the \nFunction\n constructor for evaluating expressions, and dynamically generated \nstyle\n elements for Ractive-managed CSS.\n\n\nIn order to avoid violating \nscript-src\n, either:\n\n\n\n\nPre-parse templates. As of 0.8, the parser will store expressions as functions on the AST. To preserve the functions when serializing the AST, use libraries like \nnode-tosource\n or \nserialize-javascript\n instead of \nJSON.stringify()\n.\n\n\nSet \nallowExpressions\n initialization option to \nfalse\n. This will tell Ractive to avoid evaluating expressions.\n\n\nAdd the \nscript-src 'unsafe-eval'\n CSP directive. This will allow the use of the \nFunction\n constructor.\n\n\n\n\nIn order to avoid violating \nstyle-src\n, either:\n\n\n\n\nAdd \nstyle-src 'unsafe-inline'\n to your CSP directives. This will allow the use of dynamically generated \nstyle\n elements.\n\n\n\n\nTemplates\n\n\nStrictly speaking, Ractive templates are not HTML. They are markup representations of objects that are used to construct HTML. Simply put, templates are \nHTML-like\n. Ractive parses templates into \nAST\ns which contain everything Ractive needs to know to construct an instance's DOM, data bindings, events and transitions etc.\n\n\nRactive.parse('\ndiv class=\nmessage\nHello World!\n/div\n')\n\n// {\nv\n:4,\nt\n:[{\nt\n:7,\ne\n:\ndiv\n,\nm\n:[{\nn\n:\nclass\n,\nf\n:\nmessage\n,\nt\n:13}],\nf\n:[\nHello World!\n]}]}\n\n\n\n\nKeypaths\n\n\nA keypath is a kind of reference that represents the location of a piece of data.\n\n\nRactive({\n  data: {\n    foo: {\n      bar: {\n        baz: {\n          qux: 'Hello, World!'\n        }\n      }\n    }\n  },\n  template: `\n    {{ foo.bar.baz.qux }}\n  `\n})\n\n\n\n\nDot and bracket notations\n\n\nDot and bracket notation rules for keypaths are similar to vanilla JS. The only addition to this is that the dot notation can also be used to access arrays, by using the index directly on the segment.\n\n\nconst instance = Ractive({\n  data: {\n    items: [1, 2, 3],\n    foo: {\n      bar: {\n        baz: {\n          qux: 'Hello, World!',\n          'dotted.key': 'Me, Hungry!'\n        }\n      }\n    },\n    dynamicKey: 'bar'\n  },\n  template: `\n    {{ foo['bar']['baz']['qux'] }} \n!-- bracket notation object access --\n\n    {{ foo.bar.baz.qux }}          \n!-- dot notation object access --\n\n\n    {{ items[0] }} \n!-- bracket notation array access --\n\n    {{ items.0 }}  \n!-- dot notation array access --\n\n\n    {{ foo.bar.baz['dotted.key'] }} \n!-- dotted key access --\n\n\n    {{ foo[dynamicKey].baz.qux }} \n!-- dynamic key access --\n\n  `\n})\n\n\n\n\nMissing properties\n\n\nIn JavaScript, trying to access a child property of an object that does not exist would throw an error. In Ractive, it would simply return \nundefined\n or render nothing.\n\n\nconst instance = Ractive({\n  data: {\n    numbers: [ 1, 2, 3 ]\n  },\n  template: `\n    {{ letters[0] }}\n  `\n})\n\nractive.get( 'letters[0]' ) // undefined\n\n\n\n\nUpstream and downstream keypaths\n\n\nRactive has this concept of \"upstream\" and \"downstream\" keypaths. Upstream keypaths are ancestor keypaths. For the keypath \nfoo.bar.baz.qux\n, it's upstream keypaths are \nfoo\n, \nfoo.bar\n and \nfoo.bar.baz\n. Downstream keypaths are descendant keypaths. For the \nfoo\n keypath, it's downstream keypaths would be \nfoo.bar\n, \nfoo.bar.baz\n and \nfoo.bar.baz.qux\n.\n\n\nReferences\n\n\nA reference is a string that refers to a piece of data. A keypath is an example of a reference, one that points to a specific location in the data. Special references are also a form of reference, one that provides to a certain value.\n\n\nReference resolution\n\n\nRactive follows the following resolution algorithm to find the value of a reference:\n\n\n\n\nIf the reference a special reference, resolve with that keypath.\n\n\nIf the reference is explicit or matches a path in the current context exactly, resolve with that keypath.\n\n\nGrab the current virtual node from the template hierarchy.\n\n\nIf the reference matches an alias, section indexes, or keys, resolve with that keypath.\n\n\nIf the reference matches any mappings, resolve with that keypath.\n\n\nIf the reference matches a path on the context, resolve with that keypath.\n\n\nRemove the innermost context from the stack. Repeat steps 3-7.\n\n\nIf the reference is a valid keypath by itself, resolve with that keypath.\n\n\nIf the reference is still unresolved, add it to the 'pending resolution' pile. Each time potentially matching keypaths are updated, resolution will be attempted for the unresolved reference.\n\n\n\n\nContext stack\n\n\nWhenever Ractive encounters section mustaches or similar constructs, it stores the context in a \ncontext stack\n. Ractive then resolves references relative to the top of the stack, and popping off contexts until the reference resolves to a keypath.\n\n\nRactive({\n  data: {\n    qux: 'Me, Hungry!',\n    foo: {\n      bar: {\n        baz: 'Hello, World!'\n      }\n    }\n  },\n  template: `\n                \n!-- context is the root of the data --\n\n    {{#foo}}    \n!-- context is now foo --\n\n      {{#bar}}  \n!-- context is now foo.bar --\n\n        {{baz}} \n!-- Resolution order: foo.bar.baz, foo.baz, baz. Resolved at foo.bar.baz. --\n\n        {{qux}} \n!-- Resolution order: foo.bar.quz, foo.qux, qux. Resolved at qux. --\n\n      {{/}}\n    {{/}}\n  `,\n})\n\n\n\n\nConditional attributes\n\n\nSections can toggle attributes, whether it's one attribute, multiple attributes or specific values of the attribute.\n\n\n!-- one attribute --\n\n\na href=\n/\n {{#if currentPage}}class=\nactive\n{{/if}}\nHome\n/a\n\n\n\n!-- multiple attributes --\n\n\na href=\n/\n {{#if currentPage}}class=\nactive\n title=\nCurrent page\n{{/if}}\nHome\n/a\n\n\n\n!-- specific attribute value --\n\n\na href=\n/\n class=\nnav-link {{#if currentPage}}nav-link--active{{/if}}\nHome\n/a\n\n\n\n\n\nOptimization\n\n\nPre-parsing\n\n\nParsing templates can be a very slow operation. As an optimization option, templates can be pre-parsed outside of runtime, speeding up app initialization. Most loaders do pre-parsing of templates as part of their build process. A parsed template is approximately 30-40% larger than the markup version, making it a trade-off between space and processing.\n\n\nLimiting template expressions\n\n\nWhile expressions provide power and convenience when building templates, it incurs a performance penalty as Ractive sets up each one on a per-instance level. To avoid this overhead, there are several places where logic can move to, trimming down expressions into mere function calls.\n\n\nFunctions can be set on the data globally via \nRactive.defaults.data\n.\n\n\nRactive.defaults.data.customLogic = function () { ... }\n\nRactive({\n  template: `\n    {{ customLogic() }}\n  `\n})\n\n\n\n\nFunctions can also be defined on a component level using methods.\n\n\nconst Component = Ractive.extend({\n  template: `\n    {{ @this.customLogic() }}\n  `,\n  customLogic () {\n    ...\n  }\n})\n\n\n\n\nExpression processing\n\n\nWhen Ractive parses a template, it creates a string representation of the expression structure and keeps track of its dependencies. Then Ractive converts these expression strings into a function which can be called to generate the expression's value.\n\n\nRactive optimizes this routine starting by generating the same expression string for structurally-identical expressions. Then a value-generating function is created for each \ndistinct\n expression string, cached globally and shared to all instances. Furthermore, Ractive caches the generated values and only updates them when the expression's dependencies update.\n\n\n// Expression parsing\nRactive.parse('{{ a + b }}{{ c + d }}')\n\n// {\n//   \nv\n: 4,\n//   \nt\n: [\n//     {\n//       \nt\n: 2,\n//       \nx\n: {\n//         \nr\n: [\na\n,\nb\n], \n-- dependencies here\n//         \ns\n: \n_0+_1\n    \n-- expression string here\n//       }\n//     },\n//     {\n//       \nt\n: 2,\n//       \nx\n: {\n//         \nr\n: [\nc\n,\nd\n], \n-- dependencies here\n//         \ns\n: \n_0+_1\n    \n-- expression string here\n//       }\n//     }\n//   ],\n//   \ne\n: {}\n// }\n\n// Building and caching of the expression resolver of `_0+_1`\nconst expressionFunctionsCache = {}\nexpressionFunctionsCache['_0+_1'] = new Function('_0', '_1', 'return _0+_1')\n\n// Evaluate {{ a + b }}\nconst dep = ['a', 'b']\nconst exp = '_0+_1'\nconst arg = dep.map(instance.get)\nconst val = expressionFunctionsCache[exp].apply(instance, arg)\n\n// Evaluate {{ c + d }}\nconst dep = ['c', 'd']\nconst exp = '_0+_1'\nconst arg = dep.map(instance.get)\nconst val = expressionFunctionsCache[exp].apply(instance, arg)\n\n\n\n\nThe \nFunction\n constructor was chosen over \neval\n because it allows Ractive to compile the expression string \nonce\n as well as \ncache\n the resulting function, instead of evaluating the string every time the value is needed.", 
            "title": "Concepts"
        }, 
        {
            "location": "/legacy/0.9/concepts/#architecture", 
            "text": "There are three major sections in the Ractive source code: The parser which handles template parsing, the models which handle data management and the views which handle the virtual DOM. This document aims to give a breakdown of just what exactly each of these sections do.", 
            "title": "Architecture"
        }, 
        {
            "location": "/legacy/0.9/concepts/#parser", 
            "text": "Ractive's parser is reponsible for taking in Mustache-like/Handlebar-like templates. Unlike Mustache and Handlebars, however, it turns them into an  AST  for use by the runtime. In addition, it also supports a fair amount of ES syntax for use in expressions.  Each item expressable in Ractive-flavored mustache has its own parsing function that may also be comprised of other parsing functions. Each bit of ES syntax that Ractive understands for expressions also has its own parsing function. The parser starts at the beginning of the template string and starts applying each parsing function in precedence order. Each function will then consume as much of the template as needed to return an item, like an element, a section, a partial, a bit of text, or an interpolator. It may also return nothing. Most items can also contain children, including items of the same type as themselves, and will thus recurse by trying to parse their content.", 
            "title": "Parser"
        }, 
        {
            "location": "/legacy/0.9/concepts/#mustaches", 
            "text": "Each type of mustache has its own reader that calls the appropriate expression or reference readers internally. For instance, the partial reader reads the current open mustache delimiter (defaults to  {{ ) followed by a  . It then expects to find a relaxed reference, meaning it may contain dashes and slashes among other usually-forbidden characters. It may then optionally read a context expression or series of alias definitions", 
            "title": "Mustaches"
        }, 
        {
            "location": "/legacy/0.9/concepts/#expressions", 
            "text": "The expression readers are set arranged such that they can read valid ES expressions with the correct operator precedence by starting with ternary conditionals and trying different expression types from there. Once the expression tree has been parsed, it is flattened into an expression string and a list of references that are used within that string. If the parsing is done with  csp  (Content Security Policy) support enabled, then the expression strings are also turned into functions and attached to the output template structure so that the template can be used as-is from a script tag without  eval ing.", 
            "title": "Expressions"
        }, 
        {
            "location": "/legacy/0.9/concepts/#cleanup", 
            "text": "After all of the nodes have been parsed from the template, the template is cleaned up in a process that, among other things, merges adjacent text nodes and forms individual conditional sections out of  elseif / else  trees.", 
            "title": "Cleanup"
        }, 
        {
            "location": "/legacy/0.9/concepts/#models", 
            "text": "Ractive wraps any data given to it into a tree-like hierarchy of  Model . Any data that is rendered into a template will be bound to a  Model . Access to read and write data in Ractive is handled through the model hierarchy based on keypaths, which are, generally, a list of object properties that one would need to follow to reach a leaf of the data tree starting from the root. Each key along the keypath has its own corresponding model.  Models allow entities that depend upon them to register themeselves to receive change notifications when the model value changes. This is how Ractive keeps track of exactly which parts of the view need to be updated when values change.  All of the data managed by Ractive is represented by its model hierarchy.  Almost every type of Model is a subclass of  Model , so it seems a good place to start. Each model typically has a parent model, a key that is used to access its value from its parent, and a value. Most models also have children of some sort, which are tracked by key such that  { foo: { bar: 'baz' } }  would have a model with a  childByKey['foo'] , which would also have a model at  childByKey['bar'] . The value of each of the models listed there would be the object containing  foo: { bar: baz } , its  foo  child would be the object  bar: 'baz' , and its  bar  child would be the string  'baz' . Where children of a model are other models, dependents ( deps ) of a model may be anything that wants to be notified of changes, and each model will typically have a number of dependents, too.  Each model has a unique keypath that is assembled by taking its key and each of its parents keys up to the root and joining them with a  . .  Models are also inherently lazy, meaning their value is not necessarily available when the are created. A value is retrieved from a model using its  get  method which may have the side effect of computing the value. Once a value has been computed, it is generally cached until a change happens that would cause the cache to be invalidated. In most models, there isn't really an opportunity for that change outside of normal change propagation.", 
            "title": "Models"
        }, 
        {
            "location": "/legacy/0.9/concepts/#rootmodel", 
            "text": "Every tree needs a root, and  RootModel  serves that purpose here. Each Ractive instance gets its own  RootModel  that is stored at its  viewmodel  property. This special model is also the storage point for computations and mappings.", 
            "title": "RootModel"
        }, 
        {
            "location": "/legacy/0.9/concepts/#keymodel", 
            "text": "The last major model remaining is the  KeyModel . Instances of this represent indices of arrays and keys of objects during iteration. The key flavor never is immutable, becuase the keys of  objects never change (they may be removed, but that doesn't change the key itself). The index flavor  does  change, but only when the array represented by its parent model is shuffled.", 
            "title": "KeyModel"
        }, 
        {
            "location": "/legacy/0.9/concepts/#other-models", 
            "text": "There are a few other types of  Model  in the code, such as the  RactiveModel , which represents a Ractive instance, and the  GlobalModel , which represents the global object of the current environment a.k.a.  window  for browsers and  global  for Node.js.", 
            "title": "Other models"
        }, 
        {
            "location": "/legacy/0.9/concepts/#model-operations", 
            "text": "", 
            "title": "Model operations"
        }, 
        {
            "location": "/legacy/0.9/concepts/#change-propagation", 
            "text": "When a change is supplied to a model, its  set  method is called, which usually delegates to  applyValue .  applyValue  checks to see that the value has actually changed in some way (hint: setting to the same object or array is considered a change because something may have changed further in), and if it has, it will start change notification for all of the model's children and dependents. If the model has resolvers registered with it trying to get an unresolved value, then this is where the unresolved value will be resolved and the resolver satisfied and cleared. Next, any children will be notified that their parent has had a value change and that they may need to update accordingly, which may trigger further cascades of resolution and change notification. Next, any dependents of the model will be notified that the model has had a value change as their  handleChange  methods are called. Finally, upstream models (parents) are notified that a change has taken place somewhere among its children.  The child notification of the propagation is handled by the model's  mark  method.  mark  also checks to see that the value has actually changed, and if it has, will notify its children and dependents that it has had a value change. This is also the method called when the user signals that they have changed some data externally by calling  ractive.update() .", 
            "title": "Change propagation"
        }, 
        {
            "location": "/legacy/0.9/concepts/#shuffling", 
            "text": "There is a special form of change wherein an array is modified without being swapped out, which is triggered by array methods like  splice ,  push , and  pop . When an array modification happens, change propagation takes a special path through the model that allows more precise DOM manipulation rather than throwing all of the DOM out and replacing it with a new result. This is achieved by having the special array method handlers compute which indexes are actually changed and having the array model's deps that can actally handle a shuffle ignore any untouched indices.  The instance method  merge  does something similar, but instead of modifying the underlying array, it compares the members of the new supplied array against the model array to compute the index changes. It the swaps in the new array and triggers a shuffle based on the computed index changes.", 
            "title": "Shuffling"
        }, 
        {
            "location": "/legacy/0.9/concepts/#adaptation", 
            "text": "Between the change check and the change propagation during  applyValue , there is a step that handles part of adaptation so that external objects with special behaviors, like backbone models, can be used as data sources. An adaptors takes the special object, wraps it up, and returns the wrapper that also has a value that represents the object for consumption by Ractive. Most adaptors also have methods to update values in their source data as well, and those methods are called when an update is applied to an adapted model.", 
            "title": "Adaptation"
        }, 
        {
            "location": "/legacy/0.9/concepts/#computations", 
            "text": "A computation is exactly what is sounds like: a getter and optional setter function that are used to provide read and optional write access to some non-fixed piece of data. Each computation is stored in the root model  computations  hash by its keypath. Computations can be created in two places:   Explicitly when a  computed  map is passed to a Ractive instantiation or when an entry is later added to a instance's computed map. These may be read/write and have a keypath that mirrors their name.  Implicitly when an expression is used in a template. These are read-only and have a keypath that is an expanded representation of their expression.   A computation is also a form of model, so anything that depends on it will subscribe to it as if it were a regular model. Change propagation happens in the same way as a regular model as well.  Since computations may depend on other bits of data controlled by Ractive, while they are being retrieved, any references to other models will cause the extra references to be  capture d. When the computation is complete, the computation will register with each of its captured dependencies so that it will be notified when it needs to invalidate and notify its dependents of the change.", 
            "title": "Computations"
        }, 
        {
            "location": "/legacy/0.9/concepts/#mappings", 
            "text": "When a Ractive instance has children, typically components, it may supply a handles to its own data to them in the form of mappings. The child instance stores a reference to the parent model at its mapped name and uses it when its dependents request access to keypaths that start with the mapped name. This allows child instances, which may be isolated, to stay in sync with portions of their parents data easily, because the parent still controls the data (single source of truth) and there is no syncing involved. So if a parent has a component  Component foo=\"{{bar.baz.bat.bippy}}\" / , then the component instance will get a mapping  foo  that references the parent model at  bar.baz.bat.bippy .", 
            "title": "Mappings"
        }, 
        {
            "location": "/legacy/0.9/concepts/#virtual-dom", 
            "text": "Every piece of DOM that Ractive can manage has a corresponding class in the virtual DOM to handle the DOM node, which generally end up being either Elements or Text Nodes. View items are grouped together as Fragments of view, which may then be owned by other fragments or items. At the root of every ractive instance is a Fragment instance that contains its entire virtual DOM tree. Each Ractive template construct has at least one analog in the virtual DOM. The bulk of Ractive's view functionality is implemented in the Section, Interpolator, and Element items, with there being a number of specialized element classes to handle special types of HTML element.  All virtual DOM items go through roughly the same lifecycle: creation, binding, rendering, bubbling, updating, unrendering, and unbinding. Creation is basically just the constructor call and almost always is immediately followed by binding. Binding is the point at which the item resolves and registers with its data references. Rendering is the point at which the item inserts an actual DOM node into the DOM. Bubbling and updating are the two halves of the update process, which is discussed in the next section. Unrendering is the point at which the item should no longer be present in the DOM, and it often occurs at the same point as unbinding, which is the point at which the item unregisters with the viewmodel and is effectively destroyed.  There a number of other members, such as events and decorators, and processes, such as change propagation, which are described in detail in the view overview.  Ractive views are structured virtual DOM trees that are assembled from template AST and manage DOM nodes on the page when they are rendered. Virtual DOM items are grouped together in  Fragment s, which contain them, and they may also own  Fragment s that contain other items. Each item may contain a reference to a DOM node when rendered, though every item doesn not have a DOM analog.", 
            "title": "Virtual DOM"
        }, 
        {
            "location": "/legacy/0.9/concepts/#parallel-dom", 
            "text": "Ractive works by maintaining a simplified model of the part of the DOM that it's responsible for. This model contains all the information - about data-binding, event handling and so on - that it needs to keep things up-to-date.  You can inspect the parallel DOM to understand what's going on under the hood, if you're into that sort of thing. Each Ractive instance, once rendered, has a  fragment  property. Each fragment has a number of properties:   contextStack  - the context stack in which mustache references should be evaluated  root  - a reference to the Ractive instance to which it belongs  owner  - the  item  that owns this fragment (in the case of the root fragment, the same as  root )  items  - the items belonging to this fragment   Items  means elements, text nodes, and mustaches. Elements may have fragments of their own (i.e. if they have children). A partial mustache will have a fragment, and a section mustache will have zero or more fragments depending on the value of its keypath.  Elements may also have attributes, which have a different kind of fragment (a  text fragment  as opposed to a  DOM fragment ), containing text and mustaches.  Each item has a  descriptor , which is something like DNA. This comes straight from the parsed template.  This is the briefest of overviews - if you want to gain a deeper understanding of what's going on under the hood,  use the source .", 
            "title": "Parallel DOM"
        }, 
        {
            "location": "/legacy/0.9/concepts/#states", 
            "text": "Items generally follow a fixed lifecycle.   Construction - the item is created and knows about its parent and the template chunk from which it was created. Its template may also indicate what its children should look like if it has them.  bind  - the item looks up any references is may have and registers with the model(s) that they represent. At this point, the item may create child items and bind them as well.  render  - the item may create an actual DOM node and tell its children to create their DOM nodes as necessary. The resulting nodes will be inserted into the document.  unrender  - thie item is no longer needed and will be removed from the document immediately or in the near future.  unbind  - this typically goes along with  unrender  and tells the models on which this item depends that they should no longer send change notifications to it.   There is a sixth floating step  rebind  that happens any time one dependency models shuffles (and in certain other very special circumstances) that causes the items to re-resolve their models and re-register if necessary.", 
            "title": "States"
        }, 
        {
            "location": "/legacy/0.9/concepts/#virtual-dom-items", 
            "text": "", 
            "title": "Virtual DOM Items"
        }, 
        {
            "location": "/legacy/0.9/concepts/#text", 
            "text": "Text is the simplest item. It simply holds a string that it turns into a  TextNode  when rendered.", 
            "title": "Text"
        }, 
        {
            "location": "/legacy/0.9/concepts/#interpolator", 
            "text": "This is the next simplest item. It resolves a model for its reference or expression and renders the value of the model as a text node if needed. Interpolators don't necessarily render directly, as they may be used for values by other items, such as attributes, mappings, and bindings.", 
            "title": "Interpolator"
        }, 
        {
            "location": "/legacy/0.9/concepts/#element", 
            "text": "An  Element  represents a DOM element. It also contains a number of other items in the form of  Attribute s,  Decorator s,  Transition s,  EventDirective s, and its children in a  Fragment .", 
            "title": "Element"
        }, 
        {
            "location": "/legacy/0.9/concepts/#attributes", 
            "text": "There are actually several different items that are treated as attributes for  Element s, event though only two of them actually may render into the DOM.   Attribute s - maybe obvious, they these represent a DOM attribute on their parent element. There are a number of different handlers for updating attributes depending on the element and attribute name. The  updateDelegate  for a particular attribute can be found in  getUpdateDelegate.js .  ConditionalAttribute s - render as a string and are parsed into actual DOM attributes using a  div  or an  svg  depending on their parent element.  Mapping s - when rendered add a mapping to their component, and when unrendered, remove it. These aren't attached to  Element s, but instead, are attached to  Component s (see below).  EventDirective s - when rendered attach an event listener to their parent, and when unrenedered, remove it. Event parameters are kept in sync with their bindings and are evaluated when the event fires.  BindingDirective s - when rendered and unrendered update their parent element's bindings, if they exist.  Decorator s - when rendered call the named decorator with their parent element, and when unrenedered, remove it.  Decorator s also have an update cycle related to their parameters.  Transition s - are a sort of weird case. When rendered, they attach a transition handler to their element, and when the element renders or unrenders, if an appropriate transition handler is registered, will trigger the transition. Transition parameters are also kept in sync with their bindings.", 
            "title": "Attributes"
        }, 
        {
            "location": "/legacy/0.9/concepts/#bindings", 
            "text": "Certain attributes may also trigger a binding to be created on their parent element. For instance, if two-way binding is enabled on the parent element, and the parent element is an  input , a  value  attribute with a single  Interpolator  as its content will cause a two-way binding to be created between the value of the  input  and the model of the  Interpolator . This binding will handle updating the model when the input  value  has changed. There are a few other types of bindings for managing check values, content editables, name-bound lists of checkboxes, and other miscellaneous special values.  A  lazy  binding directive will cause any associated two-way bindings to fire either after a timeout or on blur, depending on the value of the  lazy  directive.", 
            "title": "Bindings"
        }, 
        {
            "location": "/legacy/0.9/concepts/#section", 
            "text": "Section s come in many flavors, depending on the chunk of template from which they are created. A section may provide context, be conditional (positive or negative), or be iterative. Generic sections ( {{#something}}...{{/}}  in template) will adjust their type, to a certain extent, based on the value of their model. A generic section will always provide context in the form of their model. An  if -style conditional section, including  elseif ,  else , and  unless  do not provide context. An  each  section will always provide context in the form of the current iteration. A  with  section will always provide context as its model, but it will only render if its model is considered truthy by Ractive, which is pretty much the same as JS truthy except  {}  and  []  are falsey. A generic section will be context/conditional if it is anything other than an array, which will make it iterative.  Sections that provide context do so by binding their  Fragment s with their model so that the reference resolution process can find the appropriate contexts when resolving.", 
            "title": "Section"
        }, 
        {
            "location": "/legacy/0.9/concepts/#contextconditional", 
            "text": "Context and conditional sections will render and unrender their child fragment as their model changes truthiness. Conditional sections always stand alone, even it they have  elseif  or  else  branches nested within them, because those branches are turned into independent sections during parsing.", 
            "title": "Context/Conditional"
        }, 
        {
            "location": "/legacy/0.9/concepts/#iterative", 
            "text": "If section is designated iterative ( {{#each ...}} ) or is a general section with an array value resolution, the section will create a special form of fragment for each index or key in the value. The special form  RepeatedFragment  handles mapping of indices, keys, and references to those to a corresponding model. Iterative sections also have special handling for shuffles so that DOM is not wholesale destroyed and recreated when the array shuffles.  Iterative sections may supply an alias for their context, so that referencing the iterated value is a little bit easier. See  Aliases  below for more info, as this is just a slightly specialized form of that.  Iterative sections may also supply key and/or index aliases so that their keys and/or indices may be referenced by a name from within their child fragments.", 
            "title": "Iterative"
        }, 
        {
            "location": "/legacy/0.9/concepts/#alias", 
            "text": "Alias sections simply resolve their models and act as a lookup endpoint for reference resolution. Aliasing happens entirely in the view.", 
            "title": "Alias"
        }, 
        {
            "location": "/legacy/0.9/concepts/#component", 
            "text": "A component is a sort-of special form of  Element  that, instead of creating a DOM element, creates a new Ractive instance. The child instance will be rendered and unrendered in place of the component placeholder in the DOM.  Any plain  Attribute s with a single  Interpolator  as content in a component's template are turned into  Mapping s.  The resolution process no longer happens strictly within the vDOM, as the result of  Ractive.getContext  also uses the target  Element 's fragment to resolve relative references. Event objects are also extended with methods from the same helper.", 
            "title": "Component"
        }, 
        {
            "location": "/legacy/0.9/concepts/#updates", 
            "text": "The  runloop  controls when the DOM is actually updated and when transitions start in  batch es. It also handles resolving promises when transitions have completed and the DOM is completely up to date.  As changes propagate through the viewmodel, view items are notified of the change through their  handleChange  method. Most items just set a dirty flag and notify their parent, via their  bubble  method, that they will need to be updated at the completion of the runloop turn. The root fragment of each instance affected will then register with the runloop. Once the changes are ready to be flushed to the view, each fragment registered with the runloop is called on to update, where the process happens in reverse, with each parent fragment checking to see if there is a change it needs to respond to and propagating the update downward to its children.", 
            "title": "Updates"
        }, 
        {
            "location": "/legacy/0.9/concepts/#data-management", 
            "text": "", 
            "title": "Data management"
        }, 
        {
            "location": "/legacy/0.9/concepts/#dependents", 
            "text": "Ractive maintains a dependency graph in order to do only the minimum amount of work necessary to keep the DOM up-to-date. If you inspect a Ractive instance, you'll see a property called  _deps . This is where all dependants are listed, indexed by their dependency.", 
            "title": "Dependents"
        }, 
        {
            "location": "/legacy/0.9/concepts/#expression-dependencies", 
            "text": "Ractive uses dynamic analysis to determine dependencies. Depedendencies are determined by capturing references in the viewmodel while the function is executing. Dependencies for functions are re-captured each time the function is executed.  p {{ formattedName() }} /p   var ractive = Ractive({\n  template: template,\n  el: output,\n  data: {\n    user: { firstName: 'John', lastName: 'Public' },\n    formattedName () {\n      return this.get('user.lastName') + ', ' + this.get('user.firstName')\n    }\n  }\n}  Result:  p Public, John /p   In this example, the function  formattedName  will depend on both  user.firstName  and  user.lastName , and updating either (or  user ) will cause any expressions referencing  formattedName  to be re-evaluated as well.  ractive.set('user.firstName', 'Jane')  Result:  p Public, Jane /p", 
            "title": "Expression dependencies"
        }, 
        {
            "location": "/legacy/0.9/concepts/#priority", 
            "text": "Ractive runs updates based on priority. For instance, when a subtree of the DOM needs to be removed while at the same time updates are pending for that subtree. What Ractive does is prioritize the removal of the subtree over the updates. This causes the dependents on the subtree to unregister themselves, eliminating the need to update, resulting with only the removal operation being done.", 
            "title": "Priority"
        }, 
        {
            "location": "/legacy/0.9/concepts/#indirect-dependencies", 
            "text": "If you have a mustache which depends on  foo.bar , and  foo  changes, it's quite possible that the mustache needs to re-render. We say that the mustache has an  indirect dependency  on  foo , or that it has a  direct dependency on a downstream keypath  of  foo .  This relationship is expressed through the  _depsMap  property of a Ractive instance - whenever  foo  changes, as well as dealing with direct  foo  dependants we check the map for those indirect dependants.  In the case of expressions and observers, we also need to consider dependants of  upstream keypaths . For example, suppose we have a section based on a sorted array - if we modify one of the members of the array, we need to see if the sort order has changed or not as a result:  {{#( sort( list, 'name' ) )}}\n   p {{name}} /p \n{{/()}}  ractive = Ractive({\n  el: myContainer,\n  template: myTemplate,\n  data: {\n    list: [{ name: 'Bob' }, { name: 'Charles' }, { name: 'Alice' }],\n    sort ( list, property ) {\n      return list.slice().sort( function ( a, b ) {\n        return a[ property ]   b[ property ] ? -1 : 1\n      })\n    }\n  }\n})\n\n// renders Alice, Bob, Charles\n\nractive.set( 'list[0].name', 'Zebediah' )\n\n// updates to Alice, Charles, Zebediah  In the example, setting  list[0].name  causes dependants of  list  to be updated.  As well as expressions, Observers respond to both upstream and downstream changes.", 
            "title": "Indirect dependencies"
        }, 
        {
            "location": "/legacy/0.9/concepts/#expressions-with-multiple-dependencies", 
            "text": "The expression  {{ a + b }}  has two dependencies -  a  and  b  (or more accurately, whatever those references resolve to). The  _deps  graph actually includes objects representing those individual references, rather than the expression itself - the reference objects then notify the expression (if their value has changed) that it will need to re-evaluate itself.  Because the expression has multiple dependencies, it won't trigger an update straight away - it will wait until all the new data has come in first. So doing  ractive.set({ a: 1, b: 2 })  will only trigger one update, not two.", 
            "title": "Expressions with multiple dependencies"
        }, 
        {
            "location": "/legacy/0.9/concepts/#two-way-binding", 
            "text": "Two-way binding allows data to update bi-directionally, from data to the UI and vice versa.   Ractive({\n  data: {\n    msg: 'Hello, World!'\n  },\n  template: `\n     input type= text  value= {{ msg }}  {{ msg }}\n\n     button on-click= @this.set('msg', 'Lorem Ipsum') To lipsum /button \n  `\n})  Two-way binding can be disabled via the  twoway  initialization option or the  twoway  input directive.", 
            "title": "Two-way binding"
        }, 
        {
            "location": "/legacy/0.9/concepts/#ambiguous-references", 
            "text": "An ambiguous reference refers to a reference whose data does not exist at the time of construction. Ractive must make an assumption, following a resolution algorithm, on what ambiguous references resolve to. Until a suitable keypath pops into existence, ambiguous references resolve to  undefined .   Ractive({\n  data: {},\n  template: `\n     input value= {{ msg }}  {{ msg }}\n  `,\n})  Ambiguous references can be locked to a specific keypath, skipping the whole resolution process, using keypath prefixes.", 
            "title": "Ambiguous references"
        }, 
        {
            "location": "/legacy/0.9/concepts/#lazy-updates", 
            "text": "By default, Ractive uses various events (i.e.  change ,  click ,  input ,  keypress ) to listen for changes on interactive elements and immediately update bound data. In cases where data updates should only take place after the element loses focus, Ractive also supports lazy updating.   Ractive({\n  lazy: true,\n  data: {\n    msg: ''\n  },\n  template: `\n     div Type and click outside the input /div \n     input type= text  value= {{ msg }}  {{ msg }}\n  `\n})  Lazy updates can be enabled via the  lazy  initialization option or the  lazy  directive.", 
            "title": "Lazy updates"
        }, 
        {
            "location": "/legacy/0.9/concepts/#computed-properties", 
            "text": "Computed properties are top-level pseudo-data references whose value is defined by a computation and which automatically update when its dependencies update.", 
            "title": "Computed Properties"
        }, 
        {
            "location": "/legacy/0.9/concepts/#function-syntax", 
            "text": "The function syntax defines a computed property as a function that returns the computed value. The context of the function is the current instance.   Ractive({\n  data: {\n    width: 200,\n    length: 300\n  },\n  computed: {\n    area () {\n      return this.get('width') * this.get('length')\n    }\n  },\n  template: `\n    Width:  input type= text  value= {{ width }} \n    Length:  input type= text  value= {{ length }} \n    Area: {{ area }}\n  `\n})", 
            "title": "Function syntax"
        }, 
        {
            "location": "/legacy/0.9/concepts/#expression-syntax", 
            "text": "The expression syntax defines a computed property as a string containing a JavaScript expression.  ${}  is replaced internally with a  ractive.get() , using its contents as a keypath.   Ractive({\n  data: {\n    width: 200,\n    length: 300\n  },\n  computed: {\n    area: '${width} * ${length}'\n  },\n  template: `\n    Width:  input type= text  value= {{ width }} \n    Length:  input type= text  value= {{ length }} \n    Area: {{ area }}\n  `\n})", 
            "title": "Expression syntax"
        }, 
        {
            "location": "/legacy/0.9/concepts/#accessor-syntax", 
            "text": "Both function and expression syntaxes only describe retrieval of the computed property's value, and therefore makes the computed property read-only. The accessor syntax defines a computed property by providing  get  and  set  methods.  get  is called to retrieve its value and  set  is called when something updates its value.   Ractive({\n  data: {\n    side: 200\n  },\n  computed: {\n    area: {\n      get () {\n        return Math.pow(this.get('side'), 2)\n      },\n      set(v) {\n        this.set('side', Math.sqrt(v))\n      }\n    }\n  },\n  template: `\n    Side:  input type= text  value= {{ side }} \n    Area:  input type= text  value= {{ area }} \n  `\n})  Both function and expression syntaxes are supported for the  get  method.", 
            "title": "Accessor syntax"
        }, 
        {
            "location": "/legacy/0.9/concepts/#observers", 
            "text": "", 
            "title": "Observers"
        }, 
        {
            "location": "/legacy/0.9/concepts/#nested-properties", 
            "text": "Observers observe  upstream  and  downstream  keypaths. This allows observers to execute when data is updated indirectly, whether if it's the enclosing structure or a descendant structure.   const instance = Ractive({\n  data: {\n    foo: {\n      bar: 1\n    }\n  },\n  observe: {\n    'foo' (newValue) {\n      console.log('foo changed to', newValue)\n    },\n    'foo.bar' (newValue) {\n      console.log('foo.bar changed to', newValue)\n    }\n  }\n})\n\ninstance.set('foo.bar', 2)\ninstance.set('foo', { bar: 3 })  Observers can be set to only execute on the specified keypath via the  strict  option for both  observe  initialization option and  ractive.observe() .", 
            "title": "Nested properties"
        }, 
        {
            "location": "/legacy/0.9/concepts/#wildcards", 
            "text": "Wildcards allow observers to observe keypaths whose segments cannot be determined in advance. This is useful when observing an array, observing items within an array, or observing changes on object properties.   const instance = Ractive({\n  data: {\n    people: [\n      {name: 'Rich Harris'},\n      {name: 'Marty Nelson'}\n    ],\n    config: {\n      allowComments: true,\n      allowEdit: false\n    }\n  },\n  observe: {\n    // Observe changes on the array\n    'people.*' () {\n      console.log('array observer', arguments)\n    },\n    // Observe changes on the name property of any item in the array\n    'people.*.name' () {\n      console.log('array item observer', arguments)\n    },\n    // Observe changes on any property of an object\n    'config.*' () {\n      console.log('object property observer', arguments)\n    }\n  }\n})\n\ninstance.push('people', {name: 'Jason Brown'})\ninstance.set('people.3', {name: 'Jack Black'})\ninstance.set('config.allowEdit', true)", 
            "title": "Wildcards"
        }, 
        {
            "location": "/legacy/0.9/concepts/#multiple-sources", 
            "text": "Multiple keypaths can be observed by adding them one after the other, separating them with a space.   const instance = Ractive({\n  data: {\n    user: {username: 'browniefed'},\n    config: {isAdmin: false},\n    commentCount: 0\n  },\n  observe: {\n    'user.username config.isAdmin commentCount' () {\n      console.log('data changed', arguments)\n    }\n  }\n})\n\ninstance.set('user.username', 'chris')\ninstance.set('config.isAdmin', true)\ninstance.set('commentCount', 42)", 
            "title": "Multiple sources"
        }, 
        {
            "location": "/legacy/0.9/concepts/#caveats", 
            "text": "Observers do not defensively clone the old and new values as identity of these values may be essential. Thus, observers on non-primitive values may result in having identically equal old and new values.   const instance = Ractive({\n  data: {\n    config: {\n      allowComments: true,\n      allowEdit: false\n    }\n  },\n  observe: {\n    'config' (newValue, oldValue) {\n      console.log(newValue === oldValue)\n    }\n  }\n})\n\ninstance.set('config.allowEdit', true)  Both  observe  initialization option and  ractive.observe()  accept an  old  option which allows you to define the old value passed to the observer prior to modifications.", 
            "title": "Caveats"
        }, 
        {
            "location": "/legacy/0.9/concepts/#components", 
            "text": "", 
            "title": "Components"
        }, 
        {
            "location": "/legacy/0.9/concepts/#mappings_1", 
            "text": "Mappings connect pieces of data on the enclosing instance to data on enclosed instances. Changes on one side will reflect on the other.  Ractive.components.MyComponent = Ractive.extend({\n  data: {\n    message: ''\n  },\n  template: `\n     input type= text  value= {{ message }} \n  `\n})\n\nconst instance = Ractive({\n  el: 'body',\n  data: {\n    text: ''\n  },\n  template: `\n     MyComponent message= {{ text }} / \n  `\n})\n\nractive.set('text', 'Hello World!')  In the example above,  text  on the instance is mapped to  MyComponent 's  message . Updates on  text  will update  message  and any UI elements bound to it. Updates on  message , like editing the  input  bound with it, will update  text .", 
            "title": "Mappings"
        }, 
        {
            "location": "/legacy/0.9/concepts/#data-context", 
            "text": "Each component instance comes with its own data context so that its data does not pollute the primary data. Any mapping between the component and the enclosing instance will still update across both contexts.  Ractive.components.MyComponent = Ractive.extend({\n  data: {\n    shades: '',\n    option: ''\n  }\n})\n\nconst instance = Ractive({\n  template: `\n     MyComponent shades='{{colors}}' option='A' / \n  `,\n  data: {\n    name: 'Colors',\n    colors: ['red', 'blue', 'yellow']\n  }\n})\n\nconst widget = ractive.findComponent('MyComponent')\n\nractive.get() // { colors :[ red , blue , yellow ],  name : Colors }\nwidget.get()  // { shades :[ red , blue , yellow ],  option : A }\n\nractive.set('colors.1', 'green')\n\nractive.get() // { colors :[ red , green , yellow ],  name : Colors }\nwidget.get()  // { shades :[ red , green , yellow ],  option : A }  In the example above, the enclosing instance data holds  name  and  colors .  colors  is mapped to  shades  and  option  is set on an instance of  MyComponent . Upon inspection,  name  from the enclosing instance does not cross over to  MyComponent  nor does  option  cross over to the enclosing instance. However, since  colors  on the instance is mapped to  shades  on the component, any modifications on either side will reflect on the other.", 
            "title": "Data context"
        }, 
        {
            "location": "/legacy/0.9/concepts/#isolation", 
            "text": "By default, components are \"isolated\". Descendant components can update ancestor data only when there is an explicit mapping between them. This avoids unintended mutation of ancestor data and ensures portability of components.  Ractive.components.ChildComponent = Ractive.extend({\n  template: 'Message missing {{ message }}'\n})\n\nconst instance = Ractive({\n  el: 'body',\n  template: ' ChildComponent / ',\n  data: {\n    message: 'The ChildComponent will not know anything about this message'\n  }\n})  In the example above,  ChildComponent  will not print anything since  message  is not defined in the component and due to isolation, the component cannot see the instance's  message .  Isolation can be disabled via the  isolated  initialization option.", 
            "title": "Isolation"
        }, 
        {
            "location": "/legacy/0.9/concepts/#event-management", 
            "text": "Like many other libraries, Ractive implements its own  publish/subscribe  mechanism for triggering and responding to particular events. One of the advantages of using Ractive-managed events is that events are automatically unsubscribed and unreferenced once the instance is torn down, avoiding the need to do manual housekeeping.", 
            "title": "Event Management"
        }, 
        {
            "location": "/legacy/0.9/concepts/#sources", 
            "text": "", 
            "title": "Sources"
        }, 
        {
            "location": "/legacy/0.9/concepts/#event-api", 
            "text": "Events that are published as a result of using the event APIs directly (i.e.  ractive.fire ). Most of the other event sources use the event APIs to publish events at some point in their operation.  instance.fire('someevent', 'Hello, World!')", 
            "title": "Event API"
        }, 
        {
            "location": "/legacy/0.9/concepts/#lifecycle-events", 
            "text": "Lifecycle events are events that are published by an instance during the different phases of its existence. Ractive instances publish the following lifecycle events:   construct  config  init  render  complete  update  insert  detach  unrender  teardown  destruct   Lifecycle event names are reserved. They should not be used as names of other events.", 
            "title": "Lifecycle events"
        }, 
        {
            "location": "/legacy/0.9/concepts/#dom-events", 
            "text": "DOM events are events that are published by the DOM.  button on-click= ...", 
            "title": "DOM events"
        }, 
        {
            "location": "/legacy/0.9/concepts/#custom-events", 
            "text": "Custom events are events that are published by event plugins.  img on-tap= ...", 
            "title": "Custom events"
        }, 
        {
            "location": "/legacy/0.9/concepts/#component-events", 
            "text": "Component events are events that are published by  components .  MyModal on-close= ...  /", 
            "title": "Component events"
        }, 
        {
            "location": "/legacy/0.9/concepts/#handling", 
            "text": "", 
            "title": "Handling"
        }, 
        {
            "location": "/legacy/0.9/concepts/#event-api_1", 
            "text": "Events published from the direct use of the event APIs are also handled by directly using the event APIs (i.e.  ractive.on ,  ractive.once ). Most of the other handling methods use the event APIs to handle events at some point in their operation.  instance.on('someevent', (context, message) =  {\n  console.log(message)\n})", 
            "title": "Event API"
        }, 
        {
            "location": "/legacy/0.9/concepts/#lifecycle-events_1", 
            "text": "Lifecycle events are handled by assigning a function to the appropriate lifecycle event initialization option.  Ractive({\n  onrender () {\n    console.log('instance has been rendered')\n  }\n})  The event APIs can also subscribe to lifecycle events. However, the handler must subscribe prior to the event publishing. Using the lifecycle event initialization options is the safer option to ensure the correct timing of subscriptions.", 
            "title": "Lifecycle events"
        }, 
        {
            "location": "/legacy/0.9/concepts/#proxy-syntax", 
            "text": "Ractive instances do not immediately subscribe to template-based events (DOM events, component events, custom events). The proxy syntax \"proxies\" template-based events into events that the current instance can subscribe to. From there, the events are handled by event APIs. Arguments are not supported in this syntax.  Ractive({\n  template: `\n     button on-click= buttonclicked Click Me! /button \n  `,\n  on: {\n    buttonclicked (context) {\n      console.log('button clicked')\n    }\n  }\n})", 
            "title": "Proxy syntax"
        }, 
        {
            "location": "/legacy/0.9/concepts/#expression-syntax_1", 
            "text": "A more powerful form of template-based event handling is the expression syntax, which allows the use of expressions as their values. This form acts very similar to inline scripts plus some useful additions. The expression syntax also has full, unmustached access to data and special references.  The first form is a special form of the proxy syntax. It accepts an array whose first item is the event name, and the rest are its arguments.  Ractive({\n  template: `\n     button on-click= ['buttonclicked', 'foo', 'bar'] Click Me! /button \n  `,\n  on: {\n    buttonclicked (context, foo, bar) {\n      console.log('button clicked passing', foo, bar)\n    }\n  }\n})  The second form uses expressions directly. This allows unrestricted access to almost anything, from calling instance methods, custom methods, or even firing a proxy event manually.  Ractive({\n  data: { msg: '' },\n  template: `\n     button on-click= @this.set('msg', 'Hello, World!') Set message /button \n     button on-click= @this.greetz(msg) Print message /button \n     button on-click= @this.fire('manualproxy', msg) Print message via proxy /button \n     button on-click= @this.set('foo', 1), @this.set('bar', 2) Cccombo!!! /button \n  `,\n  greetz(message) {\n    console.log(`${message}`)\n  },\n  on: {\n    manualproxy (context, message) {\n      console.log(`${message}`)\n    }\n  }\n})", 
            "title": "Expression syntax"
        }, 
        {
            "location": "/legacy/0.9/concepts/#event-context", 
            "text": "Event handlers, regardless of event source, receive an  context  object as first argument. The  context  object is a special instance of a context object augmented with additional event-related properties where applicable.   name  - The name of the published event.  node  - A reference to the DOM node publishing the event. Only available on DOM events.  event  - A reference to the DOM event. Only available on DOM  original  - A reference to the DOM event. Only available on DOM  component  - A reference to the component that published the event. Only available on propagated events.   Ractive({\n  template: `\n     button on-click= buttonclicked Click Me! /button \n  `,\n  on: {\n    buttonclicked (context) {\n      console.log(event.node.type) // submit\n    }\n  }\n})", 
            "title": "Event context"
        }, 
        {
            "location": "/legacy/0.9/concepts/#namespacing", 
            "text": "Pattern-matching is supported on any type of event, allowing a form of event namespacing. This is done by using a keypath-like event name and using wildcards ( * ) on segments during subscription.  Ractive({\n  el: 'body',\n  append: true,\n  template: `\n     button on-click= foo.bar Click Me! /button \n     button on-click= foo.baz Click Me! /button \n     button on-click= foo.bam Click Me! /button \n     button on-click= qux.bar Click Me! /button \n     button on-click= qux.baz Click Me! /button \n     button on-click= qux.bam Click Me! /button \n  `,\n  on: {\n    '*.bar' (context) {\n      console.log('A bar event was published')\n    },\n    'qux.*' (context) {\n      console.log('A qux event was published')\n    }\n  }\n})  Be aware that handlers subscribing to just  *  will fire for  all  events.", 
            "title": "Namespacing"
        }, 
        {
            "location": "/legacy/0.9/concepts/#propagation", 
            "text": "", 
            "title": "Propagation"
        }, 
        {
            "location": "/legacy/0.9/concepts/#dom-event-propagation", 
            "text": "Native DOM event propagation is preserved, allowing things such as delegation.  Ractive({\n  template: `\n     div on-click= buttonclicked \n       button type= button Click Me! /button \n     /div \n  `,\n  on: {\n    buttonclicked (context) {\n      console.log('button clicked')\n    }\n  }\n})", 
            "title": "DOM event propagation"
        }, 
        {
            "location": "/legacy/0.9/concepts/#component-propagation", 
            "text": "Propagation across component boundaries is also supported. Propagating events are namespaced using the publishing component's name as prefix. This applies to component, proxy, and even lifecycle events.  const ChildComponent = Ractive.extend({\n  template: ' div /div ',\n  oncomplete () {\n    this.fire('childevent')\n  }\n})\n\nconst ParentComponent = Ractive.extend({\n  components: { ChildComponent },\n  template: ' ChildComponent / '\n})\n\nconst instance = Ractive({\n  components: { ParentComponent },\n  template: ' ParentComponent / '\n})\n\ninstance.on('ChildComponent.childevent', function () {\n  console.log('Hello World!')\n})", 
            "title": "Component propagation"
        }, 
        {
            "location": "/legacy/0.9/concepts/#stopping-propagation", 
            "text": "Propagation can be stopped by simply returning  false  from an event handler. If the event is a DOM event,  event.stopPropagation()  and  event.preventDefault()  are automatically called.  Ractive({\n  template: `\n     div on-click= ancestorbuttonclick \n       button on-click= descendantbuttonclick Click Me! /button \n     /div \n  `,\n  on: {\n    ancestorbuttonclick (context) {\n      console.log('This will not run')\n    },\n    descendantbuttonclick (context) {\n      console.log('This will run')\n      return false\n    }\n  }\n})  Returning  false  also stops propagation across components.  const ChildComponent = Ractive.extend({\n  template: ' div /div ',\n  oncomplete () {\n    this.fire('childevent')\n  }\n})\n\nconst ParentComponent = Ractive.extend({\n  components: { ChildComponent },\n  template: ' ChildComponent / ',\n  on: {\n    'ChildComponent.childevent' () {\n      return false\n    }\n  }\n})\n\nconst instance = Ractive({\n  components: { ParentComponent },\n  template: ' ParentComponent / '\n})\n\ninstance.on('ChildComponent.childevent', function () {\n  console.log('This will not run')\n})  Assigning a handler using  on-*  will also stop propagation. However, if  on-*  is assigned a proxy event and not stopped, that proxy event will propagate in place of the stopped event.  const ChildComponent = Ractive.extend({\n  template: ' div /div ',\n  oncomplete () {\n    this.fire('childevent1')\n    this.fire('childevent2')\n    this.fire('childevent3')\n    this.fire('childevent4')\n  }\n})\n\nconst ParentComponent = Ractive.extend({\n  components: { ChildComponent },\n  template: `\n     ChildComponent\n      on-childevent1= \n      on-childevent2= childevent2proxy \n      on-childevent3= childevent3proxy \n      on-childevent4= @this.parentMethod() \n    / \n  `,\n  on: {\n    childevent2proxy () {\n      // childevent2proxy replaces childevent2\n    },\n    childevent3proxy () {\n      // childevent3proxy replaces childevent3 but stopped\n      return false\n    }\n  },\n  parentMethod () {\n    // childevent4 handled by a method\n  }\n})\n\nconst instance = Ractive({\n  components: { ParentComponent },\n  template: ' ParentComponent / '\n})\n\ninstance.on('ChildComponent.childevent1', function () {\n  console.log('childevent1 stopped by a blank handler')\n})\n\ninstance.on('ChildComponent.childevent2', function () {\n  console.log('childevent2 stopped by a proxy event')\n})\n\ninstance.on('ChildComponent.childevent3', function () {\n  console.log('childevent3 stopped by a proxy event')\n})\n\ninstance.on('ChildComponent.childevent4', function () {\n  console.log('childevent4 stopped by a method call')\n})\n\ninstance.on('ParentComponent.childevent3proxy', function () {\n  console.log('childevent3proxy stopped by returning false')\n})\n\n// This one gets through since its proxy event was left to propagate\ninstance.on('ParentComponent.childevent2proxy', function () {\n  console.log('childevent2proxy fired')\n})", 
            "title": "Stopping propagation"
        }, 
        {
            "location": "/legacy/0.9/concepts/#rendering", 
            "text": "", 
            "title": "Rendering"
        }, 
        {
            "location": "/legacy/0.9/concepts/#synchronous-rendering", 
            "text": "Ractive does not batch renders, asynchronously render, nor render at next tick. The instance's DOM is updated immediately after its dependencies update. This is a trade-off between optimization and predictability. Ractive chose the latter route to make it easier to anticipate the state of the DOM at any given moment.   const instance = Ractive({\n  target: 'body',\n  data: {\n    count: 0,\n  },\n  template: `\n     div {{ count }} /div \n  `,\n})\n\nconst div = instance.find('div')\n\nconsole.log('Before:', div.innerHTML)\ninstance.set('count', 100)\nconsole.log('After:', div.innerHTML)\n\n// Before: 0\n// After: 100  The only time rendering happens asynchronously is during animations and transitions. All mutator methods return a promise which resolves when the animations and/or transitions resulting from these operations complete.   const instance = Ractive({\n  target: 'body',\n  data: {\n    count: 0,\n  },\n  template: `\n     div {{ count }} /div \n  `,\n})\n\nconst div = instance.find('div')\n\nconsole.log('Before:', div.innerHTML)\ninstance.animate('count', 100).then(() =  {\n  console.log('Resolved:', div.innerHTML)\n})\nconsole.log('After:', div.innerHTML)\n\n// Before: 0\n// After: 0\n//\n// Resolved: 100", 
            "title": "Synchronous rendering"
        }, 
        {
            "location": "/legacy/0.9/concepts/#scoped-css", 
            "text": "CSS provided via the  css  initialization option is scoped to the component.  const Component = Ractive.extend({\n  template: `\n     span I'm red /span \n     div \n       span I'm also red /span \n     /div \n  `,\n  css: `\n    span { color: red }\n  `\n})\n\nRactive({\n  components: { Component },\n  el: 'body',\n  template: `\n     Component / \n     span I'm not red /span \n  `\n})  This is done by generating a unique id for each component definition. That ID is then added to each selector defined in  css  and to each top-level element in the component's DOM.  span[data-ractive-css~= {6f9bd745-a6b9-9346-0c8c-e3cc94b3d2a5} ],\n[data-ractive-css~= {6f9bd745-a6b9-9346-0c8c-e3cc94b3d2a5} ] span {\n  color: red\n}  span data-ractive-css= {6f9bd745-a6b9-9346-0c8c-e3cc94b3d2a5} I'm red /span  div data-ractive-css= {6f9bd745-a6b9-9346-0c8c-e3cc94b3d2a5} \n   span I'm also red /span  /div  span I'm not red /span   Currently, there are a few limitations to this feature:   ID-based scoping is not true component scoping and will affect elements of descendant components.  css  can only be used with components and not on direct Ractive instances. This may change in the future.", 
            "title": "Scoped CSS"
        }, 
        {
            "location": "/legacy/0.9/concepts/#progressive-enhancement", 
            "text": "TODO", 
            "title": "Progressive Enhancement"
        }, 
        {
            "location": "/legacy/0.9/concepts/#server-side", 
            "text": "Server-side rendering can be achieved using  ractive.toHTML()  and  ractive.toCSS() . Both methods render the instance and its descendants at their current state to HTML and CSS, respectively.  const Component1 = Ractive.extend({\n  data: {\n    message: ''\n  },\n  template: `\n     div class= component1 {{message}} /div \n  `,\n  css: `\n    .component1 { color: red }\n  `\n})\n\nconst Component2 = Ractive.extend({\n  data: {\n    greeting: ''\n  },\n  template: `\n     div class= component2 {{greeting}} /div \n  `,\n  css: `\n    .component2 { color: green }\n  `\n})\n\nconst App = Ractive.extend({\n  components: {\n    Component1,\n    Component2\n  },\n  data: {\n    greet: '',\n    msg: ''\n  },\n  template: `\n     Component1 message= {{ msg }}  / \n     Component2 greeting= {{ greet }}  / \n  `\n})\n\nconst state = { greet: 'Good Morning!', msg: 'Hello, World!' }\nconst app = App({ data: state })\nconst html = app.toHTML()\nconst css = app.toCSS()  Currently, there are a few limitations to this feature:   ractive.toHTML()  prints HTML without component IDs while  ractive.toCSS()  prints out selectors with component IDs, which causes the HTML and CSS to not match up.  A workaround is to render the CSS as is by setting  noCssTransform  to  true  and to use a CSS naming convention (i.e BEM, OOCSS, SMACSS) to match up selectors with their elements.    ractive.toHTML()  does not automatically insert the document CSS when rendering a component that represents a full document. This must be done manually.", 
            "title": "Server-side"
        }, 
        {
            "location": "/legacy/0.9/concepts/#security", 
            "text": "", 
            "title": "Security"
        }, 
        {
            "location": "/legacy/0.9/concepts/#use-of-the-function-constructor", 
            "text": "Ractive uses the  Function  constructor only to convert expressions (i.e. mustache expressions, expression-style computed properties) into value-generating functions. As of 0.9,  allowExpressions  initialization option is available to toggle the expression-to-function feature. Setting it to  false  will tell Ractive neither to parse nor process expressions.", 
            "title": "Use of the Function constructor"
        }, 
        {
            "location": "/legacy/0.9/concepts/#content-security-policy", 
            "text": "Out of the box, Ractive will violate certain CSP directives due to the use of the  Function  constructor for evaluating expressions, and dynamically generated  style  elements for Ractive-managed CSS.  In order to avoid violating  script-src , either:   Pre-parse templates. As of 0.8, the parser will store expressions as functions on the AST. To preserve the functions when serializing the AST, use libraries like  node-tosource  or  serialize-javascript  instead of  JSON.stringify() .  Set  allowExpressions  initialization option to  false . This will tell Ractive to avoid evaluating expressions.  Add the  script-src 'unsafe-eval'  CSP directive. This will allow the use of the  Function  constructor.   In order to avoid violating  style-src , either:   Add  style-src 'unsafe-inline'  to your CSP directives. This will allow the use of dynamically generated  style  elements.", 
            "title": "Content Security Policy"
        }, 
        {
            "location": "/legacy/0.9/concepts/#templates", 
            "text": "Strictly speaking, Ractive templates are not HTML. They are markup representations of objects that are used to construct HTML. Simply put, templates are  HTML-like . Ractive parses templates into  AST s which contain everything Ractive needs to know to construct an instance's DOM, data bindings, events and transitions etc.  Ractive.parse(' div class= message Hello World! /div ')\n\n// { v :4, t :[{ t :7, e : div , m :[{ n : class , f : message , t :13}], f :[ Hello World! ]}]}", 
            "title": "Templates"
        }, 
        {
            "location": "/legacy/0.9/concepts/#keypaths", 
            "text": "A keypath is a kind of reference that represents the location of a piece of data.  Ractive({\n  data: {\n    foo: {\n      bar: {\n        baz: {\n          qux: 'Hello, World!'\n        }\n      }\n    }\n  },\n  template: `\n    {{ foo.bar.baz.qux }}\n  `\n})", 
            "title": "Keypaths"
        }, 
        {
            "location": "/legacy/0.9/concepts/#dot-and-bracket-notations", 
            "text": "Dot and bracket notation rules for keypaths are similar to vanilla JS. The only addition to this is that the dot notation can also be used to access arrays, by using the index directly on the segment.  const instance = Ractive({\n  data: {\n    items: [1, 2, 3],\n    foo: {\n      bar: {\n        baz: {\n          qux: 'Hello, World!',\n          'dotted.key': 'Me, Hungry!'\n        }\n      }\n    },\n    dynamicKey: 'bar'\n  },\n  template: `\n    {{ foo['bar']['baz']['qux'] }}  !-- bracket notation object access -- \n    {{ foo.bar.baz.qux }}           !-- dot notation object access -- \n\n    {{ items[0] }}  !-- bracket notation array access -- \n    {{ items.0 }}   !-- dot notation array access -- \n\n    {{ foo.bar.baz['dotted.key'] }}  !-- dotted key access -- \n\n    {{ foo[dynamicKey].baz.qux }}  !-- dynamic key access -- \n  `\n})", 
            "title": "Dot and bracket notations"
        }, 
        {
            "location": "/legacy/0.9/concepts/#missing-properties", 
            "text": "In JavaScript, trying to access a child property of an object that does not exist would throw an error. In Ractive, it would simply return  undefined  or render nothing.  const instance = Ractive({\n  data: {\n    numbers: [ 1, 2, 3 ]\n  },\n  template: `\n    {{ letters[0] }}\n  `\n})\n\nractive.get( 'letters[0]' ) // undefined", 
            "title": "Missing properties"
        }, 
        {
            "location": "/legacy/0.9/concepts/#upstream-and-downstream-keypaths", 
            "text": "Ractive has this concept of \"upstream\" and \"downstream\" keypaths. Upstream keypaths are ancestor keypaths. For the keypath  foo.bar.baz.qux , it's upstream keypaths are  foo ,  foo.bar  and  foo.bar.baz . Downstream keypaths are descendant keypaths. For the  foo  keypath, it's downstream keypaths would be  foo.bar ,  foo.bar.baz  and  foo.bar.baz.qux .", 
            "title": "Upstream and downstream keypaths"
        }, 
        {
            "location": "/legacy/0.9/concepts/#references", 
            "text": "A reference is a string that refers to a piece of data. A keypath is an example of a reference, one that points to a specific location in the data. Special references are also a form of reference, one that provides to a certain value.", 
            "title": "References"
        }, 
        {
            "location": "/legacy/0.9/concepts/#reference-resolution", 
            "text": "Ractive follows the following resolution algorithm to find the value of a reference:   If the reference a special reference, resolve with that keypath.  If the reference is explicit or matches a path in the current context exactly, resolve with that keypath.  Grab the current virtual node from the template hierarchy.  If the reference matches an alias, section indexes, or keys, resolve with that keypath.  If the reference matches any mappings, resolve with that keypath.  If the reference matches a path on the context, resolve with that keypath.  Remove the innermost context from the stack. Repeat steps 3-7.  If the reference is a valid keypath by itself, resolve with that keypath.  If the reference is still unresolved, add it to the 'pending resolution' pile. Each time potentially matching keypaths are updated, resolution will be attempted for the unresolved reference.", 
            "title": "Reference resolution"
        }, 
        {
            "location": "/legacy/0.9/concepts/#context-stack", 
            "text": "Whenever Ractive encounters section mustaches or similar constructs, it stores the context in a  context stack . Ractive then resolves references relative to the top of the stack, and popping off contexts until the reference resolves to a keypath.  Ractive({\n  data: {\n    qux: 'Me, Hungry!',\n    foo: {\n      bar: {\n        baz: 'Hello, World!'\n      }\n    }\n  },\n  template: `\n                 !-- context is the root of the data -- \n    {{#foo}}     !-- context is now foo -- \n      {{#bar}}   !-- context is now foo.bar -- \n        {{baz}}  !-- Resolution order: foo.bar.baz, foo.baz, baz. Resolved at foo.bar.baz. -- \n        {{qux}}  !-- Resolution order: foo.bar.quz, foo.qux, qux. Resolved at qux. -- \n      {{/}}\n    {{/}}\n  `,\n})", 
            "title": "Context stack"
        }, 
        {
            "location": "/legacy/0.9/concepts/#conditional-attributes", 
            "text": "Sections can toggle attributes, whether it's one attribute, multiple attributes or specific values of the attribute.  !-- one attribute --  a href= /  {{#if currentPage}}class= active {{/if}} Home /a  !-- multiple attributes --  a href= /  {{#if currentPage}}class= active  title= Current page {{/if}} Home /a  !-- specific attribute value --  a href= /  class= nav-link {{#if currentPage}}nav-link--active{{/if}} Home /a", 
            "title": "Conditional attributes"
        }, 
        {
            "location": "/legacy/0.9/concepts/#optimization", 
            "text": "", 
            "title": "Optimization"
        }, 
        {
            "location": "/legacy/0.9/concepts/#pre-parsing", 
            "text": "Parsing templates can be a very slow operation. As an optimization option, templates can be pre-parsed outside of runtime, speeding up app initialization. Most loaders do pre-parsing of templates as part of their build process. A parsed template is approximately 30-40% larger than the markup version, making it a trade-off between space and processing.", 
            "title": "Pre-parsing"
        }, 
        {
            "location": "/legacy/0.9/concepts/#limiting-template-expressions", 
            "text": "While expressions provide power and convenience when building templates, it incurs a performance penalty as Ractive sets up each one on a per-instance level. To avoid this overhead, there are several places where logic can move to, trimming down expressions into mere function calls.  Functions can be set on the data globally via  Ractive.defaults.data .  Ractive.defaults.data.customLogic = function () { ... }\n\nRactive({\n  template: `\n    {{ customLogic() }}\n  `\n})  Functions can also be defined on a component level using methods.  const Component = Ractive.extend({\n  template: `\n    {{ @this.customLogic() }}\n  `,\n  customLogic () {\n    ...\n  }\n})", 
            "title": "Limiting template expressions"
        }, 
        {
            "location": "/legacy/0.9/concepts/#expression-processing", 
            "text": "When Ractive parses a template, it creates a string representation of the expression structure and keeps track of its dependencies. Then Ractive converts these expression strings into a function which can be called to generate the expression's value.  Ractive optimizes this routine starting by generating the same expression string for structurally-identical expressions. Then a value-generating function is created for each  distinct  expression string, cached globally and shared to all instances. Furthermore, Ractive caches the generated values and only updates them when the expression's dependencies update.  // Expression parsing\nRactive.parse('{{ a + b }}{{ c + d }}')\n\n// {\n//    v : 4,\n//    t : [\n//     {\n//        t : 2,\n//        x : {\n//          r : [ a , b ],  -- dependencies here\n//          s :  _0+_1      -- expression string here\n//       }\n//     },\n//     {\n//        t : 2,\n//        x : {\n//          r : [ c , d ],  -- dependencies here\n//          s :  _0+_1      -- expression string here\n//       }\n//     }\n//   ],\n//    e : {}\n// }\n\n// Building and caching of the expression resolver of `_0+_1`\nconst expressionFunctionsCache = {}\nexpressionFunctionsCache['_0+_1'] = new Function('_0', '_1', 'return _0+_1')\n\n// Evaluate {{ a + b }}\nconst dep = ['a', 'b']\nconst exp = '_0+_1'\nconst arg = dep.map(instance.get)\nconst val = expressionFunctionsCache[exp].apply(instance, arg)\n\n// Evaluate {{ c + d }}\nconst dep = ['c', 'd']\nconst exp = '_0+_1'\nconst arg = dep.map(instance.get)\nconst val = expressionFunctionsCache[exp].apply(instance, arg)  The  Function  constructor was chosen over  eval  because it allows Ractive to compile the expression string  once  as well as  cache  the resulting function, instead of evaluating the string every time the value is needed.", 
            "title": "Expression processing"
        }
    ]
}